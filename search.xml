<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[python系统性能信息模块-psutil]]></title>
      <url>http://codeinterviews.com/python%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9D%97-pstuil/</url>
      <content type="html"><![CDATA[<p>psutil模块能够轻松获取系统能够运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。主要用于系统监控，分析和限制系统资源及进程的管理。</p>
<p>它实现了很多同等命令行工具提供的功能，如ps、top、df等。</p>
<a id="more"></a>
<h2 id="一-psutil的安装与基本使用"><a href="#一-psutil的安装与基本使用" class="headerlink" title="一. psutil的安装与基本使用"></a>一. psutil的安装与基本使用</h2><p>楼主本人使用的系统是osx 10.11.1。使用的python版本是系统自带的2.7.10.</p>
<h4 id="下载软件包"><a href="#下载软件包" class="headerlink" title="下载软件包"></a>下载软件包</h4><p>psutil的下载网址为:<a href="https://pypi.python.org/simple/psutil/" target="_blank" rel="external">下载网址</a>。然后选择<code>psutil-3.2.2.tar.gz</code>进行下载。</p>
<p>具体安装步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. tar -zxvf psutil-3.2.2.tar.gz</span><br><span class="line">2. cd psutil-3.2.2</span><br><span class="line">3. sudo python setup.py install</span><br></pre></td></tr></table></figure>
<h4 id="psutil的基本使用"><a href="#psutil的基本使用" class="headerlink" title="psutil的基本使用"></a>psutil的基本使用</h4><p>首先需要进行模块的导入，然后就可以进行使用了，具体事例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import psutil  </span><br><span class="line">print psutil.virtual_memory()</span><br></pre></td></tr></table></figure>
<h2 id="二-系统性能信息"><a href="#二-系统性能信息" class="headerlink" title="二. 系统性能信息"></a>二. 系统性能信息</h2><p>psutil模块已经分装了系统性能信息的方法，主要分为以下几个方面：</p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 获取CPU完整信息  </span><br><span class="line">print psutil.cpu_times()  </span><br><span class="line"></span><br><span class="line"># 获取单项数据信息,如user的CPU时间比  </span><br><span class="line">print psutil.cpu_times().user  </span><br><span class="line"></span><br><span class="line"># 获取cpu的逻辑个数  </span><br><span class="line">print psutil.cpu_count()  </span><br><span class="line"></span><br><span class="line"># 获取cpu的物理个数  </span><br><span class="line">print psutil.cpu_count(logical=False)</span><br></pre></td></tr></table></figure>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#获取内存全部信息</span><br><span class="line">print psutil.virtual_memory()</span><br><span class="line"></span><br><span class="line">#获取内存总数</span><br><span class="line">print psutil.virtual_memory().total</span><br><span class="line"></span><br><span class="line">#获取空闲内存属</span><br><span class="line">print psutil.virtual_memory().free</span><br><span class="line"></span><br><span class="line">#获取SWAP分区信息</span><br><span class="line">print psutil.swap_memory()</span><br></pre></td></tr></table></figure>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#获取磁盘的完整信息</span><br><span class="line">print psutil.disk_partitions()</span><br><span class="line"></span><br><span class="line">#获取分区的使用情况</span><br><span class="line">print psutil.disk_usage(&apos;/&apos;)</span><br><span class="line"></span><br><span class="line">#获取硬盘总的IO个数</span><br><span class="line">print psutil.disk_io_counters()</span><br><span class="line"></span><br><span class="line">#获取单个分区IO个数</span><br><span class="line">print psutil.disk_io_counters(perdisk=True)</span><br></pre></td></tr></table></figure>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#获取网络总的IO信息</span><br><span class="line">print psutil.net_io_counters()</span><br><span class="line"></span><br><span class="line">#获取每个网络接口的IO信息</span><br><span class="line">print psutil.net_io_counters(pernic=True)</span><br></pre></td></tr></table></figure>
<p>####其他系统信息（登陆用户，开机时间）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取当前登陆系统的用户信息</span><br><span class="line">print psutil.users()</span><br><span class="line"></span><br><span class="line">#获取开机时间,以linux时间戳的格式返回</span><br><span class="line">import datetime</span><br><span class="line">print datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br></pre></td></tr></table></figure>
<p>##三. 系统进程管理方法<br>获取当前系统的进程信息，可以得知程序的运行状态，包括进程的启动时间、查看或设置CPU亲和度、内存使用率、IO信息、socket链接、线程数等，通过这些信息可以很好的看出进程的状态，以便进行优化。</p>
<p>####进程信息<br>获取全部进程的信息，或者根据一个进程ID得到进程的process对象，然后获取该进程的一些信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#获取所有进程的PID</span><br><span class="line">print psutil.pids()</span><br><span class="line"></span><br><span class="line">#实例化一个process对象,参数为一个进程PID</span><br><span class="line">p=psutil.Process(1788)</span><br><span class="line">print p.name() #进程名</span><br><span class="line">print p.exe()  #进程路径</span><br><span class="line">print p.cwd() #进程工作目录绝对路径</span><br><span class="line">print p.status() #进程的状态</span><br><span class="line">print p.create_time() #进程创建的时间</span><br><span class="line">print p.uids() #进程uid信息</span><br><span class="line">print p.gids() #进程gid信息</span><br><span class="line">print p.cpu_times() #进程CPU时间信息</span><br><span class="line">print p.cpu_affinity() #进程cpu亲和度</span><br><span class="line">print p.memory_percent() #进程内存利用率</span><br><span class="line">print p.memory_info() #进程内存rss,vms信息</span><br><span class="line">print p.io_counters() #进程IO信息</span><br><span class="line">print p.connections() #打开进程socket的namedutples列表</span><br><span class="line">print p.num_threads() #进程开启的线程数</span><br></pre></td></tr></table></figure>
<p>####Popen类的使用<br>psutil提供的Popen类的作用是获取用户启动的应用程序进程信息，以便跟踪程序进程的运行状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#通过psutil的Popen方法启动的应用程序,可以进行跟踪</span><br><span class="line">from subprocess import PIPE</span><br><span class="line">p=psutil.Popen([&quot;/usr/bin/python&quot;,&quot;-c&quot;,&quot;print(&apos;hello&apos;)&quot;],stdout=PIPE)</span><br><span class="line">print p.name()</span><br><span class="line">print p.username()</span><br><span class="line">print p.cpu_times()</span><br></pre></td></tr></table></figure>
<p>##四. 参考文档</p>
<ol>
<li><a href="https://github.com/xwzpp/psutil" target="_blank" rel="external">psutil的github地址</a></li>
<li><a href="http://pythonhosted.org/psutil/" target="_blank" rel="external">psutil的文档说明</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[System Design Preparation]]></title>
      <url>http://codeinterviews.com/System%20Design%20Preparation/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="https://www.hackerrank.com/domains" target="_blank" rel="external">https://www.hackerrank.com/domains</a></li>
<li><a href="https://oj.leetcode.com/problemset/algorithms/" target="_blank" rel="external">https://oj.leetcode.com/problemset/algorithms/</a> LeetCode至少要刷三遍，付费部分的题建议花点钱看一下，舍不得孩子套不着狼</li>
<li><a href="http://lintcode.com/" target="_blank" rel="external">http://lintcode.com/</a></li>
<li><a href="http://new.ninechapter.com/solutions/" target="_blank" rel="external">http://new.ninechapter.com/solutions/</a></li>
<li><a href="http://www.geeksforgeeks.org/about/interview-corner/" target="_blank" rel="external">http://www.geeksforgeeks.org/about/interview-corner/</a></li>
<li>TopCoder Algorithm Tutorial: <a href="http://help.topcoder.com/data-science/competing-in-algorithm-challenges/algorithm-tutorials/" target="_blank" rel="external">http://help.topcoder.com/data-science/competing-in-algorithm-challenges/algorithm-tutorials/</a> 其中几何算法的教程要仔细看，Google特爱出几何题</li>
<li>CC150: Cracking the Code Interview: <a href="http://www.valleytalk.org/wp-content/uploads/2012/10/CrackCode.pdf" target="_blank" rel="external">http://www.valleytalk.org/wp-content/uploads/2012/10/CrackCode.pdf</a></li>
<li>CareerCup: <a href="http://www.careercup.com/page" target="_blank" rel="external">http://www.careercup.com/page</a></li>
<li>Glassdoor: <a href="http://www.glassdoor.com/Interview/index.htm" target="_blank" rel="external">http://www.glassdoor.com/Interview/index.htm</a></li>
</ul>
<p><a href="http://blog.csdn.net/longyulu/article/details/9159589" target="_blank" rel="external">http://blog.csdn.net/longyulu/article/details/9159589</a></p>
<p>Here are some articles about system design related topics.</p>
<ul>
<li>How to Rock a Systems Design Interview</li>
<li>System Interview</li>
<li>Scalability for Dummies</li>
<li>Scalable Web Architecture and Distributed Systems</li>
<li>Numbers Everyone Should Know</li>
<li>Scalable System Design Patterns</li>
<li>Introduction to Architecting Systems for Scale</li>
<li>Transactions Across Datacenters</li>
<li>A Plain English Introduction to CAP Theorem</li>
<li>The CAP FAQ</li>
<li>Paxos Made Simple</li>
<li>Consistent Hashing</li>
<li>NOSQL Patterns</li>
<li>Scalability, Availability &amp; Stability Patterns</li>
</ul>
<p>There are some good references for each question. The references here are slides and articles.</p>
<ul>
<li><p><strong>Design a CDN network </strong><br>Reference:<br>Globally Distributed Content Delivery.</p>
</li>
<li><p><strong>Design a Google document system</strong><br>Reference:<br>google-mobwrite<br>Differential Synchronization.</p>
</li>
<li><p><strong>Design a random ID generation system  </strong><br>Reference:<br>Announcing Snowflake<br>snowflake.</p>
</li>
<li><p><strong>Design a key-value database  </strong><br>Reference:<br>Introduction to Redis.</p>
</li>
<li><p><strong>Design the Facebook news seed function  </strong><br>Reference:<br>What are best practices for building something like a News Feed?<br>[<a href="http://www.weiming.info/zhuti/JobHunting/32463885/][11" target="_blank" rel="external">http://www.weiming.info/zhuti/JobHunting/32463885/][11</a>]<br>What are the scaling issues to keep in mind while developing a social network feed?<br>Activity Feeds Architecture<br><a href="http://www.weiming.info/zhuti/JobHunting/32463885/" target="_blank" rel="external">http://www.weiming.info/zhuti/JobHunting/32463885/</a></p>
</li>
<li><p><strong>Design the Facebook timeline function   </strong><br>Reference:<br>Building Timeline<br>Facebook Timeline.</p>
</li>
<li><p><strong>Design a function to return the top k requests during past time interval   </strong><br>Reference:<br>Efficient Computation of Frequent and Top-k Elements in Data Streams<br>An Optimal Strategy for Monitoring Top-k Queries in Streaming Windows</p>
</li>
<li><p><strong>Design an online multiplayer card game   </strong><br>Reference:<br>How to Create an Asynchronous Multiplayer Game<br>How to Create an Asynchronous Multiplayer Game Part 2: Saving the Game State to Online Database<br>How to Create an Asynchronous Multiplayer Game Part 3: Loading Games from the Database<br>How to Create an Asynchronous Multiplayer Game Part 4: Matchmaking<br>Real Time Multiplayer in HTML5</p>
</li>
<li><p><strong>Design a graph search function   </strong><br>Reference:<br>Building out the infrastructure for Graph Search<br>Indexing and ranking in Graph Search<br>The natural language interface of Graph Search and Erlang at Facebook.</p>
</li>
<li><p><strong>Design a picture sharing system  </strong><br>Reference:<br>Flickr Architecture<br>Instagram Architecture.</p>
</li>
<li><p><strong>Design a search engine   </strong><br>Reference:<br>How would you implement Google Search?<br>Implementing Search Engines</p>
</li>
<li><p><strong>Design a recommendation system   </strong><br>Reference:<br>Hulu’s Recommendation System<br>Recommender Systems</p>
</li>
<li><p><strong>Design a tiny url system   </strong><br>Reference:<br>System Design for Big Data-tinyurl<br>URL Shortener API.</p>
</li>
<li><p><strong>Design a garbage collection system   </strong><br>Reference:<br>Baby’s First Garbage Collector.</p>
</li>
<li><p><strong>Design a scalable web crawling system  </strong><br>Reference:<br>Design and Implementation of a High-Performance Distributed Web Crawler</p>
</li>
<li><p><strong>Design the Facebook chat function   </strong><br>Reference:<br>Erlang at Facebook<br>Facebook Chat<br><a href="http://www.cnblogs.com/piaoger/archive/2012/08/19/2646530.html" target="_blank" rel="external">http://www.cnblogs.com/piaoger/archive/2012/08/19/2646530.html</a></p>
</li>
<li><p><strong>Design a trending topic system   </strong><br>Reference:<br>Implementing Real-Time Trending Topics With a Distributed Rolling Count Algorithm in Storm<br>Early detection of Twitter trends explained</p>
</li>
<li><p><strong>Design a cache system   </strong><br>Reference:<br>Introduction to Memcached<br><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="external">https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/</a><br><a href="http://www.careercup.com/question?id=16835665" target="_blank" rel="external">http://www.careercup.com/question?id=16835665</a></p>
</li>
<li><p><strong>Design a typeahead search/search suggestion  </strong><br>Reference:<br><a href="https://www.facebook.com/notes/facebook-engineering/the-life-of-a-typeahead-query/389105248919" target="_blank" rel="external">https://www.facebook.com/notes/facebook-engineering/the-life-of-a-typeahead-query/389105248919</a></p>
</li>
<li><p><strong>Design a system to return POI within 5 miles  </strong><br>Reference:<br><a href="http://blog.sina.com.cn/s/blog_ae33b83901017921.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_ae33b83901017921.html</a><br><a href="http://www.cnblogs.com/LBSer/p/3310455.html" target="_blank" rel="external">http://www.cnblogs.com/LBSer/p/3310455.html</a></p>
</li>
<li><p><strong>Copy one file to multiple servers  </strong><br>Reference:<br><a href="https://vimeo.com/11280885" target="_blank" rel="external">https://vimeo.com/11280885</a><br><a href="https://blog.twitter.com/2010/murder-fast-datacenter-code-deploys-using-bittorrent" target="_blank" rel="external">https://blog.twitter.com/2010/murder-fast-datacenter-code-deploys-using-bittorrent</a></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Resevior Sampling蓄水池算法java实现]]></title>
      <url>http://codeinterviews.com/Resevior%20Sampling/</url>
      <content type="html"><![CDATA[<h1 id="Resevior-Sampling"><a href="#Resevior-Sampling" class="headerlink" title="Resevior Sampling"></a>Resevior Sampling</h1><blockquote>
<p>Randomly return the index of maximal elements in the array.<br>follow up: 要求linear time 和constant space</p>
</blockquote>
<p>先把前k个数放入蓄水池，对第k+1，我们以k/(k+1)概率决定是否要把它换入蓄水池，换入时随机的选取一个作为替换项，这样一直做下去，对于任意的样本空间n，对每个数的选取概率都为k/n。也就是说对每个数选取概率相等。</p>
<ul>
<li>Create an array reservoir[0..k-1] and copy first k items of stream[] to it.</li>
<li>Now one by one consider all items from (k+1)th item to nth item.</li>
<li>Generate a random number from 0 to i where i is index of current item in stream[]. Let the generated random number is j.</li>
<li>If j is in range 0 to k-1, replace reservoir[j] with arr[i]</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length();</span><br><span class="line">	<span class="keyword">int</span> ret =-<span class="number">1</span>, max = INT_MIN;</span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]==max)&#123;</span><br><span class="line">			count++;</span><br><span class="line">			srand(time(NULL));</span><br><span class="line">			<span class="keyword">int</span> judge = rand()%count;</span><br><span class="line">			<span class="keyword">if</span>(judge==<span class="number">0</span>)&#123;</span><br><span class="line">				ret = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(max==INT_MIN || arr[i]&gt;max)&#123;</span><br><span class="line">			max = arr[i];</span><br><span class="line">			ret = i;</span><br><span class="line">			count=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Top 25 Angular.js Interview Questions]]></title>
      <url>http://codeinterviews.com/Top%2025%20Angular.js%20Interview%20Questions/</url>
      <content type="html"><![CDATA[<blockquote>
<p>1) What is Angular.js? </p>
</blockquote>
<p>AngularJS is a javascript framework used for creating single web page applications. It allows you to use HTML as your template language and enables you to extend HTML’s syntax to express your application’s components clearly </p>
<blockquote>
<p>2) Explain what are the key features of Angular.js ? </p>
</blockquote>
<p>The key features of angular.js are:<br>Scope<br>Controller<br>Model<br>View<br>Services<br>Data Binding<br>Directives<br>Filters<br>Testable </p>
<blockquote>
<p>3) Explain what is scope in Angular.js ? </p>
</blockquote>
<p>Scope refers to the application model, it acts like glue between application controller and the view. Scopes are arranged in hierarchical structure and impersonate the DOM ( Document Object Model) structure of the application. It can watch expressions and propagate events. </p>
<blockquote>
<p>4) Explain what is services in Angular.js ? </p>
</blockquote>
<p>In angular.js services are the singleton objects or functions that are used for carrying out specific tasks. It holds some business logic and these function can be called as controllers, directive, filters and so on. </p>
<blockquote>
<p>5) Explain what is Angular Expression? Explain what is key difference between angular expressions and JavaScript expressions? </p>
</blockquote>
<p>Like JavaScript, Angular expressions are code snippets that are usually placed in binding such as </p>
<p>The key difference between the JavaScript expressions and Angular expressions </p>
<p>Context : In Angular, the expressions are evaluated against a scope object, while the Javascript expressions are evaluated against the global window<br>Forgiving: In Angular expression evaluation is forgiving to null and undefined, while in Javascript undefined properties generates TypeError or ReferenceError<br>No Control Flow Statements: Loops, conditionals or exceptions cannot be used in an angular expression </p>
<blockquote>
<p>6) With options on page load how you can initialize a select box ? </p>
</blockquote>
<p>You can initialize a select box with options on page load by using ng-init directive </p>
<blockquote>
<p>7) Explain what are directives ? Mention some of the most commonly used directives in Angular.js application ? </p>
</blockquote>
<p>A directive is something that introduces new syntax, they are like markers on DOM element which attaches a special behavior to it. In any Angular.js application, directives are the most important components. </p>
<p>Some of the commonly used directives are ng-model, ng-App, ng-bind, ng-repeat , ng-show etc. </p>
<blockquote>
<p>8) Mention what are the advantages of using Angular.js ? </p>
</blockquote>
<p>Angular.js has several advantages in web development. </p>
<p>Angular.js supports MVS pattern<br>Can do two ways data binding using Angular.js<br>It has per-defined form validations<br>It supports both client server communication<br>It supports animations </p>
<blockquote>
<p>9) Explain what Angular JS routes does ? </p>
</blockquote>
<p>Angular js routes enable you to create different URLs for different content in your application. Different URLs for different content enables user to bookmark URLs to specific content. Each such bookmark able URL in Angular.js is called a route </p>
<p>A value in Angular JS is a simple object. It can be a number, string or JavaScript object. Values are typically used as configuration injected into factories, services or controllers. A value should be belong to an Angular.js module. </p>
<p>Injecting a value into an Angular.js controller function is done by adding a parameter with the same name as the value </p>
<blockquote>
<p>10) Explain what is data binding in Angular.js ? </p>
</blockquote>
<p>Automatic synchronization of data between the model and view components is referred as data binding in Angular.js. There are two ways for data binding </p>
<p>Data mining in classical template systems<br>Data binding in angular templates </p>
<blockquote>
<p>11) What makes angular.js better ? </p>
</blockquote>
<p>Registering Callbacks: There is no need to register callbacks . This makes your code simple and easy to debug.<br>Control HTML DOM programmatically: All the application that are created using Angular never have to manipulate the DOM although it can be done if it is required<br>Transfer data to and from the UI: Angular.js helps to eliminate almost all of the boiler plate like validating the form, displaying validation errors, returning to an internal model and so on which occurs due to flow of marshaling data<br>No initialization code: With angular.js you can bootstrap your app easily using services, which auto-injected into your application in Guice like dependency injection style </p>
<blockquote>
<p>12) Explain what is string interpolation in angular.js ? </p>
</blockquote>
<p>In angular.js the compiler during the compilation process matches text and attributes using interpolate service to see if they contains embedded expressions. As part of normal digest cycle these expressions are updated and registered as watches. </p>
<blockquote>
<p>13) Mention the steps for the compilation process of HTML happens? </p>
</blockquote>
<p>Compilation of HTML process occurs in following ways </p>
<p>Using the standard browser API, first the HTML is parsed into DOM<br>By using the call to the $compile () method, compilation of the DOM is performed. The method traverses the DOM and matches the directives.<br>Link the template with scope by calling the linking function returned from the previous step </p>
<blockquote>
<p>14) Explain what is directive and Mention what are the different types of Directive? </p>
</blockquote>
<p>During compilation process when specific HTML constructs are encountered a behavior or function is triggered, this function is referred as directive. It is executed when the compiler encounters it in the DOM. </p>
<p>Different types of directives are </p>
<p>Element directives<br>Attribute directives<br>CSS class directives<br>Comment directives </p>
<blockquote>
<p>15) Explain what is linking function and type of linking function? </p>
</blockquote>
<p>Link combines the directives with a scope and produce a live view. For registering DOM listeners as well as updating the DOM, link function is responsible. After the template is cloned it is executed. </p>
<p>Pre-linking function: Pre-linking function is executed before the child elements are linked. It is not considered as the safe way for DOM transformation.<br>Post linking function: Post linking function is executed after the child elements are linked. It is safe to do DOM transformation by post-linking function </p>
<blockquote>
<p>16) Explain what is injector? </p>
</blockquote>
<p>An injector is a service locator. It is used to retrieve object instances as defined by provider, instantiate types, invoke methods and load modules. There is a single injector per Angular application, it helps to look up an object instance by its name. </p>
<blockquote>
<p>17) Explain what is the difference between link and compile in angular.js? </p>
</blockquote>
<p>Compile function: It is used for template DOM Manipulation and collect all of the directives.<br>Link function: It is used for registering DOM listeners as well as instance DOM manipulation. It is executed once the template has been cloned. </p>
<blockquote>
<p>18) Explain what is factory method in angular.js? </p>
</blockquote>
<p>For creating the directive, factory method is used. It is invoked only once, when compiler matches the directive for the first time. By using $injector.invoke the factory method is invoked. </p>
<blockquote>
<p>19) Mention what are the styling form that ngModel adds to CSS classes ? </p>
</blockquote>
<p>ngModel adds these CSS classes to allow styling of form as well as control </p>
<p>ng- valid<br>ng- invalid<br>ng-pristine<br>ng-dirty </p>
<blockquote>
<p>20) Mention what are the characteristics of “Scope”? </p>
</blockquote>
<p>To observer model mutations scopes provide APIs ($watch)<br>To propagate any model changes through the system into the view from outside of the Angular realm<br>A scope inherits properties from its parent scope, while providing access to shared model properties, scopes can be nested to isolate application components<br>Scope provides context against which expressions are evaluated </p>
<blockquote>
<p>21) Explain what is DI (Dependency Injection ) and how an object or function can get a hold of its dependencies ? </p>
</blockquote>
<p>DI or Dependency Injection is a software design pattern that deals with how code gets hold of its dependencies. In order to retrieve elements of the application which is required to be configured when module gets loaded , the operation “config” uses dependency injection. </p>
<p>These are the ways that object uses to hold of its dependencies </p>
<p>Typically using the new operator, dependency can be created<br>By referring to a global variable, dependency can be looked up<br>Dependency can be passed into where it is required </p>
<blockquote>
<p>22) Mention what are the advantages of using Angular.js framework ? </p>
</blockquote>
<p>Advantages of using Angular.js as framework are </p>
<p>Supports two way data-binding<br>Supports MVC pattern<br>Support static template and angular template<br>Can add custom directive<br>Supports REST full services<br>Supports form validations<br>Support both client and server communication<br>Support dependency injection<br>Applying Animations<br>Event Handlers </p>
<blockquote>
<p>23) Explain the concept of scope hierarchy? How many scope can an application have? </p>
</blockquote>
<p>Each angular application consist of one root scope but may have several child scopes. As child controllers and some directives create new child scopes, application can have multiple scopes. When new scopes are formed or created they are added as a children of their parent scope. Similar to DOM, they also creates a hierarchical structure. </p>
<blockquote>
<p>24) Explain what is the difference between angular.js and backbone.js? </p>
</blockquote>
<p>Angular.js combines the functionalities of most of the 3rd party libraries, it supports individual functionalities required to develop HTML5 Apps. While Backbone.js do their jobs individually. </p>
<blockquote>
<p>25) Who created Angular JS ? </p>
</blockquote>
<p>Intially it was developed by Misko Hevery and Adam Abrons. Currently it is being developed by Google. </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NodeJS 学习资料]]></title>
      <url>http://codeinterviews.com/NodeJS-Learning/</url>
      <content type="html"><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Go to <a href="http://nodejs.org/" target="_blank" rel="external">http://nodejs.org/</a>, download node.js installer and follow instructions. Mac OS, Windows, and Linux are supported. </p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>To use Node.js you need to have a decent understanding of JavaScript language. </p>
<ul>
<li><a href="http://www.codecademy.com/tracks/javascript" target="_blank" rel="external">Codecademy - JS</a> - Good for practicing and learning syntax.</li>
<li><a href="http://yuiblog.com/crockford/" target="_blank" rel="external">Crockford’s videos</a></li>
<li><a href="http://eloquentjavascript.net/" target="_blank" rel="external">Eloquent JavaScript</a></li>
<li><a href="http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="external">Essential JavaScript Design Patterns For Beginners</a></li>
<li><a href="http://blog.buymeasoda.com/advanced-javascript-fundamentals/" target="_blank" rel="external">Advanced JavaScript Fundamentals</a></li>
<li><a href="http://javascriptissexy.com/understand-javascript-closures-with-ease/" target="_blank" rel="external">Understand JavaScript Closures With Ease</a></li>
<li><a href="http://bonsaiden.github.com/JavaScript-Garden/" target="_blank" rel="external">JavaScript garden</a></li>
<li><a href="http://oreilly.com/catalog/9780596806767" target="_blank" rel="external">JavaScript Patterns Book</a></li>
<li><a href="http://oreilly.com/catalog/9780596517748/" target="_blank" rel="external">JavaScript: The Good Parts Book</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/es6/promises/" target="_blank" rel="external">JavaScript Promises</a></li>
</ul>
<h2 id="Development-Tools-IDEs"><a href="#Development-Tools-IDEs" class="headerlink" title="Development Tools/IDEs"></a>Development Tools/IDEs</h2><ul>
<li><a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a> - Project and modules generator</li>
<li><a href="http://gulpjs.com/" target="_blank" rel="external">Gulp</a> - Task runner/build system</li>
<li><a href="http://eric-xujun.github.io/sergtitov/NodeJS-Learning/blob/master" target="_blank" rel="external">Grunt</a> - Task runner/build system</li>
<li><a href="http://www.jetbrains.com/webstorm/" target="_blank" rel="external">WebStorm/PHPStorm</a> - popular and extremely powerful IDE for coding web applications. Paid but you can get it for free , if you are an open-source developer (required an application approval).</li>
<li><a href="https://nodejstools.codeplex.com/" target="_blank" rel="external">Node.js Tools for Visual Studio</a> - see <a href="http://www.hanselman.com/blog/IntroducingNodejsToolsForVisualStudio.aspx" target="_blank" rel="external">blog post</a> from team member Scott Hanselman.</li>
<li>NetBeans with <a href="http://plugins.netbeans.org/plugin/36653/nodejs" target="_blank" rel="external">Node.js plugin</a></li>
<li><a href="https://github.com/tanepiper/SublimeText-Nodejs" target="_blank" rel="external">Nodejs Sublime Text 2 Package</a> - a set of code completion, scripts and tools to work with Node.js.</li>
<li><a href="http://www.microsoft.com/web/webmatrix/" target="_blank" rel="external">WebMatrix</a> - is a free, lightweight, cloud-connected web development tool from Microsoft.</li>
<li><a href="http://krillapps.com/coderunner/" target="_blank" rel="external">CodeRunner</a> - Mac only paid IDE.</li>
<li><a href="http://www.activestate.com/komodo-ide/features" target="_blank" rel="external">Komodo</a> - full-featured IDE from ActiveState is paid but there is also lean free version <a href="http://www.activestate.com/komodo-edit" target="_blank" rel="external">Komodo Edit</a>.</li>
<li><a href="http://coreh.github.io/nide/" target="_blank" rel="external">Nide</a> - is a web-based IDE for Node.JS that can run locally or on a remote server. Available both as a command-line tool and as a standalone Mac app.</li>
<li><a href="http://www.nodeclipse.org/" target="_blank" rel="external">Nodeclipse &amp; Enide</a> - is free open-source IDE based on Eclipse.</li>
<li><a href="http://www.aptana.com/" target="_blank" rel="external">Aptana Studio</a></li>
<li><a href="https://github.com/scripted-editor/scripted" target="_blank" rel="external">Scripted</a></li>
<li><a href="http://brackets.io/" target="_blank" rel="external">Brackets</a></li>
</ul>
<h3 id="Online"><a href="#Online" class="headerlink" title="Online"></a>Online</h3><ul>
<li><a href="https://c9.io/" target="_blank" rel="external">Cloud9</a> - cloud-based IDE with native support for development of Node.js applications including debugging and other features. Note that you can also <a href="http://www.cambus.net/setting-up-a-node-js-development-environment-with-npm-and-cloud9-ide-installed-locally/" target="_blank" rel="external">install it locally</a>.</li>
<li><a href="https://www.nitrous.io/" target="_blank" rel="external">Nitrous.io</a> - is both an IDE and environment in the cloud. Has both online and desktop versions. Paid.</li>
<li><a href="https://koding.com" target="_blank" rel="external">Koding</a> - offers you a free bootable VM with Node. Also you can work on the same code with your friends.</li>
<li><a href="https://codenvy.com/" target="_blank" rel="external">Cloud IDE (a.k.a eXo Cloud IDE, a.k.a cod envy)</a> - cloud development IDE and environment with continuous integration and other features. Offers both hosted and on-premises solutions.</li>
</ul>
<h2 id="Hosting-Providers"><a href="#Hosting-Providers" class="headerlink" title="Hosting Providers"></a>Hosting Providers</h2><ul>
<li><a href="https://www.nodejitsu.com/" target="_blank" rel="external">Nodejitsu</a> - hosting, databases and private NPM. Free for Open Source.</li>
<li><a href="https://www.openshift.com/developers/node-js" target="_blank" rel="external">OpenShift</a></li>
<li><a href="https://devcenter.heroku.com/articles/getting-started-with-nodejs" target="_blank" rel="external">Heroku</a> - Dead simple to use.</li>
<li><a href="https://modulus.io/" target="_blank" rel="external">Modulus</a> -Scalable application platform (PaaS) for developers, offering Node.js hosting, MongoDB, and performance analytics in the cloud.</li>
<li><a href="https://codio.com/" target="_blank" rel="external">Codio</a> - Powerful web based IDE, free for public projects</li>
</ul>
<h2 id="Fundamentals"><a href="#Fundamentals" class="headerlink" title="Fundamentals"></a>Fundamentals</h2><ul>
<li><a href="http://webapplog.com/node-js-fundamentals-a-concise-overview-of-the-main-concepts" target="_blank" rel="external">Node.js FUNdamentals: A Concise Overview of The Main Concepts</a></li>
<li>Why Node.js<ul>
<li><a href="http://www.toptal.com/nodejs/why-the-hell-would-i-use-node-js" target="_blank" rel="external">Why The Hell Would I Use Node.js? A Case-by-Case Introduction</a></li>
<li><a href="http://pettergraff.blogspot.com/2013/01/why-node.html" target="_blank" rel="external">Why I use Node.js?</a></li>
<li><a href="http://webapplog.com/php-vs-node-js/" target="_blank" rel="external">PHP vs. Node.js</a></li>
</ul>
</li>
<li>Migrating to Node.js<ul>
<li><a href="https://engineering.groupon.com/2013/misc/i-tier-dismantling-the-monoliths/" target="_blank" rel="external">Dismantling the Monoliths</a></li>
<li><a href="https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/" target="_blank" rel="external">Node.js at PayPal</a></li>
</ul>
</li>
<li><a href="http://nodejs.org/api/" target="_blank" rel="external">Official Documentation</a></li>
<li>CommonJS Module System<ul>
<li><a href="http://docs.nodejitsu.com/articles/getting-started/what-is-require" target="_blank" rel="external">http://docs.nodejitsu.com/articles/getting-started/what-is-require</a>)</li>
<li><a href="http://pages.citebite.com/i9e9e4d1yxip" target="_blank" rel="external">http://pages.citebite.com/i9e9e4d1yxip</a></li>
</ul>
</li>
<li><a href="http://nodejs.org/api/modules.html" target="_blank" rel="external">Node.js Modules Official Documentation</a></li>
<li><a href="http://howtonode.org/managing-module-dependencies" target="_blank" rel="external">Managing module dependencies</a></li>
<li><a href="http://code.tutsplus.com/tutorials/using-nodes-event-module--net-35941" target="_blank" rel="external">Using Node’s Event Module</a></li>
<li><a href="http://openmymind.net/2012/2/3/Node-Require-and-Exports/" target="_blank" rel="external">Understanding exports vs. module.exports</a></li>
</ul>
<h2 id="Asynchronous-Programming"><a href="#Asynchronous-Programming" class="headerlink" title="Asynchronous Programming"></a>Asynchronous Programming</h2><ul>
<li><a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/" target="_blank" rel="external">Understanding the node.js event loop</a></li>
</ul>
<ul>
<li><a href="http://www.slideshare.net/cacois/avoiding-callback-hell-with-asyncjs" target="_blank" rel="external">Avoiding Callback Hell with Async.js</a></li>
</ul>
<ul>
<li><p>Promises </p>
<ul>
<li><a href="http://howtonode.org/promises" target="_blank" rel="external">Asynchronous Control Flow with Promises</a></li>
<li><a href="http://www.slideshare.net/async_io/javascript-promisesq-library-17206726" target="_blank" rel="external">Promises with Q</a></li>
</ul>
</li>
<li><a href="http://www.sitepoint.com/javascript-generators-preventing-callback-hell/" target="_blank" rel="external">ES6 Generators and Preventing Callback Hell</a></li>
<li><a href="http://strongloop.com/strongblog/node-js-callback-hell-promises-generators/?utm_source=nodeweekly&amp;utm_medium=email" target="_blank" rel="external">Managing Node.js Callback Hell with Promises, Generators and Other Approaches</a></li>
</ul>
<h2 id="Node-Package-Manager-nam"><a href="#Node-Package-Manager-nam" class="headerlink" title="Node Package Manager (nam)"></a>Node Package Manager (nam)</h2><ul>
<li><a href="http://docs.nodejitsu.com/articles/getting-started/npm/what-is-npm" target="_blank" rel="external">What is nam?</a></li>
<li><a href="http://howtonode.org/introduction-to-npm" target="_blank" rel="external">Introduction to npm</a></li>
<li>Explore <a href="https://npmjs.org/" target="_blank" rel="external">registered public nam modules</a></li>
<li><a href="https://gist.github.com/coolaj86/1318304" target="_blank" rel="external">How to publish your module to nam?</a></li>
<li>Node.js tips and tricks<ul>
<li><a href="http://blog.ponyfoo.com/2013/12/14/9-quick-tips-about-npm" target="_blank" rel="external">9 Quick Tips About npm</a></li>
<li><a href="http://www.devthought.com/2012/02/17/npm-tricks/" target="_blank" rel="external">NPM tricks</a></li>
<li><a href="http://substack.net/task_automation_with_npm_run" target="_blank" rel="external">Task automation with nam run</a></li>
</ul>
</li>
<li>Private NPM approaches<ul>
<li><a href="http://clock.co.uk/tech-blogs/how-to-create-a-private-npmjs-repository" target="_blank" rel="external">How to create a private npm.js repository</a></li>
<li><a href="https://github.com/paypal/kappa" target="_blank" rel="external">A hierarchical nom-registry proxy that allows to support private nam repos without replicating the entire public registry</a></li>
<li><a href="https://github.com/mixu/npm_lazy" target="_blank" rel="external">A lazy local cache for npm</a></li>
</ul>
</li>
</ul>
<h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><ul>
<li><a href="http://strongloop.com/strongblog/whats-new-nodejs-v0-12-debugging-clusters/" target="_blank" rel="external">What’s New in Node.js v0.12: Debugging Clustered Apps with Node-Inspector</a></li>
<li><a href="http://www.youtube.com/watch?v=03qGA-GJXjI" target="_blank" rel="external">Video: Debugging Node.js with node-inspector</a></li>
<li><a href="https://github.com/node-inspector/node-inspector" target="_blank" rel="external">node-inspector</a></li>
<li><a href="https://github.com/joyent/node/wiki/Using-Eclipse-as-Node-Applications-Debugger" target="_blank" rel="external">Using Eclipse as Node Applications Debugger</a></li>
</ul>
<h2 id="Tutorials"><a href="#Tutorials" class="headerlink" title="Tutorials"></a>Tutorials</h2><ul>
<li><a href="http://nodeschool.io/" target="_blank" rel="external">http://nodeschool.io/</a></li>
<li><a href="https://www.codeschool.com/courses/real-time-web-with-nodejs" target="_blank" rel="external">https://www.codeschool.com/courses/real-time-web-with-nodejs</a></li>
<li><a href="http://cwbuecheler.com/web/tutorials/2013/node-express-mongo/" target="_blank" rel="external">The dead-simple step-by-step guide for front-end developers to getting up and running with node.js, express, jade, and mongodb</a></li>
<li><a href="http://webapplog.com/todo-app-with-express-jsnode-js-and-mongodb/" target="_blank" rel="external">Make a RESTful todo app</a></li>
<li><a href="http://scotch.io/tutorials/javascript/easy-node-authentication-setup-and-local" target="_blank" rel="external">Authentication</a> - Goes over local, Facebook &amp; twitter authentication.</li>
</ul>
<h3 id="Command-line"><a href="#Command-line" class="headerlink" title="Command line"></a>Command line</h3><ul>
<li><a href="http://javascriptplayground.com/blog/2012/08/writing-a-command-line-node-tool/" target="_blank" rel="external">Command line tool</a></li>
</ul>
<h2 id="Blog-posts-articles"><a href="#Blog-posts-articles" class="headerlink" title="Blog posts/articles"></a>Blog posts/articles</h2><ul>
<li><a href="http://www.joyent.com/developers/node" target="_blank" rel="external">Node.js Production Practices</a> - fantastic overview of design, deployment and debugging technics from <a href="http://www.joyent.com/" target="_blank" rel="external">Joyent</a>.</li>
</ul>
<h2 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h2><ul>
<li><a href="http://www.youtube.com/watch?v=jo_B4LTHi3I" target="_blank" rel="external">Introduction to Node.js with Ryan Dahl</a> - Ryan Dahl is a Node.js creator. Must see.</li>
<li><a href="http://www.youtube.com/watch?v=BN0JlMZCtNU" target="_blank" rel="external">Alex Ford: Node.js &amp; Express 101</a></li>
<li><a href="http://lanyrd.com/topics/nodejs/video/" target="_blank" rel="external">142 conference presentation Videos</a> from <a href="http://lanyrd.com/" target="_blank" rel="external">Lanyard.com</a></li>
<li><a href="http://nodetuts.com/" target="_blank" rel="external">Node.js video tutorials by Pedro Teixeira</a></li>
<li><a href="http://vidinterest.com/playlist/enbeeone3/nodejs-tutorial-videos" target="_blank" rel="external">Collection of node.js video tutorials</a> at <a href="http://eric-xujun.github.io/sergtitov/NodeJS-Learning/blob/master/vidinterest.com" target="_blank" rel="external">vidinterest.com</a></li>
<li><a href="http://vimeo.com/70603516" target="_blank" rel="external">Node.js has Arrived!</a> - In this video, Node.js core committer Bert Belder discusses some of the new features in Node v0.12 including Streams3, VM improvements, cluster round-robin, execSync and profiling APIs.</li>
<li><a href="http://channel9.msdn.com/Series/Visual-Studio-Online-Monaco/Getting-started-with-nodejs" target="_blank" rel="external">Getting started with node.js</a> at <a href="http://eric-xujun.github.io/sergtitov/NodeJS-Learning/blob/master/channel9.msdn.com" target="_blank" rel="external">channel9.msdn.com</a> -<a href="http://www.youtube.com/watch?v=eD2I0zAjM5g&amp;list=PLw2e3dFxewkLL73aUzOP-efQnXOTtMLbY" target="_blank" rel="external">Basics of Express and Mongo</a> -<a href="http://irlnathan.github.io/sailscasts/" target="_blank" rel="external">Getting Started with Sails.js</a> -<a href="http://www.youtube.com/watch?v=SAc0vQCC6UQ" target="_blank" rel="external">History of Node.js</a></li>
</ul>
<h2 id="Free-Courses"><a href="#Free-Courses" class="headerlink" title="Free Courses"></a>Free Courses</h2><ul>
<li><a href="https://www.coursera.org/course/startup" target="_blank" rel="external">Startup engineering by Stanford</a></li>
</ul>
<h2 id="Paid-Courses"><a href="#Paid-Courses" class="headerlink" title="Paid Courses"></a>Paid Courses</h2><ul>
<li><a href="https://www.codeschool.com/courses/real-time-web-with-nodejs" target="_blank" rel="external">Real-time Web with Node.js</a> from <a href="https://www.codeschool.com/" target="_blank" rel="external">codeschool.com</a></li>
<li><a href="http://teamtreehouse.com/library/code-racer/getting-started-with-nodejs-and-the-npm-package-manager" target="_blank" rel="external">Getting Started with Node.js and the NPM Package Manager</a> from <a href="http://teamtreehouse.com/" target="_blank" rel="external">Treehouse</a>.</li>
<li><a href="http://www.lynda.com/Nodejs-tutorials/Nodejs-First-Look/101554-2.html" target="_blank" rel="external">Node.js First Look</a>(beginner) and <a href="http://www.lynda.com/JavaScript-tutorials/Nodejs-Essential-Training/141132-2.html" target="_blank" rel="external">Node.js Essential Training</a>(advanced) at <a href="http://www.lynda.com/Node-js-training-tutorials/1283-0.html" target="_blank" rel="external">lynda.com</a></li>
<li><a href="https://peepcode.com/products/nodejs-i" target="_blank" rel="external">Meet Node.js</a> and <a href="https://peepcode.com/products/full-stack-nodejs-i" target="_blank" rel="external">Full-stack Node.js</a> at <a href="http://eric-xujun.github.io/sergtitov/NodeJS-Learning/blob/master/peepcode.com" target="_blank" rel="external">peepcode.com</a></li>
<li>Node.js courses at Pluralsight<ul>
<li><a href="http://pluralsight.com/training/courses/TableOfContents?courseName=meet-nodejs" target="_blank" rel="external">Meet Node.js</a></li>
<li><a href="http://pluralsight.com/training/courses/TableOfContents?courseName=node-intro" target="_blank" rel="external">Introduction to Node.js</a></li>
<li><a href="http://pluralsight.com/training/courses/TableOfContents?courseName=full-stack-nodejs" target="_blank" rel="external">Full Stack Node.js</a></li>
<li><a href="http://pluralsight.com/training/courses/TableOfContents?courseName=building-angularjs-nodejs-apps-mean" target="_blank" rel="external">Building AngularJS and Node.js Apps with the MEAN Stack</a></li>
<li><a href="http://pluralsight.com/training/courses/TableOfContents?courseName=expressjs" target="_blank" rel="external">Web Development with ExpressJS</a></li>
<li><a href="http://pluralsight.com/training/courses/TableOfContents?courseName=node-on-azure" target="_blank" rel="external">Node on Windows and Azure</a></li>
</ul>
</li>
</ul>
<h2 id="Free-Books"><a href="#Free-Books" class="headerlink" title="Free Books"></a>Free Books</h2><ul>
<li><a href="http://www.nodebeginner.org/#about" target="_blank" rel="external">The Node Beginner Book</a></li>
<li><a href="https://github.com/maxogden/art-of-node" target="_blank" rel="external">The Art of Node</a></li>
<li><a href="https://leanpub.com/jsfun/read" target="_blank" rel="external">JavaScript and Node FUNdamentals</a></li>
<li><a href="http://book.mixu.net/node/" target="_blank" rel="external">Mixu’s Node book</a></li>
<li><a href="http://book.rednode.cn/" target="_blank" rel="external">A collection of Node.js books</a></li>
<li><a href="http://visionmedia.github.io/masteringnode/" target="_blank" rel="external">Mastering Node.js</a></li>
</ul>
<h2 id="Paid-Books"><a href="#Paid-Books" class="headerlink" title="Paid Books"></a>Paid Books</h2><ul>
<li><a href="http://www.amazon.com/Node-js-Action-Mike-Cantelon/dp/1617290572/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1391739265&amp;sr=1-1&amp;keywords=%22node.js%22" target="_blank" rel="external">Node.js in Action</a></li>
<li><a href="http://www.amazon.com/Learning-Node-js-Hands-On-Applications-JavaScript/dp/0321910575/ref=sr_1_1?ie=UTF8&amp;qid=1394518585&amp;sr=8-1&amp;keywords=learning+node.js" target="_blank" rel="external">Learning Node.js: A Hands-On Guide to Building Web Applications in JavaScript Marc Wandschneide</a></li>
<li><a href="http://www.amazon.com/JavaScript-Server-Node-js-Express-Development/dp/0956737080/ref=sr_1_20?s=books&amp;ie=UTF8&amp;qid=1391739340&amp;sr=1-20&amp;keywords=%22node.js%22" target="_blank" rel="external">JavaScript on the Server Using Node.js and Express</a></li>
<li><a href="http://www.amazon.com/Express-js-Guide-Comprehensive-Book/dp/1494269279/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1391740486&amp;sr=1-2&amp;keywords=%22node.js%22+express" target="_blank" rel="external">Express.js Guide</a></li>
<li><a href="http://www.amazon.com/Node-js-Right-Way-Server-Side-JavaScript/dp/1937785734/ref=sr_1_1?ie=UTF8&amp;qid=1393208626&amp;sr=8-1&amp;keywords=Node+js+The+Right+Way." target="_blank" rel="external">Node js The Right Way</a></li>
<li><a href="http://learnjs.io/" target="_blank" rel="external">Learn JS</a></li>
</ul>
<h2 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks"></a>Frameworks</h2><ul>
<li>Sinatra like:<ul>
<li><a href="https://github.com/senchalabs/connect" target="_blank" rel="external">connect</a> - an extensible HTTP server framework for Node.js using “plugins” known as middleware.</li>
<li><a href="http://expressjs.com/guide.html" target="_blank" rel="external">express.js</a> - a Sinatra inspired Web development framework for Node.js.</li>
<li><a href="https://github.com/spumko/hapi" target="_blank" rel="external">hapi</a> - a rich framework for building Web applications and services.</li>
<li><a href="https://github.com/techpines/express.io" target="_blank" rel="external">express.io</a> = Express + Socket.io.</li>
<li><a href="https://github.com/koajs/koa" target="_blank" rel="external">koa</a> - an expressive middleware for Node.js using generators.</li>
<li><a href="https://github.com/flatiron/flatiron" target="_blank" rel="external">Flatiron</a> - framework components for Node.js and a browser.</li>
<li><a href="https://github.com/totaljs/framework" target="_blank" rel="external">total.js</a> - a Web application framework for creating rich Web sites and Web services.</li>
</ul>
</li>
<li>MVC: </li>
</ul>
<pre><code>* [Geddy][129] - a simple, structured Web framework for Node.js.
* [Sails.js][130] - a realtime MVC Framework for Node.js.
* [Compound][131] - the compound formula is Express + Structure + Extensions.
</code></pre><ul>
<li>Full stack: </li>
</ul>
<pre><code>* [meteor.js][132] - Meteor is an ultra-simple environment for building modern Web applications. Built using Node.js, Meteor is a framework on its own. Please see an [amazing list of Meteor resources][133] for more information.
* [Derby][134] - the MVC framework making it easy to write realtime, collaborative applications that run in both Node.js and browsers.
* [SocketStream][135] - A fast, modular Node.js Web framework dedicated to building realtime single-page applications.
</code></pre><p>If you would like to learn more about Node.js frameworks, please visit <a href="http://nodeframework.com/" target="_blank" rel="external">nodeframework.com</a> and <a href="http://nodewebmodules.com" target="_blank" rel="external">nodewebmodules.com</a>. </p>
<h2 id="CLI-TOOLS"><a href="#CLI-TOOLS" class="headerlink" title="CLI TOOLS"></a>CLI TOOLS</h2><ul>
<li><a href="http://remysharp.com/2014/01/20/nodemon-1-0/" target="_blank" rel="external">Nodemon</a></li>
</ul>
<h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><ul>
<li><a href="https://ghost.org/" target="_blank" rel="external">Ghost</a></li>
<li><a href="http://keystonejs.com/" target="_blank" rel="external">Keystone</a></li>
<li><a href="http://calip.so/" target="_blank" rel="external">Calipso</a></li>
<li><a href="http://hatchjs.com/" target="_blank" rel="external">Hatch</a></li>
</ul>
<h2 id="Static-Site-Generators"><a href="#Static-Site-Generators" class="headerlink" title="Static Site Generators"></a>Static Site Generators</h2><ul>
<li><a href="http://hexo.io/" target="_blank" rel="external">Hexo</a> - fast, simple &amp; powerful blog framework.</li>
<li><a href="http://www.metalsmith.io/" target="_blank" rel="external">Metalsmith</a> - extremely simple, pluggable static site generator.</li>
<li><a href="http://harpjs.com/" target="_blank" rel="external">Harp</a> - static web server with built-in preprocessing.</li>
<li><a href="http://assemble.io/" target="_blank" rel="external">Assemble</a> - static site generator for Grunt.js, Yeoman and Node.js.</li>
<li><a href="https://github.com/creationix/wheat" target="_blank" rel="external">Wheat</a> - a blog engine for coders written in node.JS.</li>
<li><a href="https://github.com/laktek/punch" target="_blank" rel="external">Punch</a> - a fun and easy way to build modern websites.</li>
<li><a href="https://github.com/flatiron/blacksmith" target="_blank" rel="external">Blacksmith</a> - generic static site generator built using flatiron, plates, and marked.</li>
<li><a href="https://github.com/jsantell/poet" target="_blank" rel="external">Poet</a> - a node.js blog engine.</li>
</ul>
<blockquote>
<p>See extensive collection of Static Site Generators including other languages at <a href="http://www.staticgen.com/" target="_blank" rel="external">http://www.staticgen.com/</a></p>
</blockquote>
<h2 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h2><ul>
<li><a href="https://github.com/LearnBoost/socket.io" target="_blank" rel="external">socket.io</a> - a realtime application framework for Node.JS, with HTML5 WebSockets and cross-browser fallbacks support.</li>
<li><a href="https://github.com/LearnBoost/mongoose" target="_blank" rel="external">mongoose</a> - MongoDB object modeling designed to work in an asynchronous environment.</li>
<li><a href="http://github.com/flatiron/winston" target="_blank" rel="external">winston</a> - a multi-transport asynchronous logging library for Node.js</li>
<li><a href="https://github.com/jaredhanson/passport" target="_blank" rel="external">passport</a> - simple, unobtrusive authentication for Node.js.</li>
<li><a href="https://github.com/caolan/async" target="_blank" rel="external">async</a> - asynchronous utilities for Node and the browser.</li>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a> - a tool for making and composing asynchronous promises in JavaScript.</li>
<li><a href="https://github.com/visionmedia/co" target="_blank" rel="external">co</a> - the ultimate generator based flow-control goodness for nodes;</li>
<li><a href="https://github.com/visionmedia/jade" target="_blank" rel="external">jade</a> - Jade - a robust, elegant, feature-rich template engine for Node.js.</li>
<li><a href="https://github.com/visionmedia/ejs" target="_blank" rel="external">ejs</a> - embedded JavaScript templates for Node.js.</li>
<li><a href="https://github.com/lodash/lodash" target="_blank" rel="external">lodash</a> - a utility library delivering consistency, customization, performance, and extras.</li>
<li><a href="https://github.com/mikeal/request" target="_blank" rel="external">request</a> - a simplified HTTP request client.</li>
<li><a href="https://github.com/lorenwest/node-config" target="_blank" rel="external">config</a> - a runtime configuration for Node.js. modules.</li>
<li><a href="http://passportjs.org/" target="_blank" rel="external">Passport</a> - simple, unobtrusive authentication for Node.js that supports OpenID and OAuth.</li>
</ul>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>Read about various approaches to testing Node.js code: </p>
<ul>
<li><a href="http://code.tutsplus.com/tutorials/testing-in-nodejs--net-35018" target="_blank" rel="external">Testing in Node.js</a></li>
<li><a href="http://www.slideshare.net/mlilley/testing-node-js-with-mocha" target="_blank" rel="external">Testing NodeJS with Mocha, Should, Sinon, and JSCoverage</a></li>
<li><a href="http://www.seejohncode.com/2012/03/13/setting-up-mocha-jscoverage/" target="_blank" rel="external">Setting up Mocha and JSCoverage</a></li>
<li><a href="http://www.scotchmedia.com/tutorials/express/authentication/2/02" target="_blank" rel="external">Acceptance testing with supertest</a></li>
<li><a href="http://blog.codeship.io/2013/08/20/testing-tuesday-19-how-to-test-node-js-applications-with-jasmine.html" target="_blank" rel="external">Testing node.js applications with Jasmine</a></li>
<li><a href="http://howtonode.org/mocking-private-dependencies-using-rewire" target="_blank" rel="external">Mocking Dependencies using [rewire]</a></li>
</ul>
<p>Some popular testing frameworks: </p>
<ul>
<li><a href="https://github.com/visionmedia/mocha" target="_blank" rel="external">mocha</a> - a simple, flexible JavaScript test framework for Node.js and a browser. (BDD, TDD, QUnit styles via interfaces).</li>
<li><a href="https://github.com/mhevery/jasmine-node" target="_blank" rel="external">jasmin-node</a> - integration of the Jasmine Spec framework with Node.js.</li>
<li><a href="https://github.com/cjohansen/Sinon.JS" target="_blank" rel="external">sinon</a> - test spies, stubs, and mocks for JavaScript.</li>
<li><a href="https://github.com/chaijs/chai" target="_blank" rel="external">chai</a> - a BDD / TDD assertion framework for Node.js and a browser.</li>
<li><a href="https://github.com/visionmedia/supertest" target="_blank" rel="external">supertest</a> - a super-agent driven library for testing Node.js HTTP servers using a fluent API.</li>
<li><a href="https://github.com/jhnns/rewire" target="_blank" rel="external">rewire</a> - a dependency injection for Node.js applications.</li>
<li><a href="https://github.com/visionmedia/node-jscoverage" target="_blank" rel="external">node-jscoverage</a> - JSCoverage for Node.js.</li>
</ul>
<h3 id="What-To-Read"><a href="#What-To-Read" class="headerlink" title="What To Read"></a>What To Read</h3><h3 id="Communities-Groups"><a href="#Communities-Groups" class="headerlink" title="Communities/Groups"></a>Communities/Groups</h3><ul>
<li><a href="https://groups.google.com/forum/#!forum/nodejs" target="_blank" rel="external">Google Node.js Group</a></li>
<li><a href="https://plus.google.com/communities/115365528781941125390" target="_blank" rel="external">Google+ Node.js Community</a></li>
<li><a href="http://cnodejs.org/" target="_blank" rel="external">CNode</a> - Node.js professional Chinese community</li>
<li><a href="http://www.reddit.com/r/node/" target="_blank" rel="external">Node.js on Reddit</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/node.js" target="_blank" rel="external">Stackoverflow Node.js tag</a></li>
<li><a href="http://www.nodejsforums.com" target="_blank" rel="external">NodeJsForums.com</a></li>
<li>IRC - For real-time chat about Node development go to <a href="http://eric-xujun.github.io/sergtitov/NodeJS-Learning/blob/master/irc.freenode.net" target="_blank" rel="external">irc.freenode.net</a> in the <strong>#node.js</strong> channel with an <a href="http://colloquy.info/" target="_blank" rel="external">IRC client</a> or connect in your web browser to the channel using <a href="http://webchat.freenode.net/?channels=node.js" target="_blank" rel="external">freenode’s WebChat</a>.</li>
</ul>
<h2 id="Blogs-News"><a href="#Blogs-News" class="headerlink" title="Blogs/News"></a>Blogs/News</h2><ul>
<li><a href="http://howtonode.org/" target="_blank" rel="external">“How To Node” blog</a></li>
<li><a href="http://nodeweekly.com/" target="_blank" rel="external">Node.js Weekly</a> - an email list that gathers up the latest events and news from around the Node.js community.</li>
<li><a href="http://nodeup.com/" target="_blank" rel="external">NodeUp</a> - a podcast covering the latest Node news in the community.</li>
</ul>
<h3 id="Who-to-Follow"><a href="#Who-to-Follow" class="headerlink" title="Who to Follow"></a>Who to Follow</h3><ul>
<li><a href="https://github.com/visionmedia" target="_blank" rel="external">TJ Holowachuk</a> - express, Jade, Mocha, Stylus</li>
<li><a href="https://github.com/isaacs" target="_blank" rel="external">Isaac Z. Schlueter</a> - maintainer of Node.js / NPM</li>
<li><a href="https://github.com/mikeal" target="_blank" rel="external">Mikeal Rogers</a> - Request</li>
<li><a href="https://github.com/substack" target="_blank" rel="external">James Haliday “substack”</a> - Browserify, dnode, Optimist</li>
<li><a href="https://github.com/guille" target="_blank" rel="external">Guillermo Rauch</a> - Socket.IO</li>
</ul>
<h3 id="Node-mavens"><a href="#Node-mavens" class="headerlink" title="Node mavens"></a>Node mavens</h3><p>You can find the most famous Node.js developer at <a href="http://nodemavens.com/" target="_blank" rel="external">Nodemavens</a>. </p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><ul>
<li><a href="http://yuan.rednode.cn/resource" target="_blank" rel="external">Rednode garden</a></li>
<li><a href="http://nodecloud.com" target="_blank" rel="external">Nodecloud</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Rotate List]]></title>
      <url>http://codeinterviews.com/Rotate-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Rotate List</p>
<blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and <code>k = 2</code>,<br>return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这是一道链表操作的题目，基本思路是设置两个指针<code>i</code>,<code>j</code>,中间相差<code>n</code>,用walker-runner定位到要旋转的那个结点，然后将下一个结点设为新表头，并且把当前结点设为表尾。设置前后两个指针，然后推进前进的方法称为<strong>尺取法</strong>。</p>
<p>但是这里需要注意的是<code>n</code>超过链表长度，此时步数应该重新跑到结尾点计算，即<code>j</code>指针从新回到头结点处。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> head;</span><br><span class="line">        ListNode i=<span class="keyword">null</span>;  <span class="comment">//定义两个指针</span></span><br><span class="line">        ListNode j=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">        &#123;</span><br><span class="line">        	j=j.next;</span><br><span class="line">        	<span class="keyword">if</span>(j==<span class="keyword">null</span>)   <span class="comment">//n的长度超过链表，j重新回到头结点</span></span><br><span class="line">        		j=head;</span><br><span class="line">        &#125;</span><br><span class="line">        i=head;</span><br><span class="line">        <span class="keyword">while</span>(j.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	j=j.next;</span><br><span class="line">        	i=i.next;</span><br><span class="line">        &#125;</span><br><span class="line">        j.next=head;  <span class="comment">//进行旋转</span></span><br><span class="line">        head=i.next;</span><br><span class="line">        i.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Best Time to Buy and Sell Stock II]]></title>
      <url>http://codeinterviews.com/Best-Time-to-Buy-and-Sell-Stock-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Best Time to Buy and Sell Stock II</p>
<blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题跟<a href="http://pisxw.com/algorithm/Best-Time-to-Buy-and-Sell-Stock.html" target="_blank" rel="external">Best Time to Buy and Sell Stock</a>类似，求最大利润。区别是这里可以交易无限多次（当然我们知道交易不会超过n-1次，也就是每天都进行先卖然后买）。既然交易次数没有限定，可以看出我们只要对于每次两天差价大于0的都进行交易，就可以得到最大利润。因此算法其实就是累加所有大于0的差价既可以了，非常简单。如此只需要一次扫描就可以了</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该题由于可以无限次数的买入卖出，所以最大利润应该就是相邻两天差价不为0的利润之和</span></span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> degit=prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">        	<span class="keyword">if</span>(degit&gt;<span class="number">0</span>)</span><br><span class="line">        		res+=degit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Best Time to Buy and Sell Stock IV]]></title>
      <url>http://codeinterviews.com/Best-Time-to-Buy-and-Sell-Stock-IV/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Best Time to Buy and Sell Stock IV</p>
<blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>####Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>####Credits:<br>Special thanks to @Freezen for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题与<a href="http://pisxw.com/algorithm/Best-Time-to-Buy-and-Sell-Stock-III.html" target="_blank" rel="external">Best Time to Buy and Sell Stock III</a>思路是一样的。这里同样采用动态规划进行求解，仍然使用局部最优和全局最优解法由于要考虑交易次数，因此维护量应该就是一个二维数组。</p>
<pre><code>定义维护量：
global[i][j]:表示从第1天到第i天，最多交易j次的最好的利润
local[i][j]:当前到达第i天，最多可进行j次交易，并且最后一次交易在当天卖出的最好的利润是多少
定义递推式：
global[i][j]=max(global[i-1][j],local[i][j]);即第i天没有交易，和第i天有交易
local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)  diff=price[i]-price[i-1];
就是看两个量，第一个是全局到i-1天进行j-1次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要j-1次交易，最后一次交易取当前天），第二个量则是取local第i-1天j次交易，然后加上今天的差值（这里因为local[i-1][j]比如包含第i-1天卖出的交易，所以现在变成第i天卖出，并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，因为否则就不满足local[i][j]必须在最后一天卖出的条件了）。
需要注意的是：第i天卖出的交易数是算在前i-1天买入的那次交易中的。
</code></pre><p>需要注意的事，test case中，有一个非常大的k值，直接会让内存分配失败。</p>
<p>如何处理该种情况呢。 当k值超过prices值的个数时，此时，可以把问题转换为交易数次不限的情况。即</p>
<p><a href="http://pisxw.com/algorithm/Best-Time-to-Buy-and-Sell-Stock-II.html" target="_blank" rel="external">Best Time to Buy and Sell Stock II</a>中的解法。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>)</span><br><span class="line">       		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       		<span class="keyword">if</span>(k&gt;prices.length)</span><br><span class="line">       		&#123;</span><br><span class="line">       			<span class="keyword">if</span>(prices==<span class="keyword">null</span>)</span><br><span class="line">		            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">		        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)</span><br><span class="line">		        &#123;</span><br><span class="line">		            <span class="keyword">int</span> degit=prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">		            <span class="keyword">if</span>(degit&gt;<span class="number">0</span>)</span><br><span class="line">		                res+=degit;</span><br><span class="line">		        &#125;</span><br><span class="line">		        <span class="keyword">return</span> res;</span><br><span class="line">       		&#125;</span><br><span class="line">	        <span class="comment">/*</span><br><span class="line">	       定义维护量：</span><br><span class="line">	       global[i][j]:表示从第1天到第i天，最多交易j次的最大利润</span><br><span class="line">	       local[i][j]:表示第i天交易，最多交易次数为j次的最大利润，且最后一次肯定是在第i天卖出</span><br><span class="line">	       定义递推式：</span><br><span class="line">	       global[i][j]=max(global[i-1][j],local[i][j]);即第i天没有交易，和第i天有交易</span><br><span class="line">	       local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)  diff=price[i]-price[i-1];</span><br><span class="line">	        */</span></span><br><span class="line">	        <span class="keyword">int</span>[][] global=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>];</span><br><span class="line">	        <span class="keyword">int</span>[][] local=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length][k+<span class="number">1</span>];</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	            <span class="keyword">int</span> diff=prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">	            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k-<span class="number">1</span>;j++)</span><br><span class="line">	            &#123;</span><br><span class="line">	                local[i+<span class="number">1</span>][j+<span class="number">1</span>]=Math.max(global[i][j]+Math.max(diff,<span class="number">0</span>),local[i][j+<span class="number">1</span>]+diff);</span><br><span class="line">	                global[i+<span class="number">1</span>][j+<span class="number">1</span>]=Math.max(global[i][j+<span class="number">1</span>],local[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> global[prices.length-<span class="number">1</span>][k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Best Time to Buy and Sell Stock]]></title>
      <url>http://codeinterviews.com/Best-Time-to-Buy-and-Sell-Stock/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Best Time to Buy and Sell Stock</p>
<blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题求进行一次交易能得到的最大利润。如果用<code>brute force</code>的解法就是对每组交易都看一下利润，取其中最大的，总用有n*(n-1)/2个可能交易，所以复杂度是O(n^2)。<br>很容易感觉出来这是动态规划的题目,用“局部最优和全局最优解法”。思路是维护两个变量，一个是到目前为止最好的交易，另一个是在当前一天卖出的最佳交易（也就是局部最优）。递推式是</p>
<pre><code>local[i]:表示在第i天卖出的最佳交易
global[i]:表示从第1天开始到第i天的最好交易
local[i+1]=max(local[i]+prices[i+1]-price[i],0)
global[i+1]=max(local[i+1],global[i])
</code></pre><p>这样一次扫描就可以得到结果，时间复杂度是O(n)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义局部最优维护量</span></span><br><span class="line">        <span class="keyword">int</span> local=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义全局最优维护量</span></span><br><span class="line">        <span class="keyword">int</span> global=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	local=Math.max(<span class="number">0</span>,local+prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        	global=Math.max(global,local);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Search Tree Iterator]]></title>
      <url>http://codeinterviews.com/Binary-Search-Tree-Iterator%20/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Search Tree Iterator</p>
<blockquote>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p><strong>Note</strong>: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<p>####Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>就是找到以这个 root 为 根节点的最小的 值。 用一个 stack 作为buffer 来存储， 先存入 左边节点， 当输出以后， 再向右节点移动一个， 然后再存储 进去所有左节点， 和 <a href="http://pisxw.com/algorithm/Binary-Tree-Postorder-Traversal.html" target="_blank" rel="external">inorder 遍历 的非递归解法</a>一样。</p>
<p>易错点： 要检查 node.right ！＝ null， 才能向右移动， 否则就不用管， 意思就是向上移动一个。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">	LinkedList&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	stack.push(root);</span><br><span class="line">        	root=root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode cur=stack.pop();</span><br><span class="line">        <span class="keyword">int</span> res=cur.val;</span><br><span class="line">        <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	cur=cur.right;</span><br><span class="line">        	<span class="keyword">while</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		stack.push(cur);</span><br><span class="line">        		cur=cur.left;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = new BSTIterator(root);</span><br><span class="line"> * while (i.hasNext()) v[f()] = i.next();</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Tree Inorder Traversal]]></title>
      <url>http://codeinterviews.com/Binary-Tree-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Tree Inorder Traversal</p>
<blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return <code>[1,3,2]</code>.</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<p>confused what <code>&quot;{1,#,2,3}&quot;</code> means? &gt; read more on how binary tree is serialized on OJ.</p>
<p>####OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example:</p>
<pre><code>  1
 / \
2   3
   /
  4
   \
    5
</code></pre><p>The above binary tree is serialized as <code>&quot;{1,2,3,#,#,4,#,#,5}&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是树的中序遍历，熟知的方法是一是用递归，二是使用栈实现的迭代方法。</p>
<p>递归应该最常用的算法，相信大家都了解，算法的时间复杂度是O(n), 而空间复杂度则是递归栈的大小，即O(logn)。</p>
<p>迭代的做法，其实就是用一个栈来模拟递归的过程。所以算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。过程中维护一个node表示当前走到的结点（不是中序遍历的那个结点）。</p>
<p>当然，这里还有一个线索二叉树的方法：Morris Traversal。想用O(1)空间进行遍历，因为不能用栈作为辅助空间来保存付节点的信息，重点在于当访问到子节点的时候如何重新回到父节点（当然这里是指没有父节点指针，如果有其实就比较好办，一直找遍历的后驱结点即可）。<br>Morris遍历方法用了线索二叉树，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了。<br>算法具体分情况如下：</p>
<pre><code>1. 如果当前结点的左孩子为空，则输出当前结点并将其当前节点赋值为右孩子。   
2. 如果当前节点的左孩子不为空，则寻找当前节点在中序遍历下的前驱节点（也就是当前结点左子树的最右孩子）。接下来分两种情况：   
 a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点（做线索使得稍后可以重新返回父结点）。然后将当前节点更新为当前节点的左孩子。   
 b) 如果前驱节点的右孩子为当前节点，表明左子树已经访问完，可以访问当前节点。将它的右孩子重新设为空（恢复树的结构）。输出当前节点。当前节点更新为当前节点的右孩子。      
</code></pre><p>##算法代码<br>代码采用JAVA实现：</p>
<p>####递归代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        helper(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	helper(root.left,res);</span><br><span class="line">    	res.add(root.val);</span><br><span class="line">    	helper(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####迭代代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">	    <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">	        &#123;</span><br><span class="line">	            stack.push(root);</span><br><span class="line">	            root = root.left;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">else</span></span><br><span class="line">	        &#123;</span><br><span class="line">	            root = stack.pop();</span><br><span class="line">	            res.add(root.val);</span><br><span class="line">	            root = root.right;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####线索二叉树方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		    TreeNode cur = root;</span><br><span class="line">		    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">		    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		        <span class="keyword">if</span>(cur.left == <span class="keyword">null</span>)</span><br><span class="line">		        &#123;</span><br><span class="line">		            res.add(cur.val);</span><br><span class="line">		            cur = cur.right;</span><br><span class="line">		        &#125;</span><br><span class="line">		        <span class="keyword">else</span></span><br><span class="line">		        &#123;</span><br><span class="line">		            pre = cur.left;</span><br><span class="line">		            <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span> &amp;&amp; pre.right!=cur)</span><br><span class="line">		                pre = pre.right;</span><br><span class="line">		            <span class="keyword">if</span>(pre.right==<span class="keyword">null</span>)</span><br><span class="line">		            &#123;</span><br><span class="line">		                pre.right = cur;</span><br><span class="line">		                cur = cur.left;</span><br><span class="line">		            &#125;</span><br><span class="line">		            <span class="keyword">else</span></span><br><span class="line">		            &#123;</span><br><span class="line">		                pre.right = <span class="keyword">null</span>;</span><br><span class="line">		                res.add(cur.val);</span><br><span class="line">		                cur = cur.right;</span><br><span class="line">		            &#125;</span><br><span class="line">		        &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Tree Level Order Traversal II]]></title>
      <url>http://codeinterviews.com/Binary-Tree-Level-Order-Traversal-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Tree Level Order Traversal II</p>
<blockquote>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its bottom-up level order traversal as:</p>
<pre><code>[
  [15,7],
  [9,20],
  [3]
]
</code></pre><p>confused what <code>&quot;{1,#,2,3}&quot;</code> means? &gt; read more on how binary tree is serialized on OJ.</p>
<p>####OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example: </p>
<pre><code>  1
 / \
2   3
   /
  4
   \
    5
</code></pre><p>The above binary tree is serialized as <code>&quot;{1,2,3,#,#,4,#,#,5}&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题和<a href="http://pisxw.com/algorithm/Binary-Tree-Level-Order-Traversal.html" target="_blank" rel="external">Binary Tree Level Order Traversal</a>的解法相同，只不过在最后结果上是其结果的转置。</p>
<p>这道题我没有想到什么好的做法可以一次的自底向上进行层序遍历，能想到的就是进行<a href="http://pisxw.com/algorithm/Binary-Tree-Level-Order-Traversal.html" target="_blank" rel="external">Binary Tree Level Order Traversal</a>中的遍历，然后对结果进行一次reverse.</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    	ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> res;</span><br><span class="line">    	<span class="comment">//使用队列来存储节点</span></span><br><span class="line">    	LinkedList&lt;TreeNode&gt; queen=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    	<span class="comment">//使用队列来存储上述队列中节点的层数</span></span><br><span class="line">    	LinkedList&lt;Integer&gt; cequeen=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    	queen.addLast(root);</span><br><span class="line">    	cequeen.addLast(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">int</span> ce=<span class="number">0</span>;</span><br><span class="line">    	ArrayList&lt;Integer&gt; cur=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    	<span class="keyword">while</span>(!queen.isEmpty())</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(ce==cequeen.getFirst())</span><br><span class="line">    		&#123;</span><br><span class="line">    			TreeNode no=queen.removeFirst();</span><br><span class="line">    			<span class="keyword">int</span> cengshu=cequeen.removeFirst();</span><br><span class="line">    			cur.add(no.val);</span><br><span class="line">    			<span class="keyword">if</span>(no.left!=<span class="keyword">null</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				queen.addLast(no.left);</span><br><span class="line">    				cequeen.addLast(cengshu+<span class="number">1</span>);</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">if</span>(no.right!=<span class="keyword">null</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				queen.addLast(no.right);</span><br><span class="line">    				cequeen.addLast(cengshu+<span class="number">1</span>);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">    			ce++;</span><br><span class="line">    			cur.clear();</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//最后一次不要忘记加入</span></span><br><span class="line">    	res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">    	Collections.reverse(res);</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Tree Level Order Traversal]]></title>
      <url>http://codeinterviews.com/Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Tree Level Order Traversal</p>
<blockquote>
<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its level order traversal as:</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre><p>confused what <code>&quot;{1,#,2,3}&quot;</code> means? &gt; read more on how binary tree is serialized on OJ.</p>
<p>####OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example:</p>
<pre><code>  1
 / \
2   3
   /
  4
   \
    5
</code></pre><p>The above binary tree is serialized as <code>&quot;{1,2,3,#,#,4,#,#,5}&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对二叉树进行层次优先遍历，层次遍历主要采用队列的形式进行存储，通过将每个节点的左孩子和右孩子放入队列中，然后每次从队列中取出元素即可。在java中使用LinkedList来实现队列操作，其中主要方法为：入队：addLast(),出队：revomeFirst(),获取第一个元素：getFirst(),判断队列是否为空：isEmpty();</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="comment">//该队列中放入节点</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queen=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//该队列中放入queen中对应节点的层次</span></span><br><span class="line">        LinkedList&lt;Integer&gt; cequeen=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        queen.addLast(root);</span><br><span class="line">        cequeen.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> cengshu=<span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; cur=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queen.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> ce=cequeen.getFirst();</span><br><span class="line">        	<span class="keyword">if</span>(ce==cengshu)</span><br><span class="line">        	&#123;</span><br><span class="line">        		TreeNode no=queen.removeFirst();</span><br><span class="line">        		<span class="keyword">int</span> noce=cequeen.removeFirst();</span><br><span class="line">        		cur.add(no.val);</span><br><span class="line">        		<span class="keyword">if</span>(no.left!=<span class="keyword">null</span>)</span><br><span class="line">        		&#123;</span><br><span class="line">        			queen.addLast(no.left);</span><br><span class="line">        			cequeen.addLast(noce+<span class="number">1</span>);</span><br><span class="line">        		&#125; 			</span><br><span class="line">        		<span class="keyword">if</span>(no.right!=<span class="keyword">null</span>)</span><br><span class="line">        		&#123;</span><br><span class="line">        			queen.addLast(no.right);</span><br><span class="line">        			cequeen.addLast(noce+<span class="number">1</span>);</span><br><span class="line">        		&#125;       			</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">        		cur.clear();</span><br><span class="line">        		cengshu++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Tree Maximum Path Sum]]></title>
      <url>http://codeinterviews.com/Binary-Tree-Maximum-Path-Sum/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Tree Maximum Path Sum</p>
<blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree.</p>
<p>For example:<br>Given the below binary tree,   </p>
<pre><code>  1
 / \
2   3
</code></pre><p>Return <code>6</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是求树的路径和的题目，不过和平常不同的是这里的路径不仅可以从根到某一个结点，而且路径可以从左子树某一个结点，然后到达右子树的结点，就像题目中所说的可以起始和终结于任何结点。在这里树没有被看成有向图，而是被当成无向图来寻找路径。因为这个路径的灵活性，我们需要对递归返回值进行一些调整，而不是通常的返回要求的结果。在这里，函数的返回值定义为以自己为根的一条从根到子结点的最长路径（这里路径就不是当成无向图了，必须往单方向走）。这个返回值是为了提供给它的父结点计算自身的最长路径用，而结点自身的最长路径（也就是可以从左到右那种）则只需计算然后更新即可。这样一来，一个结点自身的最长路径就是它的左子树返回值（如果大于0的话），加上右子树的返回值（如果大于0的话），再加上自己的值。而返回值则是自己的值加上左子树返回值，右子树返回值或者0（注意这里是“或者”，而不是“加上”，因为返回值只取一支的路径和）。在过程中求得当前最长路径时比较一下是不是目前最长的，如果是则更新</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//由于java是值传递，但是我们需要在递归中保存最大的路径长度，因此定义个ArryList便于修改,其中保存最大的长度。</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        res.add(Integer.MIN_VALUE);</span><br><span class="line">        helper(root,res);</span><br><span class="line">        <span class="keyword">return</span> res.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里需要一个返回值，返回以root节点为根的从root节点出发的最长路径长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;Integer&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> left=helper(root.left,res); <span class="comment">//返回左子树的最长路径长度</span></span><br><span class="line">    	<span class="keyword">int</span> right=helper(root.right,res);<span class="comment">//返回右子树的最长路径长度</span></span><br><span class="line">    	<span class="keyword">int</span> cur=(left&gt;<span class="number">0</span>?left:<span class="number">0</span>)+(right&gt;<span class="number">0</span>?right:<span class="number">0</span>)+root.val; <span class="comment">//从左子树到右子树的路径长度</span></span><br><span class="line">    	<span class="keyword">if</span>(cur&gt;res.get(<span class="number">0</span>))</span><br><span class="line">    		res.set(<span class="number">0</span>,cur);</span><br><span class="line">    	<span class="keyword">return</span> root.val+Math.max(Math.max(left,<span class="number">0</span>),Math.max(right,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Tree Postorder Traversal]]></title>
      <url>http://codeinterviews.com/Binary-Tree-Postorder-Traversal/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Tree Postorder Traversal</p>
<blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return <code>[3,2,1]</code>.</p>
<p><strong>Note</strong>: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对二叉树进行后序遍历，如果使用递归求解非常简单，这里代码就不写了。</p>
<p>题目中要求不要使用递归写法，因此可以使用<strong>栈</strong>来将递归写法变成非递归写法。但是后序遍历的非递归算法还是比较复杂的。</p>
<p>最下面在弹栈的时候需要分情况一下：<br>1）如果当前栈顶元素的右结点存在并且还没访问过（也就是右结点不等于上一个访问结点），那么就把当前结点移到右结点继续循环；<br>2）如果栈顶元素右结点是空或者已经访问过，那么说明栈顶元素的左右子树都访问完毕，应该访问自己继续回溯了。</p>
<p>在下面代码中，都用相似的结构实现了前序，中序的遍历，以便于记忆。</p>
<p>##算法代码<br>代码采用JAVA实现：</p>
<p>先序遍历非递归：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postpreorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();<span class="comment">//定义栈</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		stack.push(root);</span><br><span class="line">        		res.add(root.val);</span><br><span class="line">        		root=root.left;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		root=stack.pop();</span><br><span class="line">        		root=root.right;</span><br><span class="line">        	&#125;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>中序遍历非递归：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postinorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();<span class="comment">//定义栈</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(root!=<span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		stack.push(root);</span><br><span class="line">        		root=root.left;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		root=stack.pop();</span><br><span class="line">        		res.add(root.val);</span><br><span class="line">        		root=root.right;</span><br><span class="line">        	&#125;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后序遍历非递归：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();<span class="comment">//定义栈</span></span><br><span class="line">        TreeNode pre=<span class="keyword">null</span>;<span class="comment">//记录前一个访问的节点</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(root!=<span class="keyword">null</span>) <span class="comment">//root表示当前节点</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		 stack.push(root);</span><br><span class="line">        		 root=root.left;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		TreeNode peeknode=stack.peek();</span><br><span class="line">        		<span class="keyword">if</span>(peeknode.right!=<span class="keyword">null</span> &amp;&amp; peeknode.right!=pre)</span><br><span class="line">        		&#123;</span><br><span class="line">        			root=peeknode.right;</span><br><span class="line">        		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        			stack.pop();</span><br><span class="line">        			res.add(peeknode.val);</span><br><span class="line">        			pre=peeknode;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Tree Preorder Traversal]]></title>
      <url>http://codeinterviews.com/Binary-Tree-Preorder-Traversal/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Tree Preorder Traversal</p>
<blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return [1,2,3].</p>
<p><strong>Note</strong>: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对二叉树进行先序遍历，如果使用递归求解非常简单，这里代码就不写了。</p>
<p>题目中要求不要使用递归写法，因此可以使用<strong>栈</strong>来将递归写法变成非递归写法。这里需要注意的是先要压入右节点，然后在压入左节点，这样首先访问的就是左节点了哈。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//定义一个栈</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeNode node=stack.pop();</span><br><span class="line">        	res.add(node.val);</span><br><span class="line">        	<span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">        		stack.push(node.right);</span><br><span class="line">        	<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">        		stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Tree Right Side View]]></title>
      <url>http://codeinterviews.com/Binary-Tree-Right-Side-View/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Tree Right Side View</p>
<blockquote>
<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br>Given the following binary tree,</p>
<pre><code>   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---
</code></pre><p>You should return [1, 3, 4].</p>
<p>####Credits:<br>Special thanks to @amrsaqr for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题我们可以发现，从右边看树，看到的其实是每一层的最后一个节点，因此我们可以采用广度优先遍历，并且记录每一个节点的层数，当该层最后一个节点出现的时候，就将其放入结果中。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> res;</span><br><span class="line">    	<span class="comment">//使用广度优先搜索</span></span><br><span class="line">    	LinkedList&lt;TreeNode&gt; queen=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    	LinkedList&lt;Integer&gt; ceng=<span class="keyword">new</span> LinkedList&lt;Integer&gt;(); <span class="comment">//记录每个节点的层数</span></span><br><span class="line">    	<span class="keyword">int</span> curceng=<span class="number">0</span>;</span><br><span class="line">    	queen.offer(root);</span><br><span class="line">    	ceng.offer(<span class="number">0</span>);</span><br><span class="line">    	TreeNode cur=root;</span><br><span class="line">    	<span class="keyword">while</span>(!queen.isEmpty())</span><br><span class="line">    	&#123;</span><br><span class="line">    		TreeNode tmp=queen.poll();</span><br><span class="line">    		<span class="keyword">int</span> tmpc=ceng.poll();</span><br><span class="line">    		<span class="keyword">if</span>(tmpc!=curceng)</span><br><span class="line">    		&#123;</span><br><span class="line">    			res.add(cur.val);</span><br><span class="line">    			curceng=tmpc;</span><br><span class="line">    		&#125;</span><br><span class="line">			<span class="keyword">if</span>(tmp.left!=<span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				queen.offer(tmp.left);</span><br><span class="line">				ceng.offer(tmpc+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(tmp.right!=<span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				queen.offer(tmp.right);</span><br><span class="line">				ceng.offer(tmpc+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    		cur=tmp;</span><br><span class="line">    	&#125;</span><br><span class="line">    	res.add(cur.val);</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Binary Tree Zigzag Level Order Traversal]]></title>
      <url>http://codeinterviews.com/Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Binary Tree Zigzag Level Order Traversal</p>
<blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its zigzag level order traversal as:</p>
<pre><code>[
  [3],
  [20,9],
  [15,7]
]
</code></pre><p>confused what <code>&quot;{1,#,2,3}&quot;</code> means? &gt; read more on how binary tree is serialized on OJ.</p>
<p>####OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example:</p>
<pre><code>  1
 / \
2   3
   /
  4
   \
    5
</code></pre><p>The above binary tree is serialized as <code>&quot;{1,2,3,#,#,4,#,#,5}&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题其实还是对树的层次遍历，只不过有一点区别：在奇数层上是从左往右遍历，而在偶数层上是从右往左遍历，因此由于顺序是相反的，我们很容易想到的是用栈来存储每一层的节点。因此这里选用两个栈，一个栈用于读取节点，一个栈用于保存每一层的节点。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">	    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">	    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">	        <span class="keyword">return</span> res;</span><br><span class="line">	    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">	    <span class="keyword">int</span> level=<span class="number">1</span>;</span><br><span class="line">	    ArrayList&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	    item.add(root.val);</span><br><span class="line">	    res.add(item);</span><br><span class="line">	    stack.push(root);</span><br><span class="line">	    <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">	    &#123;</span><br><span class="line">	        LinkedList&lt;TreeNode&gt; newStack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">	        item = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">	        &#123;</span><br><span class="line">	            TreeNode node = stack.pop();</span><br><span class="line">	            <span class="keyword">if</span>(level%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">	            &#123;</span><br><span class="line">	                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    newStack.push(node.left);</span><br><span class="line">	                    item.add(node.left.val);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    newStack.push(node.right);</span><br><span class="line">	                    item.add(node.right.val);</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">else</span></span><br><span class="line">	            &#123;</span><br><span class="line">	                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    newStack.push(node.right);</span><br><span class="line">	                    item.add(node.right.val);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    newStack.push(node.left);</span><br><span class="line">	                    item.add(node.left.val);</span><br><span class="line">	                &#125;                   </span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        level++;</span><br><span class="line">	        <span class="keyword">if</span>(item.size()&gt;<span class="number">0</span>)</span><br><span class="line">	            res.add(item);</span><br><span class="line">	        stack = newStack;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Bitwise AND of Numbers Range]]></title>
      <url>http://codeinterviews.com/Bitwise-AND-of-Numbers-Range/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Bitwise AND of Numbers Range</p>
<blockquote>
<p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>
<p>For example, given the range [5, 7], you should return 4.</p>
<p>####Credits:<br>Special thanks to @amrsaqr for adding this problem and creating all test cases.<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>这道题的意思是，计算从m到n的非负整数的按位与值。太牛逼了，我想了好久都是计算超时。结果其实就是m和n公共头部。例子中5的二进制为101,7的二进制位111，其公共头部为100。再如，若计算3到5的按位或，3的二进制位11，5的二进制位101，没有公共头部，返回0。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)</span><br><span class="line">       		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">       	<span class="comment">//通过移位寻找公共的头</span></span><br><span class="line">       	<span class="keyword">while</span>(m!=n &amp;&amp; m!=<span class="number">0</span>)</span><br><span class="line">       	&#123;</span><br><span class="line">       		m=m&gt;&gt;<span class="number">1</span>;</span><br><span class="line">       		n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">       		i++;</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">return</span> m&lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Candy]]></title>
      <url>http://codeinterviews.com/Candy/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Candy</p>
<blockquote>
<p>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.   </li>
<li>Children with a higher rating get more candies than their neighbors.   </li>
</ul>
<p>What is the minimum candies you must give?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Trapping-Rain-Water.html" target="_blank" rel="external">Trapping Rain Water</a>非常类似，都是要求的变量跟左右元素有关系的题目。因此可以分别从两边对其进行遍历。在该题中，我们首先从左边遍历得到每个孩子在左边所需要的最少糖果，然后再从右边遍历得到每个孩子在右边所需要的最少糖果，最终该孩子所需的最少糖果为左边和右边中的最大的那个才能满足要求。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于一个孩子的糖果数与左右孩子都有关系，因此需要分别从两边进行遍历</span></span><br><span class="line">        <span class="comment">//首先得到左边的最少需要糖果数，然后从右开始遍历</span></span><br><span class="line">    	<span class="keyword">if</span>(ratings==<span class="keyword">null</span> || ratings.length==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//定义左边每个孩子最少需要的糖果数</span></span><br><span class="line">    	<span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">    	left[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])</span><br><span class="line">    			left[i]=left[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    			left[i]=<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//定义右边每个孩子最少需要的糖果数</span></span><br><span class="line">    	<span class="keyword">int</span>[] right=<span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">    	right[ratings.length-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=ratings.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>])</span><br><span class="line">    			right[i]=right[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    			right[i]=<span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//定义每个孩子的最少所需糖果数</span></span><br><span class="line">    	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ratings.length;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		res=Math.max(left[i],right[i])+res;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS 常用命令及快捷键整理]]></title>
      <url>http://codeinterviews.com/CentOS-Command/</url>
      <content type="html"><![CDATA[<p>##引言<br>最近用<code>linux</code>的比较多，主要用的<code>linux distributions</code>是<code>CentOS</code>.因此这里将<code>CentOS</code>中常用的命令和快捷键进行了整理。</p>
<a id="more"></a>
<p>##文件和目录</p>
<pre><code># cd /home                        进入 &apos;/home&apos; 目录

# cd ..                           返回上一级目录

# cd ../..                        返回上两级目录 

# cd -                            返回上次所在目录

# cp file1 file2                  将file1复制为file2

# cp -a dir1 dir2                 复制一个目录

# cp -a /tmp/dir1 .               复制一个目录到当前工作目录（.代表当前目录）

# ls                              查看目录中的文件

# ls -a                           显示隐藏文件

# ls -l                           显示详细信息

# ls -lrt                         按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）

# pwd                             显示工作路径

# mkdir dir1                      创建 &apos;dir1&apos; 目录

# mkdir dir1 dir2                 同时创建两个目录

# mkdir -p /tmp/dir1/dir2         创建一个目录树

# mv dir1 dir2                    移动/重命名一个目录

# rm -f file1                     删除 &apos;file1&apos;

# rm -rf dir1                     删除 &apos;dir1&apos; 目录及其子目录内容
</code></pre><p>##查看文件内容</p>
<pre><code># cat file1                       从第一个字节开始正向查看文件的内容

# head -2 file1                   查看一个文件的前两行 

# more file1                      查看一个长文件的内容

# tac file1                       从最后一行开始反向查看一个文件的内容

# tail -3 file1                   查看一个文件的最后三行
</code></pre><p>##文本处理</p>
<pre><code># grep str /tmp/test              在文件 &apos;/tmp/test&apos; 中查找 &quot;str&quot;

# grep ^str /tmp/test             在文件 &apos;/tmp/test&apos; 中查找以 &quot;str&quot; 开始的行

# grep [0-9] /tmp/test            查找 &apos;/tmp/test&apos; 文件中所有包含数字的行

# grep str -r /tmp/*              在目录 &apos;/tmp&apos; 及其子目录中查找 &quot;str&quot;

# diff file1 file2                找出两个文件的不同处

# sdiff file1 file2               以对比的方式显示两个文件的不同
</code></pre><p>##查找</p>
<pre><code># find / -name file1              从 &apos;/&apos; 开始进入根文件系统查找文件和目录

# find / -user user1              查找属于用户 &apos;user1&apos; 的文件和目录

# find /home/user1 -name \*.bin   在目录 &apos;/ home/user1&apos; 中查找以 &apos;.bin&apos; 结尾的文件

# find /usr/bin -type f -atime +100   查找在过去100天内未被使用过的执行文件

# find /usr/bin -type f -mtime -10    查找在10天内被创建或者修改过的文件

# locate \*.ps                        寻找以 &apos;.ps&apos; 结尾的文件，先运行 &apos;updatedb&apos; 命令

# find -name &apos;*.[ch]&apos; | xargs grep -E &apos;expr&apos;    在当前目录及其子目录所有.c和.h文件中查找 &apos;expr&apos;

# find -type f -print0 | xargs -r0 grep -F &apos;expr&apos;   在当前目录及其子目录的常规文件中查找 &apos;expr&apos;

# find -maxdepth 1 -type f | xargs grep -F &apos;expr&apos;   在当前目录中查找 &apos;expr&apos;
</code></pre><p>##压缩和解压</p>
<pre><code># bzip2 file1                            压缩 file1

# bunzip2 file1.bz2                      解压 file1.bz2

# gzip file1                             压缩 file1

# gzip -9 file1                          最大程度压缩 file1

# gunzip file1.gz                        解压 file1.gz

# tar -cvf archive.tar file1             把file1打包成 archive.tar

（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）

# tar -cvf archive.tar file1 dir1        把 file1，dir1 打包成 archive.tar

# tar -tf archive.tar                    显示一个包中的内容

# tar -xvf archive.tar                   释放一个包

# tar -xvf archive.tar -C /tmp           把压缩包释放到 /tmp目录下

# zip file1.zip file1                    创建一个zip格式的压缩包

# zip -r file1.zip file1 dir1            把文件和目录压缩成一个zip格式的压缩包

# unzip file1.zip                        解压一个zip格式的压缩包到当前目录

# unzip test.zip -d /tmp/                解压一个zip格式的压缩包到 /tmp 目录
</code></pre><p>##yum工具</p>
<pre><code># yum -y install [package]               下载并安装一个rpm包

# yum localinstall [package.rpm]         安装一个rpm包，使用你自己的软件仓库解决所有依赖关系

# yum -y update                          更新当前系统中安装的所有rpm包

# yum update [package]                   更新一个rpm包

# yum remove [package]                   删除一个rpm包

# yum list                               列出当前系统中安装的所有包

# yum search [package]                   在rpm仓库中搜寻软件包

# yum clean [package]                    清除缓存目录（/var/cache/yum）下的软件包

# yum clean headers                      删除所有头文件

# yum clean all                          删除所有缓存的包和头文件
</code></pre><p>##网络</p>
<pre><code># ifconfig eth0                                                                       显示一个以太网卡的配置

# ifconfig eth0 192.168.1.1 netmask 255.255.255.0   配置网卡的IP地址

# ifdown eth0                                       禁用 &apos;eth0&apos; 网络设备

# ifup eth0                                         启用 &apos;eth0&apos; 网络设备

# iwconfig eth1                                     显示一个无线网卡的配置

# iwlist scan                                       显示无线网络

# ip addr show                                      显示网卡的IP地址
</code></pre><p>##其他</p>
<pre><code># su -                            切换到root权限（与su有区别）

# shutdown -h now                 关机

# shutdown -r now                 重启

# top                             罗列使用CPU资源最多的linux任务 （输入q退出）

# pstree                          以树状图显示程序

# man ping                        查看参考手册（例如ping 命令）

# passwd                          修改密码

# df -h                           显示磁盘的使用情况

# cal -3                          显示前一个月，当前月以及下一个月的月历

# cal 10 1988                     显示指定月，年的月历

# date --date &apos;1970-01-01 UTC 1427888888 seconds&apos;   把一相对于1970-01-01 00:00的秒数转换成时间
</code></pre><p>##常用快捷键<br>CentOS 6.4 中可以通过系统-&gt;首选项-&gt;键盘快捷键来设置快捷键，如图所示。例如可将运行终端的快捷键设为Ctrl+Alt+T。<br><img src="/img/CentOS/1.png" alt=""><img src="/img/CentOS/2.png" alt=""></p>
<pre><code>Ctrl + u            删除光标之前到行首的字符

Ctrl + k            删除光标之前到行尾的字符

Ctrl + c            取消当前行输入的命令，相当于Ctrl + Break

Ctrl + a            光标移动到行首（ahead of line），相当于通常的Home键

Ctrl + e            光标移动到行尾（end of line）

Ctrl + f            光标向前（forward）移动一个字符位置

Ctrl + b            光标往回（backward）移动一个字符位置

Ctrl + l            清屏，相当于执行clear命令

Ctrl + r            显示:号提示，根据用户输入查找相关历史命令（reverse-i-search）

Ctrl + w            删除从光标位置前到当前所处单词（word）的开头

Ctrl + t            交换光标位置前的两个字符

Ctrl + y            粘贴最后一次被删除的单词

Ctrl + Alt + d      显示桌面

Alt + b             光标往回（backward）移动到前一个单词

Alt + d             删除从光标位置到当前所处单词的末尾

Alt + F2            运行

Alt + F4            关闭当前窗口

Alt + F9            最小化当前窗口

Alt + F10           最大化当前窗口

Alt + Tab           切换窗口

Alt +按住左键        移动窗口（或在最下面的任务栏滚动鼠标滑轮）

[鼠标中间键] 粘贴突出显示的文本。使用鼠标左键来选择文本。把光标指向想粘贴文本的地方。点击鼠标中间键来粘贴。

[Tab] 命令行自动补全。使用 shell 提示时可使用这一方式。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配键入字符的所有命令。

在桌面或文件管理器中直接按 / 就可以输入位置，打开文件管理器。

快速搜索：在 vi 或 Firefox 中直接按 / 即可进入搜索状态。

网站链接和图片可直接拖放到桌面或者目录，可以马上下载。

直接将文件管理器中的文件拖到终端中就可以在终端中得到完整的路径名。

在滚动条的空白处点击鼠标中键，屏幕即滚动到那个地方。
</code></pre><p>##参考资料</p>
<ol>
<li><a href="http://blog.csdn.net/lilong_dream/article/details/17081067" target="_blank" rel="external">CentOS命令和快捷键</a></li>
<li><a href="http://www.linuxguide.it/command_line/linux_commands_cn.html" target="_blank" rel="external">linux命令行</a></li>
<li><a href="http://www.pixelbeat.org/cmdline_zh_CN.html" target="_blank" rel="external">linux常见命令列表</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS-Sublime2安装]]></title>
      <url>http://codeinterviews.com/CentOS-Sublime2/</url>
      <content type="html"><![CDATA[<p>##引言<br>Sublime编辑器据说也是一种神级编辑器，所以今天就安装试了试，果然非常不错。</p>
<a id="more"></a>
<p>##安装</p>
<p>1.从官网下载相应操作系统的下的<a href="http://www.sublimetext.com/2" target="_blank" rel="external">安装包</a>，这里下的是<code>linux</code>下的安装包<br>2.解压安装包，并将其放在<code>/opt/</code>下：    </p>
<pre><code>tar -jxvf Sublime Text 2.0.1.tar.bz2 -C /opt/
</code></pre><p>3.链接<code>sublime</code>的启动文件到<code>/usr/bin</code>，以便可以在终端使用<code>sublime</code>启动：   </p>
<pre><code>ln -s /opt/Sublime\ Text\ 2/sublime_text /usr/bin/sublime
</code></pre><p>4.建立桌面快捷方式，使用<code>sublime</code>新建<code>sublime.desktop</code>：   </p>
<pre><code>sublime /usr/share/applications/sublime.desktop
</code></pre><p>并在其中加入下面内容：      </p>
<pre><code>[Desktop Entry]
Version=1.0
  Name=Sublime Text 2
 # Only KDE 4 seems to use GenericName, so we reuse the KDE strings.
  # From Ubuntu&apos;s language-pack-kde-XX-base packages, version 9.04-20090413.
  GenericName=Text Editor

  Exec=sublime
  Terminal=false
  Icon=/opt/Sublime Text 2/Icon/48x48/sublime_text.png
  Type=Application
  Categories=TextEditor;IDE;Development
  X-Ayatana-Desktop-Shortcuts=NewWindow

  [NewWindow Shortcut Group]
  Name=New Window
  Exec=sublime -n
TargetEnvironment=Unity
</code></pre><p>##Package Control组建安装<br>1.按Ctrl+`调出console<br>2.粘贴以下代码到底部命令行并回车：         </p>
<pre><code>import urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())
</code></pre><p>3.重启<code>Sublime Text 2</code><br>4.如果在<code>Perferences-&gt;package settings</code>中看到<code>package control</code>这一项，则安装成功。   </p>
<p>##插件安装<br>1.按下<code>Ctrl+Shift+P</code>调出命令面板<br>2.输入<code>install</code>调出 <code>Install Package</code> 选项并回车，然后在列表中选中要安装的插件。     </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS下配置"Unix环境高级编程第三版"中的apue.h]]></title>
      <url>http://codeinterviews.com/CentOS-apue/</url>
      <content type="html"><![CDATA[<p>##引言<br>最近在看&lt;<unix环境高级编程第三版>&gt;，其中代码中都包含了apue.h头文件。因此如果想用这个头文件，需要自己配置。</unix环境高级编程第三版></p>
<a id="more"></a>
<p>##下载apue.3e解压<br>下载地址为：<a href="http://www.apuebook.com/" target="_blank" rel="external">Unix环境高级编程第三版</a></p>
<p>##拷贝apue.h到库目录</p>
<pre><code>cp  apue.3e/include/apue.h  /usr/include
</code></pre><p>##编程实例<br>为了方便编译自己写的代码，可以使用make工具进行简化。但是我们需要编写makefile文件。<br>其格式如下：</p>
<pre><code>//生成main的可执行文件，其中有main.o文件，并需要调用/usr/local/src/error.o库文件
LIBS = /usr/local/src/error.o
OBJS = main.o
main:${OBJS}
    gcc -o main ${OBJS} ${LIBS}
clean:
    rm -f main ${OBJS}
</code></pre><p>然后编译时，只需要执行<code>make</code>即可。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS6.5使用YUM安装Adobe Flash Player]]></title>
      <url>http://codeinterviews.com/CentOS-Flash/</url>
      <content type="html"><![CDATA[<p>##引言<br>CentOS自带的火狐浏览器没有预装Flash，因此这里需要自己安装。</p>
<a id="more"></a>
<p>##i386系统</p>
<pre><code>wget http://linuxdownload.adobe.com/adobe-release/adobe-release-i386-1.0-1.noarch.rpm
rpm -ivh adobe-release-i386-1.0-1.noarch.rpm
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-adobe-linux
yum install firefox.i386 flash-plugin
</code></pre><p>##x86_64系统</p>
<pre><code>wget http://linuxdownload.adobe.com/adobe-release/adobe-release-x86_64-1.0-1.noarch.rpm
rpm -ivh adobe-release-x86_64-1.0-1.noarch.rpm
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-adobe-linux
yum install firefox.x86_64 flash-plugin
</code></pre><p>##更新Flash player</p>
<pre><code>yum update flash-plugin
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Balanced Binary Tree]]></title>
      <url>http://codeinterviews.com/Balanced-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Balanced Binary Tree</p>
<blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判断一个二叉树是否是平衡二叉树，平衡二叉树满足对树中的每一个节点，其左右子树的高度差都不大于1。因此，这里可以使用<strong>递归</strong>的方法进行判断。</p>
<p>一个二叉树是否是一个平衡二叉树的判断条件是：</p>
<pre><code>1. 左子树为平衡二叉树
2. 右子树为平衡二叉树
3. 左右子树的高度只差不大于1
</code></pre><p>这里面需要一个子方法求取每个树的高度，然而这个方法也可以使用递归方法求解。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归判断是否为平衡二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">int</span> leftheight=getHeight(root.left);</span><br><span class="line">    	<span class="keyword">int</span> rightheight=getHeight(root.right);</span><br><span class="line">    	<span class="comment">/*平衡二叉树需要满足三个条件：</span><br><span class="line">		*1.左子树为平衡二叉树</span><br><span class="line">		*2.右子树为平衡二叉树</span><br><span class="line">		*3.左右子树的高度只差不大于1</span><br><span class="line">		*/</span></span><br><span class="line">    	<span class="keyword">return</span> helper(root.left)&amp;&amp;helper(root.right)&amp;&amp;Math.abs(leftheight-rightheight)&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取二叉树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">return</span> Math.max(getHeight(root.left),getHeight(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Best Time to Buy and Sell Stock III]]></title>
      <url>http://codeinterviews.com/Best-Time-to-Buy-and-Sell-Stock-III/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Best Time to Buy and Sell Stock III</p>
<blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>####Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是[Best Time to Buy and Sell Stock][1]的扩展，这里要求只能进行两次交易，然而这里可以扩展为K次交易，应该思路是一样的，只是<code>k=2</code>而已。这里同样采用动态规划进行求解，仍然使用<strong>局部最优和全局最优解法</strong>由于要考虑交易次数，因此维护量应该就是一个二维数组。</p>
<pre><code>定义维护量：
global[i][j]:表示从第1天到第i天，最多交易j次的最好的利润
local[i][j]:当前到达第i天，最多可进行j次交易，并且最后一次交易在当天卖出的最好的利润是多少
定义递推式：
global[i][j]=max(global[i-1][j],local[i][j]);即第i天没有交易，和第i天有交易
local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)  diff=price[i]-price[i-1];
就是看两个量，第一个是全局到i-1天进行j-1次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要j-1次交易，最后一次交易取当前天），第二个量则是取local第i-1天j次交易，然后加上今天的差值（这里因为local[i-1][j]比如包含第i-1天卖出的交易，所以现在变成第i天卖出，并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，因为否则就不满足local[i][j]必须在最后一天卖出的条件了）。
需要注意的是：第i天卖出的交易数是算在前i-1天买入的那次交易中的。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">		定义维护量：</span><br><span class="line">		global[i][j]:表示从第1天到第i天，最多交易j次的最大利润</span><br><span class="line">		local[i][j]:表示第i天交易，最多交易次数为j次的最大利润，且最后一次肯定是在第i天卖出</span><br><span class="line">		定义递推式：</span><br><span class="line">		global[i][j]=max(global[i-1][j],local[i][j]);即第i天没有交易，和第i天有交易</span><br><span class="line">		local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)  diff=price[i]-price[i-1];</span><br><span class="line">        */</span></span><br><span class="line">        <span class="keyword">int</span>[][] global=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] local=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> diff=prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				local[i+<span class="number">1</span>][j+<span class="number">1</span>]=Math.max(global[i][j]+Math.max(diff,<span class="number">0</span>),local[i][j+<span class="number">1</span>]+diff);</span><br><span class="line">				global[i+<span class="number">1</span>][j+<span class="number">1</span>]=Math.max(global[i][j+<span class="number">1</span>],local[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> global[prices.length-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Combination Sum II]]></title>
      <url>http://codeinterviews.com/Combination-Sum-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Combination Sum II</p>
<blockquote>
<p>Given a collection of candidate numbers (<strong>C</strong>) and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p>
<p>Each number in <strong>C</strong> may only be used once in the combination.</p>
<p>####Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li>The solution set must not contain duplicate combinations. </li>
</ul>
<p>For example, given candidate set <code>10,1,2,7,6,1,5</code> and target <code>8</code>,</p>
<p>A solution set is:</p>
<p><code>[1, 7]</code></p>
<p><code>[1, 2, 5]</code></p>
<p><code>[2, 6]</code></p>
<p><code>[1, 1, 6]</code> </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Combination-Sum.html" target="_blank" rel="external">Combination Sum</a>的解法相同，只是该题中每个元素只能用一次，所以对<code>i</code>元素的递归求解应该从第<code>i+1</code>个开始，为了避免最后结果中出现重复的问题，需要跳过重复的元素。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span>||num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        helper(num,<span class="number">0</span>,target,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt; cur,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;num.length;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(i!=start&amp;&amp;num[i]==num[i-<span class="number">1</span>]) <span class="comment">//去除重复的问题，跳过重复的元素</span></span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		cur.add(num[i]);</span><br><span class="line">    		helper(num,i+<span class="number">1</span>,target-num[i],cur,res);</span><br><span class="line">    		cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Clone Graph]]></title>
      <url>http://codeinterviews.com/Clone-Graph/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Clone Graph</p>
<blockquote>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>####OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p>
<p>We use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<p>First node is labeled as <code>0</code>. Connect node <code>0</code> to both nodes <code>1</code> and <code>2</code>.<br>Second node is labeled as <code>1</code>. Connect node <code>1</code> to node <code>2</code>.<br>Third node is labeled as <code>2</code>. Connect node <code>2</code> to node <code>2</code> (itself), thus forming a self-cycle.<br>Visually, the graph looks like the following:     </p>
</blockquote>
<pre><code>   1
  / \
 /   \
0 --- 2
     / \
     \_/
</code></pre><a id="more"></a>
<p>##解题思路<br>该题是对图进行复制，也就是对图进行遍历。而图的遍历方法主要分为深度和广度两种，这里两种都可以实现。在这里我们使用<code>HashMap</code>来存放旧节点和新节点的对应关系，以便能够迅速找到对应的节点。</p>
<p>##算法代码<br>代码采用JAVA实现：<br>广度优先遍历：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for undirected graph.</span><br><span class="line"> * class UndirectedGraphNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     List&lt;UndirectedGraphNode&gt; neighbors;</span><br><span class="line"> *     UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;UndirectedGraphNode&gt;();</span><br><span class="line">        HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;();</span><br><span class="line">        UndirectedGraphNode copy = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line">        map.put(node,copy);</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            UndirectedGraphNode cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur.neighbors.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(cur.neighbors.get(i)))</span><br><span class="line">                &#123;</span><br><span class="line">					<span class="comment">//创建新节点</span></span><br><span class="line">                    copy = <span class="keyword">new</span> UndirectedGraphNode(cur.neighbors.get(i).label);</span><br><span class="line">                    map.put(cur.neighbors.get(i),copy);</span><br><span class="line">                    queue.offer(cur.neighbors.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//存入邻居节点</span></span><br><span class="line">                map.get(cur).neighbors.add(map.get(cur.neighbors.get(i)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>深度优先遍历：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for undirected graph.</span><br><span class="line"> * class UndirectedGraphNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     List&lt;UndirectedGraphNode&gt; neighbors;</span><br><span class="line"> *     UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;UndirectedGraphNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;UndirectedGraphNode&gt;();</span><br><span class="line">        HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;();</span><br><span class="line">        UndirectedGraphNode copy = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line">        map.put(node,copy);</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            UndirectedGraphNode cur = stack.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur.neighbors.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(cur.neighbors.get(i)))</span><br><span class="line">                &#123;</span><br><span class="line">                    copy = <span class="keyword">new</span> UndirectedGraphNode(cur.neighbors.get(i).label);</span><br><span class="line">                    map.put(cur.neighbors.get(i),copy);</span><br><span class="line">                    stack.push(cur.neighbors.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(cur).neighbors.add(map.get(cur.neighbors.get(i)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Combination Sum III]]></title>
      <url>http://codeinterviews.com/Combination-Sum-III/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Combination Sum III</p>
<blockquote>
<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
<p>Example 1:</p>
<p>Input: k = 3, n = 7</p>
<p>Output:</p>
</blockquote>
<pre><code>[[1,2,4]]
</code></pre><blockquote>
<p>Example 2:</p>
<p>Input: k = 3, n = 9</p>
<p>Output:</p>
</blockquote>
<pre><code>[[1,2,6], [1,3,5], [2,3,4]]
</code></pre><blockquote>
<p>####Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题的思路与<a href="http://pisxw.com/algorithm/Combination-Sum.html" target="_blank" rel="external">Combination Sum</a>和<a href="http://pisxw.com/algorithm/Combination-Sum-II.html" target="_blank" rel="external">Combination Sum II</a>类似，是一个求解循环子问题，但是这里的结果集中需要元素的长度为K，只需要当和为n的时候，判断当前满足和的元素的个数是否为k即可。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] candidates=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; cur=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        helper(candidates,<span class="number">0</span>,k,n,cur,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cur保存当前已经放入的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> start,<span class="keyword">int</span> k,<span class="keyword">int</span> n,List&lt;Integer&gt; cur,List&lt;List&lt;Integer&gt;&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(cur.size()==k)</span><br><span class="line">    			res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    			<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//循环处理子问题</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">//这里不需要考虑重复元素，因为是1-9的元素，没有重复</span></span><br><span class="line">    		cur.add(candidates[i]);</span><br><span class="line">    		helper(candidates,i+<span class="number">1</span>,k,n-candidates[i],cur,res);</span><br><span class="line">    		cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Anagrams]]></title>
      <url>http://codeinterviews.com/Anagrams/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Anagrams</p>
<blockquote>
<p>Given an array of strings, return all groups of strings that are anagrams.</p>
<p>Note: All inputs will be in lower-case.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>Anagrams为易位构词，其实也很好理解，就是两个单词所包含的字符和数量都是一样的，只是顺序不同。</p>
<p>判断两个单词是不是anagram，一般来说有两种方法。<br>第一种方法是用hashmap，key是字符，value是出现的次数，如果两个单词构成的hashmap相同，那么就是anagram。实现起来就是用一个构建hashmap，然后另一个在前面的hashmap中逐个去除，最后如果hashmap为空，即返回true。这个方法时间复杂度是O(m+n)，m，n分别是两个单词的长度。而空间复杂度是O(字符集的大小)。<br>第二种方法是将两个单词排序，如果排序之后结果相同，就说明两个单词是anagram。这种方法的时间复杂度取决于排序算法，一般排序算法是O(nlogn)，如果字符集够小，也可以用线性的排序算法。不过总体来说，如果是判断两个单词的，第一种方法要直接简单一些。</p>
<p>这道题，是在很多字符串里面按照anagram分类，如果用hashmap的方法，然后两两匹配，在分组会比较麻烦。而如果用排序的方法则有一个很大的优势，就是排序后的字符串可以作为一个key，也就是某一个class的id，如此只要对每一个字符串排序，然后建立一个hashmap，key是排序后的串，而value是所有属于这个key类的字符串，这样就可以比较简单的进行分类。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">anagrams</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span> || strs.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        HashMap&lt;String,ArrayList&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;String,ArrayList&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">char</span>[] st=strs[i].toCharArray();</span><br><span class="line">        	Arrays.sort(st);</span><br><span class="line">        	String sts=<span class="keyword">new</span> String(st);</span><br><span class="line">        	<span class="keyword">if</span>(map.containsKey(sts))</span><br><span class="line">        	&#123;</span><br><span class="line">        		ArrayList&lt;String&gt; alist=map.get(sts);</span><br><span class="line">        		alist.add(strs[i]);</span><br><span class="line">        		map.put(sts,alist);</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		ArrayList&lt;String&gt; alist=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        		alist.add(strs[i]);</span><br><span class="line">        		map.put(sts,alist);</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator iter=map.values().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">        	ArrayList&lt;String&gt; item=(ArrayList&lt;String&gt;)iter.next();</span><br><span class="line">        	<span class="keyword">if</span>(item.size()&gt;<span class="number">1</span>)</span><br><span class="line">        		res.addAll(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Combination Sum]]></title>
      <url>http://codeinterviews.com/Combination-Sum/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Combination Sum</p>
<blockquote>
<p>Given a set of candidate numbers (<strong>C</strong>) and a target number (<strong>T</strong>), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The <strong>same</strong> repeated number may be chosen from C unlimited number of times.</p>
<p>####Note:</p>
<ol>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ol>
<p>For example, given candidate set <code>2,3,6,7</code> and target <code>7</code>,</p>
<p>A solution set is: </p>
<p><code>[7]</code> </p>
<p><code>[2, 2, 3]</code> </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是一个求解循环子问题的题目，采用递归进行深度优先搜索。基本思路是先排好序，然后每次递归中把剩下的元素一一加到结果集合中，并且把目标减去加入的元素，然后把剩下元素（包括当前加入的元素）放到下一层递归中解决子问题。算法复杂度因为是NP问题，所以自然是指数量级的。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        helper(candidates,<span class="number">0</span>,target,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> start,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt; cur,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="comment">//不满足条件</span></span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span>(target==<span class="number">0</span>) <span class="comment">//满足条件</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur)); <span class="comment">//这边不能写成res.add(cur)，如果写成这样就是传递的是引用，会在后面改变cur的时候改变res</span></span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="comment">//去除重复解的问题,跳过重复出现的元素。</span></span><br><span class="line">    			<span class="keyword">if</span>(i!=start&amp;&amp;candidates[i]==candidates[i-<span class="number">1</span>])</span><br><span class="line">    				<span class="keyword">continue</span>;</span><br><span class="line">    			cur.add(candidates[i]);  <span class="comment">//先加进来</span></span><br><span class="line">    			helper(candidates,i,target-candidates[i],cur,res);  <span class="comment">//返回的时候加进来求解的问题已经求完了</span></span><br><span class="line">    			cur.remove(cur.size()-<span class="number">1</span>); <span class="comment">//然后在去除掉</span></span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Combinations]]></title>
      <url>http://codeinterviews.com/Combinations/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Combinations</p>
<blockquote>
<p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>For example,<br>If n = 4 and k = 2, a solution is:</p>
<pre><code>[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]  
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题用到的还是<a href="http://pisxw.com/algorithm/N-Queens.html" target="_blank" rel="external">N-Queens</a>中的方法：用一个循环递归处理子问题。实现的代码跟<a href="http://pisxw.com/algorithm/Combination-Sum.html" target="_blank" rel="external">Combination Sum</a>非常类似而且更加简练，因为不用考虑重复元素的情况，而且元素只要到了k个就可以返回一个结果.</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;  </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();  </span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || n&lt;k)  </span><br><span class="line">            <span class="keyword">return</span> res;  </span><br><span class="line">        helper(n,k,<span class="number">1</span>,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res);  </span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; item, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span>  </span><br><span class="line">    </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(item.size()==k)  </span><br><span class="line">        &#123;  </span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(item));  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            item.add(i);  </span><br><span class="line">            helper(n,k,i+<span class="number">1</span>,item,res);  </span><br><span class="line">            item.remove(item.size()-<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Combine Two Tables]]></title>
      <url>http://codeinterviews.com/Combine%20Two%20Tables/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Combine Two Tables</p>
<blockquote>
<p>Table: <code>Person</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.
</code></pre><p>Table: <code>Address</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.
</code></pre><p>Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:</p>
<pre><code>FirstName, LastName, City, State
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是合并两个表，可以通过链接操作。</p>
<p>##SQL语句<br>代码采用mysql实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select FirstName,LastName,City,State from Person</span><br><span class="line">left join Address using(PersonId)</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Compare Version Numbers]]></title>
      <url>http://codeinterviews.com/Compare-Version-Numbers/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Compare Version Numbers</p>
<blockquote>
<p>Compare two version numbers version1 and version2.<br>If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p>
<p>Here is an example of version numbers ordering:</p>
<pre><code>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37
</code></pre><p>####Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题主要是字符串的操作，我们从主版本号到次版本号依次进行比较。但是此时需要考虑一个特殊情况，即‘1.0’和‘1’这种情况，在本题中，这种情况认为是相等。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//小数点在字符串分割中是特殊符号，需要在前面加"\\"</span></span><br><span class="line">        String[] ver1=version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] ver2=version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从主版本号到次版本号依次进行比较</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;ver1.length &amp;&amp; j&lt;ver2.length)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(Integer.parseInt(ver1[i])&lt;Integer.parseInt(ver2[j]))</span><br><span class="line">        		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">else</span> <span class="keyword">if</span>(Integer.parseInt(ver1[i])&gt;Integer.parseInt(ver2[j]))</span><br><span class="line">        		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		i++;</span><br><span class="line">        		j++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//version1比较长</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;ver1.length)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//特殊处理‘1.0’和‘1’这种情况</span></span><br><span class="line">        	<span class="keyword">if</span>(Integer.parseInt(ver1[i])==<span class="number">0</span>)</span><br><span class="line">        		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//version2比较长</span></span><br><span class="line">        <span class="keyword">if</span>(j&lt;ver2.length)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//特殊处理‘1.0’和‘1’这种情况</span></span><br><span class="line">        	<span class="keyword">if</span>(Integer.parseInt(ver2[j])==<span class="number">0</span>)</span><br><span class="line">        		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Construct Binary Tree from Inorder and Postorder Traversal]]></title>
      <url>http://codeinterviews.com/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Construct Binary Tree from Inorder and Postorder Traversal</p>
<blockquote>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>####Note:<br>You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题和<a href="http://pisxw.com/algorithm/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.html" target="_blank" rel="external">Construct Binary Tree from Preorder and Inorder Traversal</a>的解法类似，只不过后序中最后一个节点才是根结点，因此与前序的差别是需要从后往前遍历。代码与<a href="http://pisxw.com/algorithm/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.html" target="_blank" rel="external">Construct Binary Tree from Preorder and Inorder Traversal</a>非常类似。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder==<span class="keyword">null</span> || postorder==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将元素和其下标存放在map中，便于寻找</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">        	map.put(inorder[i],i);</span><br><span class="line">        <span class="keyword">return</span> helper(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> inL,<span class="keyword">int</span> inR,<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> postL,<span class="keyword">int</span> postR,HashMap&lt;Integer,Integer&gt; map)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(inL&gt;inR || postL&gt;postR)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	TreeNode root=<span class="keyword">new</span> TreeNode(postorder[postR]);</span><br><span class="line">    	<span class="keyword">int</span> val=root.val;</span><br><span class="line">    	<span class="keyword">int</span> index=map.get(val);</span><br><span class="line">    	root.left=helper(inorder,inL,index-<span class="number">1</span>,postorder,postL,postL+index-inL-<span class="number">1</span>,map);</span><br><span class="line">    	root.right=helper(inorder,index+<span class="number">1</span>,inR,postorder,postR-inR+index,postR-<span class="number">1</span>,map);</span><br><span class="line">    	<span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Construct Binary Tree from Preorder and Inorder Traversal]]></title>
      <url>http://codeinterviews.com/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Construct Binary Tree from Preorder and Inorder Traversal</p>
<blockquote>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>####Note:<br>You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是树中比较有难度的题目，需要根据先序遍历和中序遍历来构造出树来。这道题看似毫无头绪，其实梳理一下还是有章可循的。下面我们就用一个例子来解释如何构造出树。<br>假设树的先序遍历是12453687，中序遍历是42516837。这里最重要的一点就是先序遍历可以提供根的所在，而根据中序遍历的性质知道根的所在就可以将序列分为左右子树。比如上述例子，我们知道1是根，所以根据中序遍历的结果425是左子树，而6837就是右子树。接下来根据切出来的左右子树的长度又可以在先序便利中确定左右子树对应的子序列（先序遍历也是先左子树后右子树）。根据这个流程，左子树的先序遍历和中序遍历分别是245和425，右子树的先序遍历和中序遍历则是3687和6837，我们重复以上方法，可以继续找到根和左右子树，直到剩下一个元素。可以看出这是一个比较明显的<strong>递归</strong>过程，对于寻找根所对应的下标，我们可以先建立一个<strong>HashMap</strong>，以免后面需要进行线行搜索，这样每次递归中就只需要常量操作就可以完成对根的确定和左右子树的分割。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder==<span class="keyword">null</span> || inorder==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//将值和下标存放到HashMap中，以便后续可以方便得到</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR, HashMap&lt;Integer, Integer&gt; map)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL&gt;preR || inL&gt;inR)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preL]);</span><br><span class="line">        <span class="keyword">int</span> index = map.get(root.val);</span><br><span class="line">        root.left = helper(preorder, preL+<span class="number">1</span>, index-inL+preL, inorder, inL, index-<span class="number">1</span>, map);</span><br><span class="line">        root.right = helper(preorder, preL+index-inL+<span class="number">1</span>, preR, inorder, index+<span class="number">1</span>, inR,map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Contains Duplicate II]]></title>
      <url>http://codeinterviews.com/Contains-Duplicate-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Contains Duplicate II</p>
<blockquote>
<p>Given an array of integers and an integer k, find out whether there there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是<a href="http://pisxw.com/algorithm/Contains-Duplicate.html" target="_blank" rel="external">Contains Duplicate</a>的扩展，但是思路依然很简单，只是判断是否存在两个重复的数字之间的索引间隔是否不大于K。对于HashMap而言，其中key为数字，value为该数组所有的数组中的索引。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="comment">//其中key为数值，value为其索引位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">int</span> j=map.get(nums[i]);</span><br><span class="line">        		<span class="comment">//只需要判断间隔是否不大于K</span></span><br><span class="line">        		<span class="keyword">if</span>(i-j&lt;=k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        		</span><br><span class="line">        	&#125;</span><br><span class="line">        	map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Contains Duplicate]]></title>
      <url>http://codeinterviews.com/Contains-Duplicate/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Contains Duplicate</p>
<blockquote>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判断一个数组中是否存在重复的元素，这个思路非常简单，就是利用hash，将数组中的元素存入一个HashMap中，如果存在相同的元素，则会造成冲突。因此可以很容易的判断是否存在重复的元素。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(map.containsKey(nums[i]))</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        	map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Contains Duplicate III]]></title>
      <url>http://codeinterviews.com/Contains-Duplicate-III/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Contains Duplicate III</p>
<blockquote>
<p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k. </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Contains-Duplicate.html" target="_blank" rel="external">Contains Duplicate</a>和<a href="http://pisxw.com/algorithm/Contains-Duplicate-II.html" target="_blank" rel="external">Contains Duplicate II</a>都不相同，这题主要考察的是两个元素之间的关系。最先想到的思路就是，维持一个长度为k的window, 每次检查新的值是否与原来窗口中的所有值的差值有小于等于t.但是这种方法的时间复杂度为O(nk)，会造成超时。因此需要进行优化。<br>参考<a href="http://blog.csdn.net/xudli/article/details/46323247" target="_blank" rel="external">这篇文章解法</a>,发现其使用treeset来存储元素，以达到快速查找元素只差是否小于t的情况，这样时间复杂度为O(nlogk). </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.SortedSet;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">1</span> || t&lt;<span class="number">0</span> || nums==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">          </span><br><span class="line">        SortedSet&lt;Long&gt; set = <span class="keyword">new</span> TreeSet&lt;Long&gt;();  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nums.length; j++) &#123;  </span><br><span class="line">            SortedSet&lt;Long&gt; subSet =  set.subSet((<span class="keyword">long</span>)nums[j]-t, (<span class="keyword">long</span>)nums[j]+t+<span class="number">1</span>);  </span><br><span class="line">            <span class="keyword">if</span>(!subSet.isEmpty()) <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">if</span>(j&gt;=k) &#123;  </span><br><span class="line">                set.remove((<span class="keyword">long</span>)nums[j-k]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            set.add((<span class="keyword">long</span>)nums[j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Convert Sorted Array to Binary Search Tree]]></title>
      <url>http://codeinterviews.com/Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Convert Sorted Array to Binary Search Tree</p>
<blockquote>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是根据已排好序的数组得到一个高度平衡的二叉查找树，高度平衡指的是左右子树的高度只差不大于1。因此这里可以采用<strong>递归</strong>的方式进行求解。<br>每次选取待求解数组中的中间元素作为根，然后左边递归得到左子树，右边递归得到右子树即可。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(num,<span class="number">0</span>,num.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用递归的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(left&gt;right)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">//为了确保得到的二叉查找树是高度平衡的，此时选取中点作为根</span></span><br><span class="line">    	<span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">    	TreeNode root=<span class="keyword">new</span> TreeNode(num[mid]);</span><br><span class="line">    	root.left=helper(num,left,mid-<span class="number">1</span>); <span class="comment">//递归求解左子树</span></span><br><span class="line">    	root.right=helper(num,mid+<span class="number">1</span>,right);<span class="comment">//递归求解右子树</span></span><br><span class="line">    	<span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Copy List with Random Pointer]]></title>
      <url>http://codeinterviews.com/Copy-List-with-Random-Pointer/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Copy List with Random Pointer</p>
<blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题首先想到的是可以通过两次遍历得到结果，第一次是复制<code>next</code>节点，第二次是链接<code>random</code>节点,为了通过旧节点能过迅速的找到对应的新节点，我们这里采用<code>hashmap</code>进行存储，其中键为旧节点，值为新节点，但是这里需要额外的存储空间。</p>
<p>这里可以不是用额外空间进行求解，但是这里需要三次扫描链表。第一次遍历链表，得到新节点，并将新节点插入到旧节点之后，即原来的链表变成新旧节点交替出现的情况。第二次是链接新节点的random,即old.next.random=old.random.next.第三次是将该链表进行分割，分别得到两个链表，就是对相互间隔的节点进行切割。</p>
<p>##算法代码<br>代码采用JAVA实现：<br>一般方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list with a random pointer.</span><br><span class="line"> * class RandomListNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     RandomListNode next, random;</span><br><span class="line"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode headbefore=<span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">        headbefore.next=head;</span><br><span class="line">        RandomListNode newheadbefore=<span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">        HashMap&lt;RandomListNode,RandomListNode&gt; map=<span class="keyword">new</span> HashMap&lt;RandomListNode,RandomListNode&gt;();</span><br><span class="line">        RandomListNode cur=head;</span><br><span class="line">        RandomListNode last=newheadbefore;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	RandomListNode newnode=<span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">        	map.put(cur,newnode);</span><br><span class="line">        	last.next=newnode;</span><br><span class="line">        	last=last.next;</span><br><span class="line">        	cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	RandomListNode newnode=map.get(cur);</span><br><span class="line">        	newnode.random=map.get(cur.random);</span><br><span class="line">        	cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newheadbefore.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不适用额外空间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list with a random pointer.</span><br><span class="line"> * class RandomListNode &#123;</span><br><span class="line"> *     int label;</span><br><span class="line"> *     RandomListNode next, random;</span><br><span class="line"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       	RandomListNode p=head;</span><br><span class="line">       	<span class="comment">//第一次遍历</span></span><br><span class="line">       	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">       	&#123;</span><br><span class="line">       		RandomListNode newnode=<span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">       		RandomListNode temp=p.next;</span><br><span class="line">       		newnode.next=p.next;</span><br><span class="line">       		p.next=newnode;</span><br><span class="line">       		p=temp;</span><br><span class="line">       	&#125;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">//第二次遍历</span></span><br><span class="line">       	p=head;</span><br><span class="line">       	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">       	&#123;</span><br><span class="line">       		<span class="keyword">if</span>(p.random!=<span class="keyword">null</span>)</span><br><span class="line">       			p.next.random=p.random.next;</span><br><span class="line">       		p=p.next.next;</span><br><span class="line"></span><br><span class="line">       	&#125;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">//第三次遍历</span></span><br><span class="line">       	p=head;</span><br><span class="line">       	RandomListNode newhead=p.next;</span><br><span class="line">       	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">       	&#123;</span><br><span class="line">       		RandomListNode temp=p.next;</span><br><span class="line">       		<span class="keyword">if</span>(p.next!=<span class="keyword">null</span>)</span><br><span class="line">       		&#123;</span><br><span class="line">       			p.next=p.next.next;</span><br><span class="line">       		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       			p.next=<span class="keyword">null</span>;</span><br><span class="line">       		&#125;</span><br><span class="line">       		p=temp;</span><br><span class="line">       	&#125;</span><br><span class="line"></span><br><span class="line">       	<span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Count Primes]]></title>
      <url>http://codeinterviews.com/Count-Primes/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Count Primes</p>
<blockquote>
<p><strong>Description</strong>:</p>
<p>Count the number of prime numbers less than a non-negative number, n</p>
<p>click to show more hints.</p>
<p><strong>References</strong>:<br>How Many Primes Are There?</p>
<p>Sieve of Eratosthenes</p>
<p><strong>Credits</strong>:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该方法如果对小于n的每一个数都进行判断的话，会造成超时。因此我们找到更加好的方法进行处理，在这里，我们选择厄拉多塞筛法(Sieve of Eeatosthese)。</p>
<p>该算法的具体操作：先将 2~n 的各个数放入表中，然后在2的上面画一个圆圈，然后划去2的其他倍数；第一个既未画圈又没有被划去的数是3，将它画圈，再划去3的其他倍数；现在既未画圈又没有被划去的第一个数 是5，将它画圈，并划去5的其他倍数……依次类推，一直到所有小于或等于 n 的各数都画了圈或划去为止。这时，表中画了圈的以及未划去的那些数正好就是小于 n 的素数。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="comment">//首先对2进行画圈，然后去除到所有2的倍数</span></span><br><span class="line">        flag[<span class="number">2</span>]=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        		flag[i]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对后面第一个没有被去除的数进行画圈，且去除其倍数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(flag[i]==<span class="keyword">false</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(i*i&gt;n)</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        		&#123;</span><br><span class="line">        			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*i&lt;n;j++)</span><br><span class="line">        			&#123;</span><br><span class="line">        				flag[j*i]=<span class="keyword">true</span>;</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计素数的个数</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(flag[i]==<span class="keyword">false</span>)</span><br><span class="line">        		res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Convert Sorted List to Binary Search Tree]]></title>
      <url>http://codeinterviews.com/Convert-Sorted-List-to-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Convert Sorted List to Binary Search Tree</p>
<blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是根据已排好序的链表得到一个高度平衡的二叉查找树，高度平衡指的是左右子树的高度只差不大于1。当然，这道题与<a href="http://pisxw.com/algorithm/Convert-Sorted-Array-to-Binary-Search-Tree.html" target="_blank" rel="external">Convert Sorted Array to Binary Search Tree</a>很类似，但是在链表中不能用常量的时间获取中间节点，但是我们可以遍历得到中间节点，这样就得到自顶向下的解法1.</p>
<p>当然利用到树的中序遍历了，按照递归中序遍历的顺序对链表结点一个个进行访问，就能得到自底向上的解法2，而我们要构造的二分查找树正是按照链表的顺序来的。思路就是先对左子树进行递归，然后将当前结点作为根，迭代到下一个链表结点，最后在递归求出右子树即可。这种方法比较不容易想到，而且递归过程有点复杂。这种构造的方式比较绕，因为一般来说我们都是对于存在的树进行遍历，这里是模拟一个中序遍历的过程把树从无到有地构造出来。过程比较不常规。</p>
<p>##算法代码<br>代码采用JAVA实现：<br>自顶向下的方法，但是需要获取链表中的中间节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; next = null; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	 	<span class="comment">//自顶向下的方法</span></span><br><span class="line">	 	<span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">	 		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	 	ListNode cur=head;</span><br><span class="line">	 	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	 	<span class="keyword">while</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		cur=cur.next;</span><br><span class="line">	 		len++;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="keyword">return</span> helper(head,<span class="number">0</span>,len-<span class="number">1</span>);	        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归求解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(ListNode head,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(left&gt;right)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    	<span class="comment">//找到中间节点</span></span><br><span class="line">    	<span class="keyword">int</span> count=mid;</span><br><span class="line">    	ListNode midnode=head;</span><br><span class="line">    	<span class="keyword">while</span>(count&gt;left)</span><br><span class="line">    	&#123;</span><br><span class="line">    		midnode=midnode.next;</span><br><span class="line">    		count--;</span><br><span class="line">    	&#125;</span><br><span class="line">    	TreeNode root=<span class="keyword">new</span> TreeNode(midnode.val);</span><br><span class="line">    	root.left=helper(head,left,mid-<span class="number">1</span>);</span><br><span class="line">    	root.right=helper(midnode.next,mid+<span class="number">1</span>,right);</span><br><span class="line">    	<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自底向上的方法，递归比较复杂，需要好好思考<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; next = null; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	 	<span class="comment">//自底向上的方法</span></span><br><span class="line">	 	<span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">	 		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	 	ListNode cur=head;</span><br><span class="line">	 	<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">	 	<span class="keyword">while</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		cur=cur.next;</span><br><span class="line">	 		len++;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="keyword">return</span> helper(head,<span class="number">0</span>,len-<span class="number">1</span>);	        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归求解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(ListNode head,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(left&gt;right)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    	<span class="comment">//中序遍历的方法</span></span><br><span class="line">    	<span class="comment">//递归获取左子树</span></span><br><span class="line">    	TreeNode rootleft=helper(head,left,mid-<span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//定义根结点</span></span><br><span class="line">    	TreeNode root=<span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">    	root.left=rootleft;</span><br><span class="line">    	<span class="comment">//每次递归后，head都要向后移动</span></span><br><span class="line">    	<span class="keyword">if</span>(head.next!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		head.val=head.next.val;</span><br><span class="line">    		head.next=head.next.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//这样当递归右子树的时候，head正好指向midnode.next，正好是右子树开始的位置</span></span><br><span class="line">    	TreeNode rootright=helper(head,mid+<span class="number">1</span>,right);</span><br><span class="line">    	root.right=rootright;</span><br><span class="line">    	<span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Count and Say]]></title>
      <url>http://codeinterviews.com/Count-and-Say/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Count and Say</p>
<blockquote>
<p>The count-and-say sequence is the sequence of integers beginning as follows:<br><code>1, 11, 21, 1211, 111221, ...</code></p>
<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2, then one 1&quot;</code> or <code>1211</code>.<br>Given an integer <code>n</code>, generate the <code>nth</code> sequence.</p>
<p>Note: The sequence of integers will be represented as a string.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是输出上述字符串序列中第<code>n</code>个字符串的问题。该题在生成字符串的过程中，需要首先放入元素的出现次数，然后在放入该元素。因此后一个字符串的生成，需要对前一个字符串统计元素的出现次数问题。</p>
<p>在实现的过程中，需要小心最后一个元素有没有放入的问题。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        String cur=<span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	StringBuilder result=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">	        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;cur.length();j++)</span><br><span class="line">	        &#123;</span><br><span class="line">	    	 	<span class="keyword">if</span>(cur.charAt(j)==cur.charAt(j-<span class="number">1</span>))  <span class="comment">//统计出现次数</span></span><br><span class="line">	    	 		count++;</span><br><span class="line">	    	 	<span class="keyword">else</span>&#123;                                <span class="comment">//放入结果字符串中</span></span><br><span class="line">	    	 		result.append(count);</span><br><span class="line">	    	 		result.append(cur.charAt(j-<span class="number">1</span>));</span><br><span class="line">	    	 		count=<span class="number">1</span>;</span><br><span class="line">	    	 	&#125;</span><br><span class="line">	        &#125;</span><br><span class="line">			<span class="comment">//最后一个字符没有放入结果字符串中</span></span><br><span class="line">	        result.append(count);</span><br><span class="line">	        result.append(cur.charAt(cur.length()-<span class="number">1</span>));</span><br><span class="line">	        cur=result.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Course Schedule II]]></title>
      <url>http://codeinterviews.com/Course-Schedule-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Course Schedule II</p>
<blockquote>
<p>There are a total of n courses you have to take, labeled from 0 to n - 1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:</p>
<pre><code>2, [[1,0]]
</code></pre><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]</p>
<pre><code>4, [[1,0],[2,0],[3,1],[3,2]]
</code></pre><p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p>
<p>######Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</p>
<p>click to show more hints.</p>
<p>#######Hints:</p>
<ul>
<li>This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>
<li>Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>
<li>Topological sort could also be done via BFS.</li>
</ul>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题的思路与<a href="http://pisxw.com/algorithm/Course-Schedule.html" target="_blank" rel="external">Course Schedule</a>类似，只不过在这题中需要保存最后拓扑结构的序列，因此在返回结果的时候稍微有所变动。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        Graph graph=<span class="keyword">new</span> Graph(numCourses,prerequisites);</span><br><span class="line">        <span class="keyword">return</span> graph.topoGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">// 图中节点数量</span></span><br><span class="line">    	<span class="keyword">private</span> HashMap&lt;Integer,ArrayList&lt;Integer&gt;&gt; alledges; <span class="comment">//所有的边</span></span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">int</span>[] indegree; <span class="comment">//每个节点的入度</span></span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">int</span>[] outdegree; <span class="comment">//每个节点的出度</span></span><br><span class="line"></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span>[][] edges)</span></span><br><span class="line">    	</span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.n=num;</span><br><span class="line">    		alledges=<span class="keyword">new</span> HashMap&lt;Integer,ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    		indegree=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    		outdegree=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.length;i++)&#123;</span><br><span class="line">    			<span class="keyword">if</span>(alledges.containsKey(edges[i][<span class="number">1</span>]))&#123;</span><br><span class="line">    				ArrayList&lt;Integer&gt; tmp=alledges.get(edges[i][<span class="number">1</span>]);</span><br><span class="line">    				tmp.add(edges[i][<span class="number">0</span>]);</span><br><span class="line">    				alledges.put(edges[i][<span class="number">1</span>],tmp);</span><br><span class="line">    			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    				ArrayList&lt;Integer&gt; tmp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    				tmp.add(edges[i][<span class="number">0</span>]);</span><br><span class="line">    				alledges.put(edges[i][<span class="number">1</span>],tmp);</span><br><span class="line">    			&#125;</span><br><span class="line">    			indegree[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">    			outdegree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">    		&#125;</span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">public</span> <span class="keyword">int</span>[] topoGraph()</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    		<span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    		<span class="comment">//对其进行拓扑结构求解</span></span><br><span class="line">    		<span class="comment">//定义个队列其中存放入度为0的节点</span></span><br><span class="line">    		LinkedList&lt;Integer&gt; queen=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indegree.length;i++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">    				queen.offer(i);</span><br><span class="line">    		&#125;</span><br><span class="line"></span><br><span class="line">    		<span class="keyword">while</span>(!queen.isEmpty())&#123;</span><br><span class="line">    			<span class="keyword">int</span> tmp=queen.poll();</span><br><span class="line">    			result[count]=tmp;</span><br><span class="line">    			count++;</span><br><span class="line">    			<span class="comment">//对该节点其所有孩子节点的入度进行-1操作，并判断是否为0</span></span><br><span class="line">    			ArrayList&lt;Integer&gt; childs=alledges.get(tmp);</span><br><span class="line">    			<span class="keyword">if</span>(childs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    				<span class="keyword">for</span>(<span class="keyword">int</span> child:childs)&#123;</span><br><span class="line">    					indegree[child]--;</span><br><span class="line">    					<span class="keyword">if</span>(indegree[child]==<span class="number">0</span>)</span><br><span class="line">    						queen.offer(child);</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line"></span><br><span class="line">    		<span class="keyword">if</span>(count==n) <span class="comment">//表示完美生成拓扑结构，即可以完成所有课程</span></span><br><span class="line">    			<span class="keyword">return</span> result;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;; <span class="comment">//返回一个空的数组</span></span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Course Schedule]]></title>
      <url>http://codeinterviews.com/Course-Schedule/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Course Schedule</p>
<blockquote>
<p>There are a total of n courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:</p>
<pre><code>2, [[1,0]]
</code></pre><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<pre><code>2, [[1,0],[0,1]]
</code></pre><p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<p>click to show more hints.</p>
<p>####Hints:</p>
<ul>
<li>This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>
<li>There are several ways to represent a graph. For example, the input prerequisites is a graph represented by a list of edges. Is this graph representation appropriate?</li>
<li>Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>
<li>Topological sort could also be done via BFS.</li>
</ul>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题如果想清楚，会发现其实是找出一个有向图中是否存在环的问题，而有向图中环的问题可以转换为求其拓扑结构，如果能够完美的构成拓扑结构，则说明不存在环，否则说明其中存在环。</p>
<p>求解拓扑结构的算法思路是这样的：对每个节点的入度出度进行计算，然后选取其中入度为0的节点，放入拓扑序中，然后对每一个和该节点关联的节点的出度进行-1操作，然后重复上述的过程直到没有找到入度为0的节点，然后判断拓扑序中元素的个数，如果等于图中节点的个数则说明完美生成拓扑结构，不存在环路，否则存在环路。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        Graph g=<span class="keyword">new</span> Graph(numCourses,prerequisites);</span><br><span class="line">        <span class="keyword">return</span> g.topoGraph();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    	<span class="keyword">private</span> HashMap&lt;Integer,ArrayList&lt;Integer&gt;&gt; alledges=<span class="keyword">new</span> HashMap&lt;Integer,ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">int</span>[] indegree;</span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">int</span>[] outdegree; </span><br><span class="line"></span><br><span class="line">    	<span class="comment">//构造图结构，由于只需要构建拓扑结构，因此只需要保存入度及出度，这里需要注意一点的是</span></span><br><span class="line">    	<span class="comment">//哪一个节点是源节点，哪一个节点是目标节点</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> nvatex,<span class="keyword">int</span>[][] edges)</span></span>&#123;</span><br><span class="line">    		<span class="keyword">this</span>.n=nvatex;</span><br><span class="line">    		<span class="keyword">this</span>.indegree=<span class="keyword">new</span> <span class="keyword">int</span>[nvatex];</span><br><span class="line">    		<span class="keyword">this</span>.outdegree=<span class="keyword">new</span> <span class="keyword">int</span>[nvatex];</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges.length;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(alledges.containsKey(edges[i][<span class="number">1</span>]))</span><br><span class="line">				&#123;</span><br><span class="line">					ArrayList&lt;Integer&gt; tmp=alledges.get(edges[i][<span class="number">1</span>]);</span><br><span class="line">					tmp.add(edges[i][<span class="number">0</span>]);</span><br><span class="line">					alledges.put(edges[i][<span class="number">1</span>],tmp);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					ArrayList&lt;Integer&gt; tmp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">					tmp.add(edges[i][<span class="number">0</span>]);</span><br><span class="line">					alledges.put(edges[i][<span class="number">1</span>],tmp);</span><br><span class="line">				&#125;    					</span><br><span class="line">				indegree[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">				outdegree[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">topoGraph</span><span class="params">()</span></span><br><span class="line">    	</span>&#123;</span><br><span class="line">    		<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    		LinkedList&lt;Integer&gt; queen=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    		<span class="comment">//将所有入度为0的点入队</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">					queen.offer(i);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//构建拓扑结构图</span></span><br><span class="line">			<span class="keyword">while</span>(!queen.isEmpty())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> ver=queen.poll();</span><br><span class="line">				count++;</span><br><span class="line">				ArrayList&lt;Integer&gt; tmp=alledges.get(ver);</span><br><span class="line">				<span class="keyword">if</span>(tmp!=<span class="keyword">null</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//对该节点所有邻居节点的入度进行-1，然后判断是否为0,</span></span><br><span class="line">					<span class="comment">//如果为0,则应该入队列</span></span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> num:tmp)</span><br><span class="line">					&#123;</span><br><span class="line">						indegree[num]--;</span><br><span class="line">						<span class="keyword">if</span>(indegree[num]==<span class="number">0</span>)</span><br><span class="line">							queen.offer(num);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果最后拓扑结构中的节点数等于图中的节点数，则不存在环路</span></span><br><span class="line">			<span class="comment">//否则则存在环路</span></span><br><span class="line">			<span class="keyword">if</span>(n==count)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Decode Ways]]></title>
      <url>http://codeinterviews.com/Decode-Ways/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Decode Ways</p>
<blockquote>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<pre><code>&apos;A&apos; -&gt; 1
&apos;B&apos; -&gt; 2
...
&apos;Z&apos; -&gt; 26
</code></pre><p>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>Given encoded message <code>&quot;12&quot;</code>, it could be decoded as <code>&quot;AB&quot;</code> (1 2) or <code>&quot;L&quot;</code> (12).</p>
<p>The number of ways decoding <code>&quot;12&quot;</code> is 2.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是一个动态规划问题，可以定义如下</p>
<pre><code>定义：dp[i]表示从第0个元素到第i个元素的解码数
通过加入第i+1个元素可以看出，i+1个元素只会产生两个结果：
    1. 他自己可以解码，则dp[i+1]=dp[i];
    2. 他与前面一个元素组合起来可以解码，则dp[i+1]=dp[i-1];
所以dp[i+1]的求解有三种情况：
    1. 他自己可以解码，也可以与前一个元素组合解码
        dp[i+1]=dp[i]+dp[i-1]
    2. 他自己可以解码，不能与前一个元素组合解码
        dp[i+1]=dp[i];
    3. 他自己不能解码，但是能与前一个元素组合解码
        dp[i+1]=dp[i-1]
自己能够解码：即自己不为字符0
与前一个元素能够组合解码：即前一个元素不为0且其组合之后不超过26
</code></pre><p>在代码实现时，需要注意一个小细节，由于需要跨越两个元素，所以当<code>i=1</code>时需要特殊处理。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>)&gt;=<span class="string">'1'</span> &amp;&amp; s.charAt(<span class="number">0</span>)&lt;=<span class="string">'9'</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(s.length()==<span class="number">1</span> &amp;&amp; (s.charAt(<span class="number">0</span>)&lt;<span class="string">'1'</span> || s.charAt(<span class="number">0</span>)&gt;<span class="string">'9'</span>))</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];<span class="comment">//dp[i]表示从第0个字符到第i个字符可以编码的次数</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">'0'</span>)</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">boolean</span> one=<span class="keyword">true</span>;</span><br><span class="line">        	<span class="keyword">boolean</span> two=<span class="keyword">true</span>;</span><br><span class="line">        	<span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==<span class="string">'0'</span> || s.charAt(i-<span class="number">1</span>)&gt;<span class="string">'2'</span> || (s.charAt(i-<span class="number">1</span>)==<span class="string">'2'</span> &amp;&amp; s.charAt(i)&gt;<span class="string">'6'</span>)) </span><br><span class="line">        	&#123;</span><br><span class="line">        		two=<span class="keyword">false</span>;  <span class="comment">//两位不能解码</span></span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(s.charAt(i)==<span class="string">'0'</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		one=<span class="keyword">false</span>;  <span class="comment">//一位不能解码</span></span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(two==<span class="keyword">true</span> &amp;&amp; one==<span class="keyword">true</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		dp[i]=(i==<span class="number">1</span>?dp[i-<span class="number">1</span>]+<span class="number">1</span>:dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]);</span><br><span class="line">        	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(two==<span class="keyword">true</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		dp[i]=(i==<span class="number">1</span>?<span class="number">1</span>:dp[i-<span class="number">2</span>]);</span><br><span class="line">        	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(one==<span class="keyword">true</span>)&#123;</span><br><span class="line">        		dp[i]=dp[i-<span class="number">1</span>];</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		dp[i]=<span class="number">0</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Distinct Subsequences]]></title>
      <url>http://codeinterviews.com/Distinct-Subsequences/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Distinct Subsequences</p>
<blockquote>
<p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).   </p>
<p>Here is an example:<br>S = <code>&quot;rabbbit&quot;</code>, T = <code>&quot;rabbit&quot;</code></p>
<p>Return <code>3</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求<code>T</code>的字串在<code>S</code>中出现的次数,可以采用动态规划的思想。首先定义维护量res[i][j]:表示S的前i个字符和T的前j个字符有多少个可行的序列。递推式可以定义如下：</p>
<pre><code>如果S的第i个字符与T的第j个字符不同，则res[i][j]的序列个数应该与res[i-1][j]的个数相同；
如果S的第i个字符与T的第j个字符相同，那么除了要考虑res[i-1][j-1]的个数情况，还要考虑res[i-1][j]的个数；
因此，递推式定义如下：
if(S.charAt(i)==T.charAt(j))
    res[i][j]=res[i-1][j-1]+res[i-1][j];
else
    res[i][j]=res[i-1][j];
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//采用动态规划的思想，定义维护量res[i][j]:表示S的前i个元素和T的前j个元素能够匹配的转化方式</span></span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[S.length()+<span class="number">1</span>][T.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(T.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(S.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//进行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length()+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	res[i][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//表示当T为空时，不管S长度为多少，只有删除所有元素这一种转化方式</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;S.length()+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;T.length()+<span class="number">1</span>;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(S.charAt(i-<span class="number">1</span>)==T.charAt(j-<span class="number">1</span>))</span><br><span class="line">        		&#123;</span><br><span class="line">        			res[i][j]=res[i-<span class="number">1</span>][j-<span class="number">1</span>]+res[i-<span class="number">1</span>][j];</span><br><span class="line">        		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        			res[i][j]=res[i-<span class="number">1</span>][j];</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[S.length()][T.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Divide Two Integers]]></title>
      <url>http://codeinterviews.com/Divide-Two-Integers/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Divide Two Integers</p>
<blockquote>
<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>对于这道题目，因为不能用乘除法和取余运算，我们只能使用位运算和加减法。比较直接的方法是用被除数一直减去除数，直到为0。这种方法的迭代次数是结果的大小，即比如结果为n，算法复杂度是O(n)。 </p>
<p>但是这种方法会超时，因此我们不应该每次减去除数，而是尽可能多的减去除数的倍数。而且在做减法的时候，只需考虑两个正数，而结果的正负只需通过看被除数和除数是正是负而得到。</p>
<p>但是这里有溢出的问题需要考虑。如果被除数为<code>Integer.MIN_VALUE</code>,则只能加上一个整数才不会发现溢出的问题，因此可以加上<code>|除数|</code>，但是结果需要考虑<code>+1</code>和<code>-1</code>的问题，具体在代码中有所体现。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//只能采用加减，移位来求解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dividend==Integer.MIN_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(divisor&lt;<span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="number">1</span>+divide(dividend-divisor,divisor);<span class="comment">//相当于原来的结果-1，所以需要+1</span></span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		<span class="keyword">return</span> divide(dividend+divisor,divisor)-<span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(divisor==Integer.MIN_VALUE)</span><br><span class="line">        	<span class="keyword">return</span> dividend==divisor ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">if</span>(dividend&gt;<span class="number">0</span>&amp;&amp;divisor&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>-divide(dividend,<span class="number">0</span>-divisor); <span class="comment">//总是计算两个整数相除</span></span><br><span class="line">       	<span class="keyword">if</span>(dividend&lt;<span class="number">0</span>&amp;&amp;divisor&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>-divide(<span class="number">0</span>-dividend,divisor);</span><br><span class="line">       	<span class="keyword">if</span>(dividend&lt;<span class="number">0</span>&amp;&amp;divisor&lt;<span class="number">0</span>) <span class="keyword">return</span> divide(<span class="number">0</span>-dividend,<span class="number">0</span>-divisor);</span><br><span class="line">       	<span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">int</span> a=<span class="number">1</span>; <span class="comment">//a表示r中divisor的个数</span></span><br><span class="line">       	<span class="keyword">int</span> r=divisor;</span><br><span class="line">        <span class="keyword">while</span>(dividend&gt;=divisor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r&gt;dividend)</span><br><span class="line">            &#123;</span><br><span class="line">                r-=divisor;</span><br><span class="line">                a--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dividend-=r;</span><br><span class="line">            	q+=a;</span><br><span class="line">            	r+=divisor;</span><br><span class="line">            	a++;</span><br><span class="line">            &#125;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker的自我认识（1）]]></title>
      <url>http://codeinterviews.com/Docker%E7%9A%84%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86(0)/</url>
      <content type="html"><![CDATA[<p>这篇主要介绍<strong>docker的自我认识</strong>，我将其画成了思维导图的形式，以便后面更好的分析。</p>
<p>自己对docker的认识还只是初步阶段，并且在以后会不断加入新的内容，希望大家多多包涵！😁</p>
<a id="more"></a>
<h2 id="docker的思维导图"><a href="#docker的思维导图" class="headerlink" title="docker的思维导图"></a>docker的思维导图</h2><p>整体架构：<br><img src="/img/%E8%AE%A4%E8%AF%86docker/4.png" alt="1"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker的自我认识（4）]]></title>
      <url>http://codeinterviews.com/Docker%E7%9A%84%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86(3)/</url>
      <content type="html"><![CDATA[<p>本篇主要是自己对<strong>docker容器</strong>的大体了解以及一些认识。</p>
<p>自己对docker的认识还只是初步阶段，并且在以后会不断加入新的内容，希望大家多多包涵！😁</p>
<a id="more"></a>
<p>##一. Docker容器<br>容器是一个镜像的运行状态，是一个运行时环境。容器就像是一个集装箱，它并不关心你到底运行的是什么程序，所有应用的运行方式都一样，而且他也不在乎你在什么样的环境中运行它。</p>
<p>镜像自身是只读的。容器从镜像启动的时候,Docker 会在镜像的最上层创建一个可写层,镜像本身将保持不变。</p>
<p>Docker采用libcontainer作为默认容器，取代了之前的LXC，这样也是为了进行容器标准化的统一。</p>
<p>##二. Docker容器的隔离性<br>docker中的libcontainer主要通过以下两个功能进行隔离：</p>
<ol>
<li>采用namespace进行进程间的隔离。</li>
<li>采用cgroups来控制资源的度量和分配，从而达到资源的隔离（cpu, 内存，网络和IO）</li>
</ol>
<p>通过上面两个隔离机制，是的docker在资源隔离方面做的很不错，因此有些公司将docker应用到yarn中以解决yarn资源隔离的弱势。</p>
<p>Docker利用AUFS来实现对容器的快速更新。AUFS是一种支持将不同目录挂载到同一个虚拟文件系统下的文件系统。AUFS具有层的概念，每一次修改都是在已有的只写层上进行<strong>增量修改</strong>，修改内容将形成新的文件层，而不影响原有的层。</p>
<p>##三. 常用命令</p>
<p>####容器相关操作</p>
<ul>
<li>docker create # 创建一个容器但是不启动它            </li>
<li>docker run # 创建并启动一个容器            </li>
<li>docker stop # 停止容器运行，发送信号SIGTERM    </li>
<li>docker start # 启动一个停止状态的容器        </li>
<li>docker restart # 重启一个容器            </li>
<li>docker rm # 删除一个容器        </li>
<li>docker kill # 发送信号给容器，默认SIGKILL        </li>
<li>docker attach # 连接(进入)到一个正在运行的容器        </li>
<li>docker wait # 阻塞到一个容器，直到容器停止运行        </li>
</ul>
<p>####获取容器相关信息</p>
<ul>
<li>docker ps # 显示状态为运行（Up）的容器        </li>
<li>docker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited)            </li>
<li>docker inspect # 深入容器内部获取容器所有信息        </li>
<li>docker logs # 查看容器的日志(stdout/stderr)            </li>
<li>docker events # 得到docker服务器的实时的事件        </li>
<li>docker port # 显示容器的端口映射        </li>
<li>docker top # 显示容器的进程信息        </li>
<li>docker diff # 显示容器文件系统的前后变化        </li>
</ul>
<p>####导出容器</p>
<ul>
<li>docker cp # 从容器里向外拷贝文件或目录        </li>
<li>docker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息        </li>
</ul>
<p>####执行</p>
<ul>
<li>docker exec # 在容器里执行一个命令，可以执行bash进入交互式        </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker的自我认识（2）]]></title>
      <url>http://codeinterviews.com/Docker%E7%9A%84%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86(1)/</url>
      <content type="html"><![CDATA[<p>这里主要想写一些自己对<strong>docker与虚拟机</strong>的大体了解以及一些认识。</p>
<p>自己对docker的认识还只是初步阶段，并且在以后会不断加入新的内容，希望大家多多包涵！😁</p>
<a id="more"></a>
<p>##一.容器与虚拟机</p>
<p>###虚拟机<br>作为老牌的虚拟化技术，虚拟机被大量公司所采用，它是一种基于硬件的虚拟技术，采用指令级的虚拟，完全虚拟一整物理主机，包含CPU，内存，磁盘，网卡等硬件设备，给用户呈现的就是一个物理主机的特性。<br>其主要架构为下图所示：<br><img src="/img/认识docker/2.jpg" alt="2"></p>
<p>###容器<br>容器是一种基于操作系统的虚拟技术，它运行在操作系统之上的用户空间，所有的容器都共用一个系统内核，甚至是公共库。容器引擎提供进程级别的隔离，让每个容器都像运行在单独的系统上，但又能够共享很多底层资源。<br>其主要架构为下图所示：<br><img src="/img/认识docker/3.jpg" alt="3"></p>
<p>##二.何为Docker<br>Docker 是基于 Go 语言实现的云开源项目,是基于 linux 的多项开源 技术提供了高效、敏捷的和轻量级的容器方案,并且支持在多种主流 平台和本地系统上部署。<br>Docker 目标:“一次封装,到处运行”。</p>
<p>Docker的优势主要有以下几点：</p>
<pre><code>1. 更快速的交付和部署。    
2. 更高效的资源利用。    
3. 更轻松的迁移扩展。    
4. 更简单的更新管理。
</code></pre><h2 id="三-Docker与虚拟机"><a href="#三-Docker与虚拟机" class="headerlink" title="三.Docker与虚拟机"></a>三.Docker与虚拟机</h2><p>Docker作为容器技术的代表，与传统的虚拟技术-虚拟机存在较大的区别，总结一下可以得到以下表格：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动速度</td>
<td>秒级启动</td>
<td>分钟级启动</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为MB</td>
<td>一般为GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于原生</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千容器</td>
<td>一般几十个</td>
</tr>
<tr>
<td>隔离性</td>
<td>安全隔离</td>
<td>完全隔离</td>
</tr>
</tbody>
</table>
<p>##四.总结<br>在计算机技术中,虚拟化是一种资源管理技术,是将计算机 的各种实体资源,如服务器、网络、内存及存储等,予以抽象、转换 后呈现出来,打破实体结构间的不可切割的障碍,使用户可以用比原 本的组态更好的方式来应用这些资源。<br>可见，Docker 以及相关其他容器技术都属于操作系统的虚拟化范畴。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker的自我认识（5）]]></title>
      <url>http://codeinterviews.com/Docker%E7%9A%84%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86(4)/</url>
      <content type="html"><![CDATA[<p>这几天去扬州参加一个云计算和大数据的国际会议，写到一半的docker认识就被这么落下了，😢。</p>
<p>本篇主要是自己对<strong>docker的数据持久化</strong>的大体了解以及一些认识。</p>
<p>自己对docker的认识还只是初步阶段，并且在以后会不断加入新的内容，希望大家多多包涵！😁</p>
<a id="more"></a>
<p>Docker容器的中数据持久化问题，一直是一个讨论比较多的话题。在docker中，容器中的数据持久化主要分别两种方法：</p>
<ol>
<li>通过主机进行数据的挂载        </li>
<li>构建数据卷容器        </li>
</ol>
<p>通过上述两种方法，可以对容器的数据进行持久化的操作，从而防止由于容器被删除而导致数据的丢失。</p>
<p>##主机挂载卷<br>通过主机进行数据的挂载，原理是在容器中提供一个数据卷，即挂载点，然后在运行容器的时候通过<code>-p</code>参数将宿主机的某一个目录挂载到容器中去。</p>
<p>这样做很容易实现宿主机和容器之间的数据传输与共享，而且容器的数据都是保存到本地宿主机上的，这样就很容易的实现数据和容器的分离。</p>
<p>但是这样做存在一些缺点，因为容器的宗旨是一次构建，到处运行。如果将容器的数据保存到宿主机上，这样导致容器的可移植性变得很差。如果要将容器进行迁移，还需迁移数据，这非常的不方便。</p>
<p>##数据卷容器<br>数据卷容器是指一个专门用来挂载数据卷的容器，以供其他容器使用。它主要用于多个容器需要从一处获取数据的情况。有了确定的数据卷容器之后，对它有依赖关系的其他容器就可以通过<code>--volumes-from</code>引用他的数据卷。</p>
<p>这样做的优点也非常明显，docker容器之间可以很好的共享数据，而不需要宿主机配置一个正确的挂载点。</p>
<p>但是缺点是性能略差，原因是数据卷容器本身只是定义了docker虚拟文件系统中数据的存储位置，数据是存储在docker的虚拟文件系统中的，这样会导致IO性能的下降。因此，如果应用需要非常好的IO性能的话，那么数据卷容器可能不是最理想的选择。</p>
<hr>
<p><strong>注意点</strong>：无论是声明数据卷的容器，还是后续引用该数据卷的容器，容器的停止和删除都不会导致数据卷本身的删除。</p>
<p>##总结<br>通过上述两种方式，都能够很好的做到容器中数据的持久化工作。但是这两中方法都有各自的优缺点，应该在充分考虑自己的使用场景的情况下，选择最适合自己的方案。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[docker的自我认识（3）]]></title>
      <url>http://codeinterviews.com/Docker%E7%9A%84%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86(2)/</url>
      <content type="html"><![CDATA[<p>本篇主要是自己对<strong>docker镜像</strong>的大体了解以及一些认识。</p>
<p>自己对docker的认识还只是初步阶段，并且在以后会不断加入新的内容，希望大家多多包涵！😁</p>
<a id="more"></a>
<h2 id="一-构建镜像的方式"><a href="#一-构建镜像的方式" class="headerlink" title="一 .构建镜像的方式"></a>一 .构建镜像的方式</h2><p>如果你想获得一个镜像，主要可以通过两种方式获取：</p>
<ol>
<li>如果你此时已经有了一个该镜像的容器，那么你可以使用<code>docker commit</code>命令将其变成一个镜像。但是这种方式并不是很好，因为你无法对镜像进行修改。                   </li>
<li>编写<strong>DockerFile</strong>文件，然后利用<code>docker build</code>进行镜像的构建。这种方式可以自己编写镜像文件，非常适合修改与扩充，因此推荐使用此方式。     </li>
</ol>
<p>但是DockerFile又是什么呢？又该怎么编写呢？下面主要对DockerFile进行介绍：</p>
<hr>
<h4 id="DockerFile简介"><a href="#DockerFile简介" class="headerlink" title="DockerFile简介"></a>DockerFile简介</h4><p>Dockerfile是自动构建Docker镜像的配置文件。也是Docker区别于其他容器的重要特征，正是有了Dockerfile，Docker的自动化和可移植性才成为可能。</p>
<p>不论是开发还是运维，学会编写Dockerfile几乎是必备的，这有助于你理解整个容器的运行。</p>
<h4 id="DockerFile命令"><a href="#DockerFile命令" class="headerlink" title="DockerFile命令"></a>DockerFile命令</h4><p>其命令主要包含以下多个：</p>
<p><strong>FROM——从一个基础镜像构建新的镜像，必须写在第一行</strong></p>
<p>```<br>FROM ubuntu<br>```</p>
<p><strong>MAINTAINER——该镜像维护者的信息</strong></p>
<p>```<br>MAINTAINER xw <a href="mailto:xwnjnu@gmail.com" target="_blank" rel="external">xwnjnu@gmail.com</a><br>```</p>
<p><strong>ENV——设置环境变量</strong></p>
<p>```<br>ENV MYSQL_ROOT_PASSWD 123<br>```</p>
<p><strong>RUN——非交互式运行shell命令</strong></p>
<p>```<br>RUN apt-get -y update<br>RUN apt-get -y install nginx<br>```</p>
<p><strong>ADD——将外部文件拷贝到镜像里</strong></p>
<p>```<br>ADD /usr/local/test.txt   /data/project<br>```</p>
<p><strong>WORKDIR——设置镜像中的工作目录</strong></p>
<p>```<br>WORKDIR  /var/www<br>```</p>
<p><strong>USER——设置用户id</strong></p>
<p>```<br>USER xw<br>```</p>
<p><strong>VOLUME——设置数据卷，即挂载点</strong></p>
<p>```<br>VOLUME [‘/data’]<br>```</p>
<p><strong>EXPOSE——暴露哪些端口</strong></p>
<p>```<br>EXPOSE 80 8088<br>```</p>
<p><strong>ENTRYPOINT [‘executable’,’param1’,’param2’]——执行命令</strong></p>
<p>```<br>ENTRYPOINT [“/usr/sbin/nginx”]<br>```<br><strong>CMD[‘param1’,’param2’]——docker创建，启动container时执行的命令，如果设置了ENTRYPOINT，则CMD将作为参数</strong></p>
<p>```<br>CMD [“start”]<br>```</p>
<h2 id="二-镜像的特性"><a href="#二-镜像的特性" class="headerlink" title="二.镜像的特性"></a>二.镜像的特性</h2><p>Docker镜像之间不是相互孤立的，而是通过AUFS联合的文件系统将镜像一层一层的叠加在一起。其分层架构如图所示：</p>
<p><img src="/img/%E8%AE%A4%E8%AF%86docker/5.png" alt="2"></p>
<p>正因为docker这种文件层叠共享机制，才造就镜像占用磁盘空间小，扩展容易，传播灵活等特点。</p>
<p>通过<code>docker run</code>命令指定镜像创建一个容器时，实际上是在该镜像上创建一个空的可读写的文件系统层级。父镜像的内容是以只读方式挂载进来的。当需要修改父镜像文件，变会触发docker从父镜像中复制这个文件到临时镜像中来，所有的修改均发生在你的文件系统中，而不会对父镜像造成任何影响，这就是docker镜像的写时复制机制。</p>
<h2 id="三-镜像常用的命令"><a href="#三-镜像常用的命令" class="headerlink" title="三.镜像常用的命令"></a>三.镜像常用的命令</h2><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><ul>
<li>docker images # 显示本地所有的镜像列表 </li>
<li>docker import # 从一个tar包创建一个镜像，往往和export结合使用   </li>
<li>docker build # 使用Dockerfile创建镜像（推荐）   </li>
<li>docker commit # 从容器创建镜像 </li>
<li>docker rmi # 删除一个镜像       </li>
<li>docker load # 从一个tar包创建一个镜像，和save配合使用     </li>
<li>docker save # 将一个镜像保存为一个tar包，带layers和tag信息            </li>
<li>docker history # 显示生成一个镜像的历史命令          </li>
<li>docker tag # 为镜像起一个别名         </li>
</ul>
<h4 id="镜像仓库（registry）操作"><a href="#镜像仓库（registry）操作" class="headerlink" title="镜像仓库（registry）操作"></a>镜像仓库（registry）操作</h4><ul>
<li>docker login # 登录到一个registry        </li>
<li>docker search # 从registry仓库搜索镜像         </li>
<li>docker pull # 从仓库下载镜像到本地          </li>
<li>docker push # 将一个镜像push到registry仓库中     </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Dungeon Game]]></title>
      <url>http://codeinterviews.com/Dungeon-Game/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Dungeon Game</p>
<blockquote>
<p>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p>####Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</p>
<p>For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p>
<pre><code>-2 (K)    -3       3
-5        -10       1
10        30      -5 (P)
</code></pre><p>####Notes:</p>
<ul>
<li>The knight’s health has no upper bound.</li>
<li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.<br>####Credits:<br>Special thanks to @stellari for adding this problem and creating all test cases.</li>
</ul>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这题容易想到的思路是用search DFS或者BFS解，给定起点和终点，我们可以搜索所有从起点到终点的路径，然后贪心保存下来最小的路径权值之和，同时要保证每次扩展分支时当前的生命值状态始终大于0。但是这并不是好的解法，时间复杂度太高。<br>该道题由于只能向右和向下移动，因此可以采用动态规划求解，是一个典型的二维动态规划问题，我们可以如下定义：</p>
<pre><code>对于从（0,0）点走到（m-1,n-1)
dp[i][j]:表示从（i,j）走到（m-1.n-1）所需的最小生命值
递推式为：
dp[i][j]=max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],0)
如果dungeon[i][j]为正，则减去一个正数，初始需要的生命值变小。同理可以理解dungeon[i][j]为负数的情况。和0取最大保证了初始生命值为非负。
</code></pre><p>迭代的方法是初始化后，从下往上，从右往左进行填表。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dungeon==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m=dungeon.length;<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> n=dungeon[<span class="number">0</span>].length;<span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对m-1行和n-1列进行初始化</span></span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>]=Math.max(<span class="number">0</span>-dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	dp[m-<span class="number">1</span>][i]=Math.max(dp[m-<span class="number">1</span>][i+<span class="number">1</span>]-dungeon[m-<span class="number">1</span>][i],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	dp[i][n-<span class="number">1</span>]=Math.max(dp[i+<span class="number">1</span>][n-<span class="number">1</span>]-dungeon[i][n-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行填表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        	&#123;</span><br><span class="line">        		dp[i][j]=Math.max(Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])-dungeon[i][j],<span class="number">0</span>);</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Edit Distance]]></title>
      <url>http://codeinterviews.com/Edit-Distance/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Edit Distance</p>
<blockquote>
<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:   </p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character   </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题求一个字符串编辑成为另一个字符串的最少操作数，操作包括添加，删除或者替换一个字符。<br>这其实是一道二维动态规划的题目，模型上确实不容易看出来，下面我们来说说递推式。<br>我们维护的变量res[i][j]表示的是word1的前i个字符和word2的前j个字符编辑的最少操作数是多少。假设我们拥有res[i][j]前的所有历史信息，看看如何在常量时间内得到当前的res[i][j]，我们讨论两种情况：<br>1）如果word1[i-1]=word2[j-1]，也就是当前两个字符相同，也就是不需要编辑，那么很容易得到res[i][j]=res[i-1][j-1]，因为新加入的字符不用编辑；<br>2）如果word1[i-1]!=word2[j-1]，那么我们就考虑三种操作，如果是插入word1，那么res[i][j]=res[i-1][j]+1，也就是取word1前i-1个字符和word2前j个字符的最好结果，然后添加一个插入操作；如果是插入word2，那么res[i][j]=res[i][j-1]+1，道理同上面一种操作；如果是替换操作，那么类似于上面第一种情况，但是要加一个替换操作（因为word1[i-1]和word2[j-1]不相等），所以递推式是res[i][j]=res[i-1][j-1]+1。上面列举的情况包含了所有可能性，有朋友可能会说为什么没有删除操作，其实这里添加一个插入操作永远能得到与一个删除操作相同的效果，所以删除不会使最少操作数变得更好，因此如果我们是正向考虑，则不需要删除操作。取上面几种情况最小的操作数，即为第二种情况的结果，即res[i][j] = min(res[i-1][j], res[i][j-1], res[i-1][j-1])+1。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1.length()==<span class="number">0</span>)  </span><br><span class="line">        	<span class="keyword">return</span> word2.length();  </span><br><span class="line">    	<span class="keyword">if</span>(word2.length()==<span class="number">0</span>)  </span><br><span class="line">        	<span class="keyword">return</span> word1.length();  </span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=word1.length();i++)<span class="comment">//表示word2为空，word1变成word2的删除操作数</span></span><br><span class="line">            res[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=word2.length();j++)<span class="comment">//表示word1为空，word2变成word1的删除操作数</span></span><br><span class="line">            res[<span class="number">0</span>][j]=j;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=word1.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=word2.length();j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">        			res[i][j]=res[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        		&#123;</span><br><span class="line">        			<span class="keyword">int</span> num=Math.min(res[i-<span class="number">1</span>][j],res[i][j-<span class="number">1</span>]);</span><br><span class="line">        			res[i][j]=Math.min(res[i-<span class="number">1</span>][j-<span class="number">1</span>],num)+<span class="number">1</span>;</span><br><span class="line">        		&#125;	</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Excel Sheet Column Number]]></title>
      <url>http://codeinterviews.com/Excel-Sheet-Column-Number%20/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Excel Sheet Column Number </p>
<blockquote>
<p>Related to question <a href="http://pisxw.com/algorithm/Excel-Sheet-Column-Title.html" target="_blank" rel="external">Excel Sheet Column Title</a></p>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
</code></pre><p>####Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是<a href="http://pisxw.com/algorithm/Excel-Sheet-Column-Title.html" target="_blank" rel="external">Excel Sheet Column Title</a>的翻转，给出字母序列得到对应的单元格数字，这个其实只要找到每一个字母对应的数字，然后乘以其所在的位置的26的次方即可，类似于将字符串数字转化为整数数字。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(s==<span class="keyword">null</span> ||s.length()==<span class="number">0</span>)</span><br><span class="line">	    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="comment">//用一个map存放26个字母对应的数字</span></span><br><span class="line">	    HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">	    <span class="keyword">char</span> ch=<span class="string">'A'</span>;</span><br><span class="line">	    <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">	    map.put(ch,num);</span><br><span class="line">	    <span class="keyword">while</span>(num&lt;<span class="number">26</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	ch+=<span class="number">1</span>;</span><br><span class="line">	    	num+=<span class="number">1</span>;</span><br><span class="line">	    	map.put(ch,num);</span><br><span class="line">	</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	res=res*<span class="number">26</span>+map.get(s.charAt(i));</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Evaluate Reverse Polish Notation]]></title>
      <url>http://codeinterviews.com/Evaluate-Reverse-Polish-Notation/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Evaluate Reverse Polish Notation</p>
<blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>
<p>Some examples:</p>
<pre><code>[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9
[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是给出表达式的后序表示，然后对其进行求值。我们可以使用一个栈来进行维护，当遇到数字时则入栈，当遇到操作符的时候，则弹出栈顶的两个元素，进行表达式运算，然后将结果压入栈中，最终栈中的元素即为最后表达式的结果。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens==<span class="keyword">null</span> || tokens.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;String&gt; stack=<span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tokens.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">switch</span>(tokens[i])</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        		&#123;</span><br><span class="line">        			<span class="keyword">int</span> a=Integer.parseInt(stack.pop());</span><br><span class="line">        			<span class="keyword">int</span> b=Integer.parseInt(stack.pop());</span><br><span class="line">        			<span class="keyword">int</span> c=a+b;</span><br><span class="line">        			stack.push(c+<span class="string">""</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">        		&#123;</span><br><span class="line">        			<span class="keyword">int</span> a=Integer.parseInt(stack.pop());</span><br><span class="line">        			<span class="keyword">int</span> b=Integer.parseInt(stack.pop());</span><br><span class="line">        			<span class="keyword">int</span> c=b-a;</span><br><span class="line">        			stack.push(c+<span class="string">""</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        		&#123;</span><br><span class="line"></span><br><span class="line">        			<span class="keyword">int</span> a=Integer.parseInt(stack.pop());</span><br><span class="line">        			<span class="keyword">int</span> b=Integer.parseInt(stack.pop());</span><br><span class="line">        			<span class="keyword">int</span> c=a*b;</span><br><span class="line">        			stack.push(c+<span class="string">""</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">        		&#123;</span><br><span class="line">        			<span class="keyword">int</span> a=Integer.parseInt(stack.pop());</span><br><span class="line">        			<span class="keyword">int</span> b=Integer.parseInt(stack.pop());</span><br><span class="line">        			<span class="keyword">int</span> c=b/a;</span><br><span class="line">        			stack.push(c+<span class="string">""</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">default</span>:&#123;</span><br><span class="line">        			stack.push(tokens[i]);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Excel Sheet Column Title]]></title>
      <url>http://codeinterviews.com/Excel-Sheet-Column-Title/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Excel Sheet Column Title</p>
<blockquote>
<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
</code></pre><p>####Credits:<br>Special thanks to @ifanchu for adding this problem and creating all test cases..</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题每次对数字进行26取模，就能能到其尾数是哪一个字母，然后得到的余数如果大于26，则继续循环处理，否则就在结果的前端插入字母下标位置为余数的字母。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//定义个hashmap存放26个字母及其对应的数字 ,A-0,B-1,....,Z-25</span></span><br><span class="line">        HashMap&lt;Integer,Character&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Character&gt;();</span><br><span class="line">        <span class="keyword">char</span> ch=<span class="string">'A'</span>;</span><br><span class="line">        map.put(<span class="number">0</span>,ch);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	ch+=<span class="number">1</span>;</span><br><span class="line">        	map.put(i,ch);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">26</span>)</span><br><span class="line">        &#123;	</span><br><span class="line">			<span class="comment">//每次取模进行处理，并将结果插入到StringBuilder的前端。</span></span><br><span class="line">        	<span class="keyword">int</span> shang=(n-<span class="number">1</span>)%<span class="number">26</span>;</span><br><span class="line">        	res.insert(<span class="number">0</span>,map.get(shang));</span><br><span class="line">        	n=(n-<span class="number">1</span>)/<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.insert(<span class="number">0</span>,map.get(n-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res.toString();       	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Factorial Trailing Zeroes]]></title>
      <url>http://codeinterviews.com/Factorial-Trailing-Zeroes/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Factorial Trailing Zeroes</p>
<blockquote>
<p>Given an integer n, return the number of trailing zeroes in n!.</p>
<p>Note: Your solution should be in logarithmic time complexity.</p>
<p>####Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题如果像把其结果计算出来后，利用取余的方法求得有多少个0，在这里时间会过不去，因此需要另辟蹊径。</p>
<p>经过分析，发现其零的个数是由5产生的，那么问题就可以解决了，只要求出n中有多少个5不就知道有多少个零了么？举了几个例子试试看，比如n=5，只有一个5，于是结果为result=1，再如n=10，result=2；n=20，result=4。直接举n=100，发现result=24，n / 100 = 20，显然5， 10， 15，…， 95，100，刚好20个数，但是其中还有以下数的因子中有5的倍数，比如25，50， 75，100，这4个数中其实是包含2个5，也就是说就会多产生一个零，于是就有24个了。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过分析可知，我们可以对n不断取5模</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	n /=<span class="number">5</span>;</span><br><span class="line">        	res+=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Find Minimum in Rotated Sorted Array II]]></title>
      <url>http://codeinterviews.com/Find-Minimum-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Find Minimum in Rotated Sorted Array II</p>
<blockquote>
<p>Follow up for “Find Minimum in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?<br>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是[Find Minimum in Rotated Sorted Array][1]的扩展，里面包含了重复元素。</p>
<p>不过正是因为这个条件的出现，影响到了算法的时间复杂度。原来我们是依靠中间和边缘元素的大小关系，来判断哪一半是不受rotate影响，仍然有序的。而现在因为重复的出现，如果我们遇到中间和边缘相等的情况，我们就无法判断哪边有序，因为哪边都有可能有序。假设原数组是{1,2,3,3,3,3,3}，那么旋转之后有可能是{3,3,3,3,3,1,2}，或者{3,1,2,3,3,3,3}，这样的我们判断左边缘和中心的时候都是3，我们并不知道应该截掉哪一半。解决的办法只能是对边缘移动一步，直到边缘和中间不在相等或者相遇，这就导致了会有不能切去一半的可能。所以最坏情况就会出现每次移动一步，总共移动n此，算法的时间复杂度变成O(n)</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minnum=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        	<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span>(num[l]&lt;num[m])</span><br><span class="line">        	&#123;</span><br><span class="line">        		minnum=Math.min(minnum,num[l]);</span><br><span class="line">        		l=m+<span class="number">1</span>;</span><br><span class="line">        	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num[l]&gt;num[m])</span><br><span class="line">        	&#123;</span><br><span class="line">        		minnum=Math.min(minnum,num[m]);</span><br><span class="line">        		r=m-<span class="number">1</span>;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				/如果l和m相等，则只能对l+<span class="number">1</span></span><br><span class="line">        		minnum=Math.min(minnum,num[l]);</span><br><span class="line">        		l++;</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Find Minimum in Rotated Sorted Array]]></title>
      <url>http://codeinterviews.com/Find-Minimum-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Find Minimum in Rotated Sorted Array</p>
<blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是<a href="http://pisxw.com/algorithm/Search-in-Rotated-Sorted-Array.html" target="_blank" rel="external">Search in Rotated Sorted Array</a>的扩展，不是找目标元素，而是找最小元素，方法与其类似，首先取中点，然后判断两边哪边有序，如果左边有序，则取左边第一个元素与最小元素进行对比，然后得到更小的元素，再去遍历右边去寻找。否则右边有序，则取右边第一个元素与最小元素进行对比，然后得到更小的元素，再去遍历左边去寻找。每次都能够切掉一半的元素。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minnum=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">        	<span class="comment">//如果左边有序</span></span><br><span class="line">        	<span class="keyword">if</span>(num[l]&lt;=num[m])</span><br><span class="line">        	&#123;</span><br><span class="line">        		minnum=Math.min(minnum,num[l]);</span><br><span class="line">        		l=m+<span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		minnum=Math.min(minnum,num[m]);</span><br><span class="line">        		r=m-<span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-First Missing Positive]]></title>
      <url>http://codeinterviews.com/First-Missing-Positive/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####First Missing Positive </p>
<blockquote>
<p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,</p>
<p>Given <code>[1,2,0]</code> return <code>3</code>,</p>
<p>and <code>[3,4,-1,1]</code> return <code>2</code>.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题的要求很明确，即第一个不存在的正数，但是需要在线性时间和常量空间下得到。线性的时间意味着不能对数组进行常规排序，因为快排时间复杂度为<code>O(nlogn)</code>。常量空间指不能开辟额外的空间。<br>因此为了搜寻元素，这里采用数组的下标作为其索引，即对数组的元素进行交换，将正数<code>i</code>放到<code>i-1</code>的位置上，对于负数和大于数组长度的元素弃之不顾。这样线性扫描一下数组就能得到第一个不存在的正数，即第<code>j</code>位置的元素不等于<code>j+1</code>。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将正数放到值-1的位置上，这样1放在0号位置，2放在1号位置，。。。。</span></span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(A[i]&lt;=A.length &amp;&amp; A[i]&gt;<span class="number">0</span> &amp;&amp; A[A[i]-<span class="number">1</span>]!=A[i])</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">int</span> temp=A[A[i]-<span class="number">1</span>];</span><br><span class="line">        		A[A[i]-<span class="number">1</span>]=A[i];</span><br><span class="line">        		A[i]=temp;</span><br><span class="line">        		i--;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(A[i]!=(i+<span class="number">1</span>))</span><br><span class="line">        		<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A.length+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Flatten Binary Tree to Linked List]]></title>
      <url>http://codeinterviews.com/Flatten-Binary-Tree-to-Linked-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Flatten Binary Tree to Linked List</p>
<blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre><p>The flattened tree should look like:</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre><p>click to show hints.</p>
<p>####Hints:<br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题要求把一颗二叉树按照先序遍历顺序展成一个链表，不过这个链表还是用树的结果，即就地解决问题，就是一直往右走（没有左孩子）来模拟链表。老套路还是用递归来解决，维护先序遍历的前一个结点pre，然后每次把pre的左结点置空，右结点设为当前结点。这里需要注意的一个问题就是我们要先把右子结点保存一下，以便等会可以进行递归，否则有可能当前结点的右结点会被覆盖，后面就取不到了。算法的复杂度时间上还是一次遍历，O(n)。空间上是栈的大小，O(logn)。</p>
<p>树的题目主要考虑递归，要考虑好递归条件和结束条件。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//定义前序节点的存放</span></span><br><span class="line">    	ArrayList&lt;TreeNode&gt; pre=<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    	pre.add(<span class="keyword">null</span>);</span><br><span class="line">        helper(root,pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;TreeNode&gt; pre)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	<span class="comment">//因为root右节点在递归中会有变化，所以需要保存右节点</span></span><br><span class="line">    	TreeNode tmp=root.right;</span><br><span class="line">    	<span class="keyword">if</span>(pre.get(<span class="number">0</span>)!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		pre.get(<span class="number">0</span>).left=<span class="keyword">null</span>;</span><br><span class="line">    		pre.get(<span class="number">0</span>).right=root;</span><br><span class="line">    	&#125;</span><br><span class="line">    	pre.set(<span class="number">0</span>,root);</span><br><span class="line">    	helper(root.left,pre);</span><br><span class="line">    	helper(tmp,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Generate Parentheses]]></title>
      <url>http://codeinterviews.com/Generate-Parentheses/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Generate Parentheses</p>
<blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<p><code>&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;</code></p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>一般来说是用递归的方法，因为可以归结为子问题去操作。在每次递归函数中记录左括号和右括号的剩余数量，然后有两种选择，一个是放一个左括号，另一种是放一个右括号。当然有一些否定条件，比如剩余的右括号不能比左括号少，或者左括号右括号数量都要大于0。正常结束条件是左右括号数量都为0。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//采用递归求解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; lists=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	<span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> lists;</span><br><span class="line">    	helper(n,n,<span class="keyword">new</span> String(),lists);</span><br><span class="line">    	<span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,String term,ArrayList&lt;String&gt; lists)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">0</span>&amp;&amp;r==<span class="number">0</span>)</span><br><span class="line">            lists.add(term);</span><br><span class="line">        <span class="keyword">if</span>(l&gt;<span class="number">0</span>)</span><br><span class="line">            helper(l-<span class="number">1</span>,r,term+<span class="string">"("</span>,lists);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;<span class="number">0</span>)</span><br><span class="line">            helper(l,r-<span class="number">1</span>,term+<span class="string">")"</span>,lists);          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Fraction to Recurring Decimal]]></title>
      <url>http://codeinterviews.com/Fraction-to-Recurring-Decimal/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Fraction to Recurring Decimal</p>
<blockquote>
<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>For example,</p>
<ul>
<li>Given numerator = 1, denominator = 2, return “0.5”.</li>
<li>Given numerator = 2, denominator = 1, return “2”.</li>
<li>Given numerator = 2, denominator = 3, return “0.(6)”.<br>####Credits:<br>Special thanks to @Shangrila for adding this problem and creating all test cases.</li>
</ul>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>先大致介绍一下需要使用到的数据结构，因为要match重复出现过的数据。HashMap必然是首选。记录出现过的数据然后每次检查是否存在在HashMap里面就可以检查重复就好。那么核心问题来了，这个HashSet应该放什么？可能是一个小数循环序列。但是这样子的话首先不说HashSet难以实现，时间复杂度也会很高。如果匹配的是一个小数循环序列，每次都要重新从尾到头遍历一次进行匹配尝试。所以最终的复杂度会是O(N^2)。但是如果存的是每一位对应的余数，就不一样了。先说一下余数的有效性。余数实际上是某种意义的被除数，只要被除数和除数相同，那么商肯定也是一样的。在这里，除数是不变的，所以只要出现了相同的余数/被除数，那么后续的结果序列必然也是相同的。所以实际上我们用一个HashMap<integer, integer="">即可。键放的是出现过的余数，值放的是对应的位置。所以只要余数出现过一次，再次出现的时候，只要把对应的位置找出来，将左括号插入进去，再在最后加一个右括号就可以了。基于上述讨论，算法如下：</integer,></p>
<p>1.先把整数部分解决了。就是大于0的商给算好了。</p>
<p>2。然后从小数部分第一位开始往哈希表里放余数和对应的位置，每次除完之后余数就乘以10相当于往下进一位，同时将当前位的商存入结果。新余数保留做下一个循环使用。</p>
<p>3.循环完结条件有二：1.当前余数已经出现过。表示循环已找到。2.余数变成0，表示这是一个有限循环小数，并没有可以表示的recurring decimal。</p>
<p>4.注意一下边界条件和负数的处理就好。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先先算出整数</span></span><br><span class="line">        Long long_numerator=(<span class="keyword">long</span>)numerator;</span><br><span class="line">        <span class="keyword">long</span> long_denominator=(<span class="keyword">long</span>)denominator;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">double</span>)long_numerator/(<span class="keyword">double</span>)long_denominator&lt;<span class="number">0</span>)</span><br><span class="line">        	res.append(<span class="string">"-"</span>);</span><br><span class="line">        res.append(Math.abs(long_numerator/long_denominator));<span class="comment">//存放整数部分</span></span><br><span class="line">        long_numerator %=long_denominator;<span class="comment">//余数</span></span><br><span class="line">        long_numerator *=<span class="number">10</span>;<span class="comment">//对余数乘以10，以便进行除法运算。</span></span><br><span class="line">        <span class="keyword">if</span>(long_numerator==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res.toString();</span><br><span class="line">        res.append(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个hashmap存放每一位的除数及其在字符串中的位置，如果除数以前出现过，则会出现循环小数,使用long防止溢出</span></span><br><span class="line">        HashMap&lt;Long,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Long,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> cur=res.length();</span><br><span class="line">        <span class="keyword">while</span>(long_numerator!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(map.containsKey(long_numerator))<span class="comment">//如果除数以前出现过，则会出现循环小数</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		res.append(<span class="string">")"</span>);</span><br><span class="line">        		res.insert(map.get(long_numerator),<span class="string">"("</span>);</span><br><span class="line">        		<span class="keyword">return</span> res.toString();</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果没有出现过，则继续进行除法运算，直到出现过，或出现0</span></span><br><span class="line">        		map.put(long_numerator,cur);</span><br><span class="line">        		res.append(Math.abs(long_numerator/long_denominator));</span><br><span class="line">        		long_numerator %=long_denominator;</span><br><span class="line">        		long_numerator *=<span class="number">10</span>;</span><br><span class="line">        		cur++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Gas Station]]></title>
      <url>http://codeinterviews.com/Gas-Station/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Gas Station</p>
<blockquote>
<p>There are <code>N</code> gas stations along a circular route, where the amount of gas at station i is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <code>i</code> to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p>####Note:<br>The solution is guaranteed to be unique.</p>
<a id="more"></a>
</blockquote>
<p>##解题思路<br>这是一道具体问题的题目，brute force的方法比较容易想到，就是从每一个站开始，一直走一圈，累加过程中的净余的油量，看它是不是有出现负的，如果有则失败，从下一个站开始重新再走一圈；如果没有负的出现，则这个站可以作为起始点，成功。可以看出每次需要扫描一圈，对每个站都要做一次扫描，所以时间复杂度是O(n^2)。代码比较直接，这里就不列举了。<br>接下来说说如何提高这个算法。方法主要思想是把这个圈划分成一个个的负序列，以及一个正序列（如果存在的话）。从任意一个站出发，我们可以累加油的净余量，如果出现负的，序列结束，开启一个新的，并且证明旧的这个序列的起点不能作为起点，因为会出现负油量，不能继续前进。下面我们证明<br>不仅这个负序列的起点不能作为起点，负序列中的任意一点都不能作为起点。<br>证明：假设我们取定负序列中的一个站作为起点，因为一个序列一旦遇到负的净余量就会结束并且开启新的，那么说明在这个起点前的累加结果必然是正数（否则会结束这个序列，则前面不会是这个序列的一部分）。如此我们从当前序列出发必然会使走到序列终点时负的油量更大，本来已经是负的，所以不能去负序列的任意一个结点作为起点。<br>根据上面的划分方式，我们会把圈分成一段段的序列，而且其中最多只有一个正序列，那就是绕一圈回到起点的那个序列（当然也有可能整个圈是一个正序列，就是油量一直为正，那么我们测的开始点就可以作为起点了）。接下来我们证明 如果将全部油量累计起来，总量为正，那么一定能找到一个起点，使得可以走完一圈，也就是一定有解。<br>证明：按照我们之前的划分，整个圈会被划分成有累积量为s1, s2, …, sk 的负序列，以及一个正序列拥有油量sp（这里正序列一定存在因为全部累加和是正的，如果全是负序列那么结果不会是正的）。而且我们知道s1+s2+…+sk+sp&gt;0，也就是说sp&gt;-s1-s2-…-sk。换句话说，如果我们从sp对应的站的起点出发，在sp对应的序列会一直是正的，并且，当他走到负序列时，因为sp的正油量大于所有负油量的总和，所以累加油量会一直正，完整整个圈的行驶。这证明了只要累加油量是正的，一定能找到一个起点来完成任务。<br>根据上面的两个命题，我们可以来实现代码，需要维护两个量，一个是总的累积油量total，另一个是当前序列的累计油量sum，如果出现负的，则切换起点，并且将sum置0。总共是需要扫描所有站一次，时间复杂度是O(n)。而只需要两个额外变量，空间复杂度是O(1)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br>广度优先遍历：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gas==<span class="keyword">null</span> || cost==<span class="keyword">null</span> || gas.length==<span class="number">0</span> || cost.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//到达当前加油站的总净容量</span></span><br><span class="line">        <span class="keyword">int</span> total=<span class="number">0</span>;<span class="comment">//整个完成一圈的总容量</span></span><br><span class="line">        <span class="keyword">int</span> pointer=<span class="number">0</span>;<span class="comment">//定义起点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> diff=gas[i]-cost[i];</span><br><span class="line">        	sum+=diff;</span><br><span class="line">        	total+=diff;</span><br><span class="line">        	<span class="keyword">if</span>(sum&lt;<span class="number">0</span>) <span class="comment">//到达该节点油不够。那么这之间的节点都不能作为起点，因为这之间的节点都是正净容量。</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		sum=<span class="number">0</span>;</span><br><span class="line">        		pointer=i+<span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total&gt;=<span class="number">0</span>?pointer:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Gray Code]]></title>
      <url>http://codeinterviews.com/Gray-Code/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Gray Code</p>
<blockquote>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p>
<pre><code>00 - 0
01 - 1
11 - 3
10 - 2
</code></pre><p><strong>Note</strong>:<br>For a given n, a gray code sequence is not uniquely defined.</p>
<p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>学过格雷码的童鞋应该比较好理解，比如<code>n=3</code>时</p>
<pre><code>000
001
011
010
------
110
111
101
100
</code></pre><p>规律是<strong>将格雷码看成是上下两部分</strong>，上部分是第一位为0，下部分是第一位为1，这样后面<code>n-1</code>位即为<code>n-1</code>位的格雷码。例如</p>
<pre><code>n=1 
0
--
1
上 0  下 1

n=2
00
01
---
11
10
上为n=1时的格雷码 下为n=1时的格雷码的倒序再加上最前面的1
</code></pre><p>找到了如上的规律，则求解<code>n</code>位的格雷码就是从<code>1</code>位格雷码不断求解即可</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	res.add(<span class="number">0</span>);</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//n=1的格雷码</span></span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        res.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> num=<span class="number">1</span>&lt;&lt;(i-<span class="number">1</span>);</span><br><span class="line">        	<span class="comment">//第i位格雷码为（第i-1位格雷码前面+0）和（第i-1位格雷码倒序后前面+1）</span></span><br><span class="line">        	<span class="comment">//而前面+0即为i-1位的格雷码，所以不需要做</span></span><br><span class="line">        	<span class="comment">//只需要对i-1位进行倒序，然后前面+1</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=res.size()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        		res.add(res.get(j)+num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HBase 应用程序开发]]></title>
      <url>http://codeinterviews.com/HBase%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h4 id="一、配置-Eclipse"><a href="#一、配置-Eclipse" class="headerlink" title="一、配置 Eclipse"></a>一、配置 Eclipse</h4><p>上次实验，我们学习了HBase的安装和配置。有了对HBase一定的了解后，我们趁热打铁，开始学习HBase应用程序开发。因为我们在开发过程中需要用到Eclipse, 所以需要先对Eclipse进行配置。</p>
<a id="more"></a>
<p><strong>（1） 新建工程</strong></p>
<p>我们在Eclipse中新建一个Java Project, 选择 File-&gt;New-&gt;Java Project</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427278637657" alt="图片描述信息"></p>
<p><strong>（2）指定HBase配置文件的位置</strong></p>
<p>当第三方程序访问HBase的时候，首选需要访问Zookeeper. Zookeeper是一个为分布式应用所设计的开源协调服务，默认情况下HBase自身有一组默认的Zookeeper实例，当然用户也可以配置其他独立的Zookeeper. 因为HBase的重要信息保存在Zookeeper之中。而Zookeeper的集群的信息由 <code>${HBASE_DIR}/conf/hbase-site.xml</code> 文件指定，因此需要通过CLASSPATH来指定HBase配置文件（即 ${HBASE_DIR}/conf/）的位置。</p>
<p>在你的工程目录下新建一个名为conf的文件夹，将Hbase的配置文件 hbase-site.xml 复制到该目录。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427335181678" alt="图片描述信息"></p>
<p>然后右击项目工程，选择 Properties-&gt;Java Build Path-&gt;Libraries-&gt;Add Class Folder, 将刚刚增加的conf目录选上。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427278670257" alt="图片描述信息"></p>
<p><strong>（3）添加 jar 包</strong></p>
<p>右击项目工程，选择 Properties-&gt;Java Build Path-&gt;Libraries-&gt;Add External JARs, 选择添加所需的 jar 包（ jar 包的位置在 ${HBASE_DIR}/lib/ 中）。<strong>为了避免不同版本等可能引发的问题，我们建议你在实验过程中，直接添加lib目录下的全部 jar 包即可。</strong></p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427278776263" alt="图片描述信息"></p>
<p><strong><em>注意：如果你不能或没有权限添加 conf 文件夹和 jar 包，请先将其复制到一个用户目录，再进行添加。</em></strong></p>
<h4 id="二、在Eclipse中编写测试代码"><a href="#二、在Eclipse中编写测试代码" class="headerlink" title="二、在Eclipse中编写测试代码"></a>二、在Eclipse中编写测试代码</h4><p>按照你的命名习惯，新建一个Test类，</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427278800243" alt="图片描述信息"></p>
<p>添加如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HColumnDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HTableDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Get;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.HBaseAdmin;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.HTable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Result;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.ResultScanner;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Scan;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HBaseTestCase</span> </span>&#123;	   </span><br><span class="line">    <span class="comment">//声明静态配置 HBaseConfiguration</span></span><br><span class="line">    <span class="keyword">static</span> Configuration cfg=HBaseConfiguration.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一张表，通过HBaseAdmin HTableDescriptor来创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">creat</span><span class="params">(String tablename,String columnFamily)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HBaseAdmin admin = <span class="keyword">new</span> HBaseAdmin(cfg);</span><br><span class="line">        <span class="keyword">if</span> (admin.tableExists(tablename)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"table Exists!"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            HTableDescriptor tableDesc = <span class="keyword">new</span> HTableDescriptor(tablename);</span><br><span class="line">            tableDesc.addFamily(<span class="keyword">new</span> HColumnDescriptor(columnFamily));</span><br><span class="line">            admin.createTable(tableDesc);</span><br><span class="line">            System.out.println(<span class="string">"create table success!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//添加一条数据，通过HTable Put为已经存在的表来添加数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String tablename,String row, String columnFamily,String column,String data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HTable table = <span class="keyword">new</span> HTable(cfg, tablename);</span><br><span class="line">        Put p1=<span class="keyword">new</span> Put(Bytes.toBytes(row));</span><br><span class="line">        p1.add(Bytes.toBytes(columnFamily), Bytes.toBytes(column), Bytes.toBytes(data));</span><br><span class="line">        table.put(p1);</span><br><span class="line">        System.out.println(<span class="string">"put '"</span>+row+<span class="string">"','"</span>+columnFamily+<span class="string">":"</span>+column+<span class="string">"','"</span>+data+<span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String tablename,String row)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    	HTable table=<span class="keyword">new</span> HTable(cfg,tablename);</span><br><span class="line">    	Get g=<span class="keyword">new</span> Get(Bytes.toBytes(row));</span><br><span class="line">		Result result=table.get(g);</span><br><span class="line">		System.out.println(<span class="string">"Get: "</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示所有数据，通过HTable Scan来获取已有表的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String tablename)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">         HTable table = <span class="keyword">new</span> HTable(cfg, tablename);</span><br><span class="line">         Scan s = <span class="keyword">new</span> Scan();</span><br><span class="line">         ResultScanner rs = table.getScanner(s);</span><br><span class="line">         <span class="keyword">for</span>(Result r:rs)&#123;</span><br><span class="line">             System.out.println(<span class="string">"Scan: "</span>+r);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(String tablename)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	HBaseAdmin admin=<span class="keyword">new</span> HBaseAdmin(cfg);</span><br><span class="line">    	<span class="keyword">if</span>(admin.tableExists(tablename))&#123;</span><br><span class="line">    		<span class="keyword">try</span></span><br><span class="line">    		&#123;</span><br><span class="line">	    		admin.disableTable(tablename);</span><br><span class="line">	    		admin.deleteTable(tablename);</span><br><span class="line">    		&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    			ex.printStackTrace();</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span> <span class="params">(String [] agrs)</span> </span>&#123;</span><br><span class="line">    	String tablename=<span class="string">"hbase_tb"</span>;</span><br><span class="line">	String columnFamily=<span class="string">"cf"</span>;</span><br><span class="line">  	</span><br><span class="line">    	<span class="keyword">try</span> &#123;    	 	</span><br><span class="line">            HBaseTestCase.creat(tablename, columnFamily);</span><br><span class="line">            HBaseTestCase.put(tablename, <span class="string">"row1"</span>, columnFamily, <span class="string">"cl1"</span>, <span class="string">"data"</span>);</span><br><span class="line">            HBaseTestCase.get(tablename, <span class="string">"row1"</span>);</span><br><span class="line">            HBaseTestCase.scan(tablename);</span><br><span class="line"> <span class="comment">/*           if(true==HBaseTestCase.delete(tablename))</span><br><span class="line">            	System.out.println("Delete table:"+tablename+"success!");</span><br><span class="line"> */</span>      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在该类中，实现了类似HBase Shell的表 create, Put, Get, Scan以及delete等操作。</p>
<p>简单分析一下，在上面的代码中，我们通过第3行加载HBase默认配置cfg; 然后，通过HbaseAdmin接口来管理现有数据库，见第7行。第8行 ~ 第18行通过HTableDescriptor（指定表相关信息）<br>和HColumnDescriptor（指定表内列族相关信息）来创建一个HBase数据库，并设置其拥有的列族成员；put函数通过HTable和Put类为该表添加值，见第21行 ~ 第27行；get函数通过HTable和Get读取刚刚添加的值，见第<br>29行 ~ 第34行；Scan函数通过HTable和Scan类读取表中的所有记录，见第36行 ~ 第43行；delete函数，通过HBaseAdmin首先将表置为无效（第51行），然后将其删除（第52行）。</p>
<h4 id="三、启动Hadoop和HBase集群"><a href="#三、启动Hadoop和HBase集群" class="headerlink" title="三、启动Hadoop和HBase集群"></a>三、启动Hadoop和HBase集群</h4><p>在开始运行程序之前，我们必须先启动Hadoop或HBase集群，我们在上节实验中已经详细介绍了，你可以点击<a href="http://www.shiyanlou.com/courses/37" target="_blank" rel="external">HBase安装配置</a>回顾一下。</p>
<p>如果你是 <strong>伪分布模式</strong> 部署的，请在相关目录下依次输入命令 <code>./start-all.sh</code> 和  <code>./start-hbase.sh</code> 来启动。而如果是 <strong>单机模式</strong>，只需在 HBase 的正确路径下输入 <code>./start-hbase.sh</code> 来启动。本次实验以 <em>伪分布模式</em> 示例。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427278929713" alt="图片描述信息"></p>
<hr>
<h4 id="四、运行Java程序"><a href="#四、运行Java程序" class="headerlink" title="四、运行Java程序"></a>四、运行Java程序</h4><p>运行程序非常简单，右击项目工程，Run As -&gt; Java Application 就OK了。然后你可以在 Console（控制台）看到程序运行的情况：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427278947301" alt="图片描述信息"></p>
<p>如果你没有在Eclipse中看到 Console 窗口，请依次选择 Window-&gt;Show View-&gt;Other-&gt;General-&gt;Console.</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427278966751" alt="图片描述信息"></p>
<p>然后：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427278983567" alt="图片描述信息"></p>
<p>####五、使用 HBase Shell 对比查看<br>Java 程序成功运行之后，由于此程序是一个模拟数据库相关操作的，因此我们可以通过 HBase Shell 来对比查看该Java程序的运行结果。</p>
<p>输入 <code>./hbase shell</code> 进入来HBase Shell</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427279013629" alt="图片描述信息"></p>
<p>输入 <code>list</code> 查看表的列项，可以看到已经成功创建了名为 &#39;hbase_tb&#39; 的一张表：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427279023749" alt="图片描述信息"></p>
<p>再输入 <code>scan &amp;#39;hbase_tb&amp;#39;</code> 来查看表的内容：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid756time1427279038103" alt="图片描述信息"></p>
<p>对比Eclipse中Console中打印的结果，可以发现二者是一致的。</p>
<hr>
<p>####六、参考文档<br>&gt;  <em> 《Hadoop实战第2版》 陆嘉恒，机械工业出版社；<br>&gt;  </em>   <a href="http://mmicky.blog.163.com/blog/static/1502901542013101911950800/" target="_blank" rel="external">使用Eclipse开发HBase应用程序</a></p>
<hr>
<p>####七、本次小结<br>本次实验学习和了解了如何在Eclipse下使用HBase API进行一些Java应用程序开发。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HBase安装配置]]></title>
      <url>http://codeinterviews.com/HBase%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h4 id="一、安装之前-检查必要条件"><a href="#一、安装之前-检查必要条件" class="headerlink" title="一、安装之前 - 检查必要条件"></a>一、安装之前 - 检查必要条件</h4><p> <strong>(1) Java （需要安装1.6.x及其以上版本)</strong></p>
<p>在终端输入 <code>java -version</code> 来查看你机子上的 Java 版本；</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427278141378" alt="图片描述信息"></p>
<p><strong>(2) Hadoop</strong></p>
<p>Hadoop的具体安装可以参见<a href="http://pisxw.com/project/hadoop2.6.0%E4%BC%AA%E5%88%86%E5%B8%83%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2.html" target="_blank" rel="external">Hadoop部署及管理</a>。需要注意的是伪分布模式下，HBase 的版本需要和 Hadoop版本 <code>匹配</code> ，不然很可能容易出错。你可以在HBase的lib目录下看到对应的Hadoop的Jar文件版本。</p>
<p>在这里，我们使用了Hadoop V2.4.1版本以及HBase V0.98.11版本。</p>
<p><strong>(3) SSH</strong></p>
<p>SSH的安装，在<a href="http://pisxw.com/project/hadoop2.6.0%E4%BC%AA%E5%88%86%E5%B8%83%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2.html" target="_blank" rel="external">Hadoop部署及管理</a>中也涵盖了这部分内容。SSH用来管理远程Hadoop和HBase守护进程。</p>
<hr>
<a id="more"></a>
<h4 id="二、安装进行时-安装和配置HBase"><a href="#二、安装进行时-安装和配置HBase" class="headerlink" title="二、安装进行时 - 安装和配置HBase"></a>二、安装进行时 - 安装和配置<strong>HBase</strong></h4><p>确认上面的条件我们都准备好了之后，就可以开始安装HBase了。实验开始前，你应该切换到 hadoop 用户：</p>
<pre><code>$ su hadoop
</code></pre><p>HBase的安装通常分为3种模式：</p>
<p><strong>1. 单机模式  安装</strong></p>
<p><strong>（1）下载和解压</strong></p>
<p>单机模式的安装非常简单，几乎不用对安装文件做什么修改就可以使用。单机模式下，HBase并不使用HDFS，因此将安装文件解压后就几乎可以直接运行。输入命令下载HBase：</p>
<pre><code>$ wget http://mirrors.aliyun.com/apache/hbase/hbase-0.98.11/hbase-0.98.11-hadoop2-bin.tar.gz
</code></pre><p>再将其压缩包解压：</p>
<pre><code>$ tar -zxvf hbase-0.98.11-hadoop2-bin.tar.gz
</code></pre><p>由于解压出来的文件名可能很长，建议修改为较短文件名，例如：</p>
<pre><code>$ mv hbase-0.98.11-hadoop2 hbase
</code></pre><p><strong>（2）配置 hbase-site.xml</strong></p>
<p>在运行之前，我们需要对HBase进行相关配置。建议大家修改 ${HBase-Dir}/conf/hbase-site.xml 文件，因为即使你修改了hbase-default.xml文件，也会被hbase-site.xml中的配置所覆盖。也就是说，最终是以 hbase-site.xml 中的配置为准的。我们做如下修改：</p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;hbase.rootdir&lt;/name&gt;
        &lt;value&gt;file:///tmp/hbase-${user.name}/hbase&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p><em>注意：修改 <code>${user.name}</code>为你自己的 hadoop 用户名</em></p>
<p><strong>2. 伪分布模式  安装</strong></p>
<p>伪分布模式是一个运行在单台机器上的分布式模式。此模式下，HBase所有的守护进程将运行在同一个节点之上，而且需要依赖HDFS，因此在此之前必须保证HDFS已经成功运行。确认无误后，我们就可以开始配置HBase的参数了。</p>
<p><strong>（1）配置 hbase-site.xml 文件</strong></p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;hbase.rootdir&lt;/name&gt;
        &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
        &lt;value&gt;true&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p><strong>hbase.rootdir</strong>：该参数制定了HReion服务器的位置，即数据存放的位置。主要端口号要和Hadoop相应配置一致。<br><strong>hbase.cluster.distributed</strong>：HBase的运行模式。false是单机模式，true是分布式模式。若为false, HBase和Zookeeper会运行在同一个JVM里面。默认为false.</p>
<p><strong>（2）设置环境变量</strong></p>
<p>另外，我们需要设置一些环境变量。修改HBase下的conf目录中的hbase-env.sh文件（你的jdk路径可能不一样）：</p>
<pre><code>export JAVA_HOME=/usr/local/jdk1.7.0_67
export HBASE_MANAGES_ZK=true


export HBASE_MANAGES_ZK=true 
</code></pre><p>此配置信息，表示设置由hbase自己管理zookeeper，不需要单独的zookeeper, 本文搭建的 Hbase  用的是自带的 zookeeper，故设置为true.</p>
<p>最后修改添加PATH, 则输入：</p>
<pre><code>$ sudo vim /etc/profile
</code></pre><p>来修改 /etc/profile 文件：</p>
<pre><code># set hbase path
export PATH=$PATH:/usr/local/hadoop/hbase/bin
</code></pre><p><strong>3. 完全分布模式  安装</strong></p>
<p>由于完全分布模式需要多台机器，在这里我们就不给出演示了。</p>
<hr>
<p>####三、安装之后 - 运行和停止<strong>HBase</strong></p>
<p>正如上面我们提到的，HBase安装分为3个模式，因此HBase的运行自然也分为同样的3个模式。</p>
<p><strong>1. 单机模式 运行</strong></p>
<p><strong>（1）启动</strong></p>
<p>单机模式下不需要HDFS，因此不需要事先启动Hadoop，直接启动HBase即可。终端下输入命令：<code>./start-hbase.sh</code></p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427277679782" alt="图片描述信息"></p>
<p><em>注意：<strong>路径要正确</strong>，应为：$HBASE_HOME/bin 目录，否则会找不到 start-hbase.sh 这个文件，就会出现错误</em></p>
<p><strong>（2）查看进程</strong></p>
<p>我们可以通过 <code>jps</code> 来查看当前 HBase 的进程：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427277712961" alt="图片描述信息"></p>
<p><strong>（3）停止HBase服务</strong></p>
<p>输入 <code>./stop-hbase.sh</code></p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427277758091" alt="图片描述信息"></p>
<p><strong>2. 伪分布模式  运行</strong></p>
<p><strong>（1）启动和查看进程</strong></p>
<p>前面我们提到过，伪分布模式下，必须先确保HDFS已经启动。因此，我们先启动HDFS，输入命令： <code>./start-all.sh</code></p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276429582" alt="图片描述信息"></p>
<p>使用 <code>jps</code> 查看目前Hadoop的进程：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276464795" alt="图片描述信息"></p>
<p>HDFS成功启动之后，我们再启动HBase，这里和单机模式下启动HBase的方法一样，输入命令： <code>./start-hbase.sh</code>：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276518159" alt="图片描述信息"></p>
<p>此时再使用 <code>jps</code>查看，可以看到多了HBase的相关进程：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276558030" alt="图片描述信息"></p>
<p><strong>（2）进入HBase Shell</strong></p>
<p>通过HBase Shell用户可以方便地创建、删除以及修改表，还可以向表中添加数据、列出表中的相关相信等。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276614167" alt="图片描述信息"></p>
<p>输入 <code>help</code> 来查看其所支持的命令，可以根据自己的需要选择。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276646424" alt="图片描述信息"></p>
<p><strong>（3）停止HBase</strong></p>
<p>根据依赖关系，我们需要先关闭HBase,  <code>./stop-hbase.sh</code>：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276770316" alt="图片描述信息"></p>
<p>通过  <code>jps</code> 可以看到，HBase相关的进程没有了：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276818873" alt="图片描述信息"></p>
<p>再关闭HDFS, <code>./stop-all.sh</code>.</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427278373979" alt="图片描述信息"></p>
<p>最后，再通过 <code>jps</code> 发现HDFS的进程也没有了：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid46108labid365time1427276969421" alt="图片描述信息"></p>
<p><strong>3. 完全分布模式 运行</strong></p>
<p><em>略。</em></p>
<hr>
<p>####四、参考文档</p>
<p>&gt;  <em> 《Hadoop实战 第2版》陆嘉恒，机械工业出版社；<br>&gt;  </em>   <a href="http://blog.csdn.net/baolibin528/article/details/42939477" target="_blank" rel="external">Hadoop2.6.0 伪分布环境搭建</a><br>&gt;  *   <a href="http://blog.csdn.net/baolibin528/article/details/43174179" target="_blank" rel="external">Hadoop-2.6.0 伪分布–安装配置hbase</a></p>
<hr>
<p>####五、本次小结</p>
<p>本次实验学习和了解了HBase在不同模式下的配置和安装，以及HBase后续的启动和停止等。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HBase简介]]></title>
      <url>http://codeinterviews.com/HBase%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>##一、本节目标</p>
<p>我们本节课程将要讲述以下内容：</p>
<ul>
<li>HBase的概述及历史</li>
<li>HBase的数据模型</li>
<li>HBase的系统架构</li>
</ul>
<a id="more"></a>
<p>##二、HBase概述</p>
<p>HBase是一个开源的非关系型分布式数据库（NoSQL），它参考了谷歌的BigTable建模，实现的编程语言为 Java。它是Apache软件基金会的Hadoop项目的一部分，运行于HDFS文件系统之上，为 Hadoop 提供类似于BigTable 规模的服务，可以存储海量稀疏的数据，并具备一定的容错性、高可靠性及伸缩性。主要应用场景是实时随机读写超大规模的数据。</p>
<p>HBase在列上实现了BigTable论文提到的压缩算法、内存操作和布隆过滤器。HBase的表能够作为MapReduce任务的输入和输出，可以通过Java API来存取数据，也可以通过REST、Avro或者Thrift的API来访问。</p>
<p>HBase不能取代RDBMS，因为二者的应用场景不同。HBase为了解决海量数据的扩展性，支持简单的增加节点来实现线性扩展，从而在集群上管理海量的非结构化或半结构化的稀疏数据。HBase仅能通过主键（row key）或主键的range检索数据，支持单行事务。</p>
<p><img src="http://anything-about-doc.qiniudn.com/hbase/1.jpg" alt="Alt text"></p>
<p>上图描述Hadoop EcoSystem中的各层系统。其中,HBase位于结构化存储层，Hadoop HDFS为HBase提供了高可靠性的底层存储支持，Hadoop MapReduce为HBase提供了高性能的计算能力，Zookeeper为HBase提供了稳定服务和failover机制。</p>
<p>此外，Pig和Hive还为HBase提供了高层语言支持，使得在HBase上进行数据统计处理变的非常简单。 Sqoop则为HBase提供了方便的RDBMS数据导入功能，使得传统数据库数据向HBase中迁移变的非常方便。</p>
<p>##三、HBase历史</p>
<p>Apache HBase最初是Powerset公司为了处理自然语言搜索产生的海量数据而开展的项目。下图展示了HBase的发展历程。</p>
<p><img src="http://anything-about-doc.qiniudn.com/hbase/2.png" alt="Alt text"></p>
<h2 id="四、HBase数据模型"><a href="#四、HBase数据模型" class="headerlink" title="四、HBase数据模型"></a>四、HBase数据模型</h2><p><img src="http://anything-about-doc.qiniudn.com/hbase/3.png" alt="Alt text"></p>
<ul>
<li><strong>行健（Row Key）</strong>：表的主键，表中的记录默认按照行健升序排序</li>
<li><strong>时间戳（Timestamp）</strong>：每次数据操作对应的时间戳，可以看作是数据的版本号</li>
<li><strong>列族（Column Family）</strong>：表在水平方向有一个或者多个列族组成，一个列族中可以由任意多个列组成，列族支持动态扩展，无需预先定义列的数量以及类型，所有列均以二进制格式存储，用户需要自行进行类型转换。所有的列族成员的前缀是相同的，例如“abc:a1”和“abc:a2”两个列都属于abc这个列族。</li>
<li><strong>表和区域（Table&amp;Region）</strong>：当表随着记录数不断增加而变大后，会逐渐分裂成多份，成为区域，一个区域是对表的水平划分，不同的区域会被Master分配给相应的RegionServer进行管理</li>
<li><strong>单元格（Cell）</strong>：表存储数据的单元。由{行健，列（列族:标签），时间戳}唯一确定，其中的数据是没有类型的，以二进制的形式存储。</li>
</ul>
<p>##五、HBase架构</p>
<p><img src="http://anything-about-doc.qiniudn.com/hbase/4.jpg" alt="Alt text"></p>
<p>如上图所示，HBase架构中只有一个Master节点，称HMaster，还有多台RegionServer成为HRegionServer，每个RegionServer包含多个Region。</p>
<ol>
<li>HBase访问接口：Java，REST，Thrift等</li>
<li>Master：集群的管理服务器，为RegionServer分配Region，负责RegionServer的负载均衡，处理schema更新请求</li>
<li>RegionServer：管理HBase的数据存储，维护Region，处理IO请求。</li>
<li>Zookeeper：保证集群的高可用性、存储Region的寻址入口，并实时监控RegionServer的状态，存储HBase的Schema。</li>
</ol>
<p>可以看到，client访问hbase上数据的过程并不需要Master参与（寻址访问Zookeeper和RegionServer，数据读写访问RegionServer），Master仅仅维护Table和Region的元数据信息，负载很低。</p>
<p>##六、HBase访问接口</p>
<ol>
<li>Native Java API，最常规和高效的访问方式，适合Hadoop MapReduce Job并行批处理HBase表数据</li>
<li>HBase Shell，HBase的命令行工具，最简单的接口，适合HBase管理使用</li>
<li>Thrift Gateway，利用Thrift序列化技术，支持C++，PHP，Python等多种语言，适合其他异构系统在线访问HBase表数据</li>
<li>REST Gateway，支持REST 风格的Http API访问HBase, 解除了语言限制</li>
<li>Pig，可以使用Pig Latin流式编程语言来操作HBase中的数据，和Hive类似，本质最终也是编译成MapReduce Job来处理HBase表数据，适合做数据统计</li>
<li>Hive，当前Hive的Release版本尚没有加入对HBase的支持，但在下一个版本Hive 0.7.0中将会支持HBase，可以使用类似SQL语言来访问HBase</li>
</ol>
<p>##七、HBase存储格式</p>
<p>HBase中的所有数据文件都存储在Hadoop HDFS文件系统上，主要包括上述提出的两种文件类型：</p>
<ol>
<li>HFile， HBase中KeyValue数据的存储格式，HFile是Hadoop的二进制格式文件，实际上StoreFile就是对HFile做了轻量级包装，即StoreFile底层就是HFile</li>
<li>HLogFile，HBase中WAL（Write Ahead Log） 的存储格式，物理上是Hadoop的Sequence File</li>
</ol>
<p>##八、HBase应用场景</p>
<p>HBase的优势主要在以下几方面：</p>
<ol>
<li>海量数据存储</li>
<li>快速随机访问</li>
<li>大量写操作的应用</li>
</ol>
<p>常见的应用场景</p>
<ol>
<li>互联网搜索引擎数据存储（BigTable要解决的问题）</li>
<li>审计日志系统</li>
<li>实时系统</li>
<li>消息中心</li>
<li>内容服务系统</li>
</ol>
<p>##参考文档</p>
<ul>
<li><a href="http://www.ymc.ch/en/introduction-to-hbase" target="_blank" rel="external">http://www.ymc.ch/en/introduction-to-hbase</a></li>
<li><a href="http://bigdatariding.blogspot.jp/2013/12/hbase-architecture.html" target="_blank" rel="external">http://bigdatariding.blogspot.jp/2013/12/hbase-architecture.html</a></li>
<li><a href="http://baike.baidu.com/view/1993870.htm" target="_blank" rel="external">http://baike.baidu.com/view/1993870.htm</a></li>
<li><a href="http://hbase.apache.org/" target="_blank" rel="external">http://hbase.apache.org/</a></li>
<li><a href="http://www.alidata.org/archives/1509" target="_blank" rel="external">http://www.alidata.org/archives/1509</a></li>
<li><a href="http://zh.wikipedia.org/zh/Apache_HBase" target="_blank" rel="external">http://zh.wikipedia.org/zh/Apache_HBase</a></li>
<li><a href="http://abloz.com/hbase/book.html" target="_blank" rel="external">http://abloz.com/hbase/book.html</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Happy Number]]></title>
      <url>http://codeinterviews.com/Happy-Number/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Happy Number</p>
<blockquote>
<p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p><strong>Example</strong>: 19 is a happy number</p>
<pre><code>1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
</code></pre><p>####Credits:<br>Special thanks to @mithmatt and @ts for adding this problem and creating all test cases.<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题是判断一个数是不是”Happy Number”，即对其每一位数进行平方和求解，且不断循环这个过程，如果结果为1，则满足条件，如果出现循环的情况，则不满足条件。在这里，采用<code>HashSet</code>对过去求解的值进行存储，然后通过判断一个数是不是在其中，来得到是否出现了循环的情况。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">       		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       	<span class="comment">//使用一个hashset来存储过去已求解的值，来判断是否出现循环</span></span><br><span class="line">       	HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">       	<span class="keyword">while</span>(n!=<span class="number">1</span>)</span><br><span class="line">       	&#123;</span><br><span class="line">       		n=computerSquare(n);</span><br><span class="line">       		<span class="keyword">if</span>(set.contains(n))</span><br><span class="line">       			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       		<span class="keyword">else</span></span><br><span class="line">       			set.add(n);</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求一个数的每一位的平方和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computerSquare</span><span class="params">(<span class="keyword">int</span> number)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(number!=<span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">int</span> tmp=number%<span class="number">10</span>;</span><br><span class="line">    		number=number/<span class="number">10</span>;</span><br><span class="line">    		res+=tmp*tmp;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-House Robber II]]></title>
      <url>http://codeinterviews.com/House-Robber-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####House Robber II</p>
<blockquote>
<p>Note: This is an extension of House Robber.</p>
<p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are <strong>arranged in a circle</strong>. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p>####Credits:<br>Special thanks to @Freezen for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是在<a href="http://pisxw.com/algorithm/House-Robber.html" target="_blank" rel="external">House Robber</a>上的扩展，将上题中的直线型的街道，变成环形的街道，但是我们可以用线性街道的动态规划的方法求解。</p>
<p>对于环形，主要考虑两种情况：</p>
<ul>
<li>第一个房子被偷：那么此时第二个房子和最后一个房子都不能被偷了，即我们可以从第三个房子到倒数最后一个房子之间用线性的动态规划求解。</li>
<li>第一个房子没有被偷：那么此时我们可以从第二个房子到最后一个房子之间用线性的动态规划求解。</li>
</ul>
<p>具体动态方程为：</p>
<pre><code>设定：dp[i]:表示抢到第i个房间的时候没有惊动警察的最大钱数
第一个房子被偷：
    dp1[0]=nums[0];
    dp1[1]=nums[0];
    dp1[i]=Max(dp1[i-2]+nums[i],dp1[i-1])   2&lt;=i&lt;=nums.length-2
    dp1[nums.length-1]=dp1[nums.length-2]

第一个房子没有被偷：
    dp2[0]=0;
    dp2[1]=nums[1];
    dp2[i]=Max(dp2[i-2]+nums[i],dp2[i-1])   2&lt;=i&lt;=nums.length-1

最后的结果为 Max(dp1[nums.length-1],dp2[nums.length-1])
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//第一个房子没有被偷，则可以从第二个房子偷到最后一个房子，在这之间用线性的动态规划求解</span></span><br><span class="line">        <span class="comment">//dp[i]表示到第i个房子，小偷没用惊动警察时获取的最大钱数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp1=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp1[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)</span><br><span class="line">        	dp1[i]=Math.max(dp1[i-<span class="number">2</span>]+nums[i],dp1[i-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个房子被偷，则第二个和最后一个房子不能被偷，则从第三个房子到倒数最后一个房子之间用线性动态规划求解</span></span><br><span class="line">        <span class="keyword">int</span>[] dp2=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp2[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp2[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length-<span class="number">1</span>;i++)</span><br><span class="line">        	dp2[i]=Math.max(dp2[i-<span class="number">2</span>]+nums[i],dp2[i-<span class="number">1</span>]);</span><br><span class="line">        dp2[nums.length-<span class="number">1</span>]=dp2[nums.length-<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp1[nums.length-<span class="number">1</span>],dp2[nums.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-House Robber]]></title>
      <url>http://codeinterviews.com/House-Robber/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####House Robber</p>
<blockquote>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p>####Credits:<br>Special thanks to @ifanchu for adding this problem and creating all test cases. Also thanks to @ts for adding additional test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题的本质相当于在一列数组中取出一个或多个不相邻数，使其和最大。<br>这是一道动态规划问题。<br>我们维护一个一位数组dp，其中dp[i]表示到i位置时不相邻数能形成的最大和。<br>状态转移方程：</p>
<pre><code>dp[0] = num[0] （当i=0时）
dp[1] = max(num[0], num[1]) （当i=1时）
dp[i] = max(num[i] + dp[i - 2], dp[i - 1])   （当i !=0 and i != 1时）(num[i]抢还是不抢两种情况)
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义dp[i]表示抢到第i个房间的时候没有惊动警察的最大钱数</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num.length==<span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[num.length];</span><br><span class="line">        dp[<span class="number">0</span>]=num[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=Math.max(num[<span class="number">0</span>],num[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;num.length;i++)</span><br><span class="line">        	dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+num[i]);</span><br><span class="line">        <span class="keyword">return</span> dp[num.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Implement strStr()]]></title>
      <url>http://codeinterviews.com/Implement-strStr()/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Implement strStr() </p>
<blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<p>####Update (2014-11-02):</p>
<blockquote>
<p>The signature of the function had been updated to return the index instead of the pointer. If you still see your function signature returns a char * or String, please click the reload button  to reset your code definition.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这是算法中比较经典的问题，判断一个字符串是否是另一个字符串的子串。这个题目最经典的算法应该是KMP算法，不了解的同学可以看<a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="external">从头到尾彻底理解KMP</a>,里面讲的很清楚。KMP算法是最优的线性算法，复杂度已经达到这个问题的下限。但是KMP算法比较复杂，很难在面试的短时间里面完整正确的实现</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//字符串中查找字串，采用KMP算法	</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] hay=haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] need=needle.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(hay.length==<span class="number">0</span>&amp;&amp;need.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(hay.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(need.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(need.length&gt;hay.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求取needle的next数组</span></span><br><span class="line">        <span class="keyword">int</span>[] next=<span class="keyword">new</span> <span class="keyword">int</span>[need.length];</span><br><span class="line">        next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;need.length-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(k==-<span class="number">1</span>||need[j]==need[k])</span><br><span class="line">        	&#123;</span><br><span class="line">				j++;</span><br><span class="line">				k++;</span><br><span class="line">				next[j]=k;        		</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		k=next[k];</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;hay.length)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(hay[i]==need[j])</span><br><span class="line">        	&#123;</span><br><span class="line">        		i++;</span><br><span class="line">        		j++;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		j=next[j];</span><br><span class="line">        		<span class="keyword">if</span>(j==-<span class="number">1</span>)</span><br><span class="line">    		    &#123;</span><br><span class="line">		            i++;</span><br><span class="line">		            j=<span class="number">0</span>;</span><br><span class="line">    		    &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(j==need.length)</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==need.length)</span><br><span class="line">        	<span class="keyword">return</span> i-need.length;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hive 接口介绍（Web UI/JDBC）]]></title>
      <url>http://codeinterviews.com/Hive%20%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>主要对Hive 接口介绍（Web UI/JDBC）。<br><a id="more"></a></p>
<h2 id="二、Hive-网络接口（Web-UI）"><a href="#二、Hive-网络接口（Web-UI）" class="headerlink" title="二、Hive 网络接口（Web UI）"></a>二、Hive 网络接口（Web UI）</h2><p><strong>（1）Web UI 简介</strong></p>
<p>Hive Web UI 提供了图像化的操作界面，通过 Hive Web UI 接口可以更方便、更直观地操作，特别是对刚刚接触 Hive 的用户来说。Hive Web UI 具有一下特性：</p>
<blockquote>
<p><strong>分离查询的执行</strong></p>
<p>在命令行（CLI）下，要执行多个查询就得打开多个终端，而通过Web UI，就可以同时执行多个查询，还可以在网络服务器上管理会话 Session。</p>
<p><strong>不依赖本地 Hive</strong></p>
<p>用户需要安装本地 Hive，就可以通过网络浏览器访问 Hive 并进行相关操作。如果想通过 Web 与 Hadoop 以及 Hive 交互，那么需要访问多个端口。</p>
</blockquote>
<p><strong>（2）配置 hive-site.xml</strong> </p>
<p>修改 <code>$HIVE_HOME/conf</code> 目录下的 hive-site.xml 文件。</p>
<p>我们可以看一下默认配置是什么：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1427449144790" alt="图片描述信息"></p>
<p>我们只需要修改 <code>hive.hwi.war.file</code>，你应该先在 <code>$HIVE_HOME/lib</code> 目录下检查一下 hwi 的版本：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1427449167021" alt="图片描述信息"></p>
<p>结果令人吃惊的是，居然没有那个 <code>war</code> 文件！<br>只有一个同名的 jar 包，没有 war 文件。解决办法是自行下载对应 Hive 的源码包再打包成 war 文件。</p>
<p>下载 Hive 源码（注意这里是 src 包，不是 bin 包。上次我们使用的是 1.1.0 版本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://labfile.oss.aliyuncs.com/apache-hive-1.1.0-src.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf apache-hive-1.1.0.src.tar.gz</span><br></pre></td></tr></table></figure>
<p>再进入 hwi 目录，打包 war 文件（注意命令末尾有一个点 <code>.</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd apache-hive-1.1.0-src/hwi</span><br><span class="line">$ jar cvfM0 hive-hwi-1.1.0.war -C web/ .</span><br></pre></td></tr></table></figure>
<p>打包完成后，有了我们需要的 war 文件，再复制到 $HIVE_HOME/lib 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp hive-hwi-1.1.0.war /usr/local/hive-1.1.0/lib</span><br></pre></td></tr></table></figure>
<p>另外我们还需要拷贝一个 Java 的 tools.jar 到 $HIVE_HOME/lib 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp /usr/local/jdk1.7.0_67/lib/tools.jar /usr/local/hive-1.1.0/lib</span><br></pre></td></tr></table></figure>
<p>否则会出现类似于下面的错误（因为 JAVA_HOME 指到 <code>$JAVA_HOME/jre</code> 下了，而其 lib下的 tools.jar 跟 <code>$JAVA_HOME/lib/tools.jar</code> 不一样，编译的时候需要用到后者）：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1427449208179" alt="图片描述信息"></p>
<p>最后，我们将 hive-site.xml 文件修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hive.hwi.war.file&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/lib/hive-hwi-1.1.0.war&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;This sets the path to the HWI war file, relative to $&#123;HIVE_HOME&#125;. &lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<p><strong>（3）启动 hwi</strong></p>
<p>在 $HIVE_HOME/bin 目录下，启动 hwi（由于我们之前已经修改了 Derby 为 MySQL 数据库，所以在启动 hwi 之前，<strong>请确保 MySQL 和 Hadoop 已经成功启动</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hive --service hwi</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428372977844" alt="图片描述信息"></p>
<p>现在，我们可以在浏览器中打开网络接口的地址：<code>localhost:9999/hwi</code>, 启动成功：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1427449406991" alt="图片描述信息"></p>
<p><strong>（4）Web UI 操作实例</strong></p>
<p><strong>数据库及表信息查询</strong></p>
<p>在查询之前，我们先新建一个 person表 以方便后续的查询操作。启动 Hive 后，输入如下命令（这个 table 只是一个示例，你可以根据需要自己创建其他的）：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1427692120414" alt="图片描述信息"></p>
<p>新建一个 txt 文件（路径自定义，比如我是 /home/hadoop/hive/person.txt），写一些示例数据，数据之间是以 <code>\t</code> 划分的；实验中已经写好，直接导入即可：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428371380477" alt="图片描述信息"></p>
<p>再把数据导入到 person表 中：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428371406358" alt="图片描述信息"></p>
<p>单击 <code>Browse Schema</code> 可以查看当前 Hive 中的数据库，显示的是当前可以是使用的数据库信息，只包含一个默认数据库（default）：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1427450004623" alt="图片描述信息"></p>
<p>再单击 default 就可以看到 default 数据库中包含的所有表的信息了（这里有我们刚刚新建的 table : person表）：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1427685745623" alt="图片描述信息"></p>
<p>点击 person 表即可看到具体信息。</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428370148182" alt="图片描述信息"></p>
<p><strong>Hive Session 查询</strong></p>
<p>在进行查询之前我们需要新建一个 Session（注意每次重启hwi后，之前的 Session 将会失效）。点击 Create Session 来新建：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428370791203" alt="图片描述信息"></p>
<p>填入以下信息，打框的必填：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428370820294" alt="图片描述信息"></p>
<blockquote>
<p>其中：<br><strong>Result File</strong> 为最后的查询结果文件；</p>
<p><strong>Query</strong> 为你的查询语句；</p>
<p><strong>Start Query</strong> 设为 YES，表示开始查询；</p>
</blockquote>
<p>点击 Submit 提交后，即可看到 View File：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428370944355" alt="图片描述信息"></p>
<p>点击 View File 即可看到最后的查询结果：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428370958166" alt="图片描述信息"></p>
<p>通过以上的学习，我们可以了解到 Web UI 虽然提供了可视化的查询操作，但最大的缺点就是用户不能实时了解查询的状态，交互能力较差。</p>
<h2 id="三、JDBC"><a href="#三、JDBC" class="headerlink" title="三、JDBC"></a>三、<strong>JDBC</strong></h2><p>在 Eclipse 中新建一个 Java 工程，例如 HiveJdbc. 然后添加所需要的 jar 包，右击工程，依次选择 Properties -&gt; Java Build Path -&gt; Libraries -&gt; Add External Jars 来添加。所需 jar 包如下（如不清楚你可以直接添加所有的 jar 包；遇到没有权限添加的，请拷贝 jar 包到其他有权限的目录再添加，实验中已经拷贝到 <code>/home/hadoop/hive</code>）：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428049346613" alt="图片描述信息"></p>
<p>新建包和类，添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveJdbc</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverName = </span><br><span class="line">                   <span class="string">"org.apache.hive.jdbc.HiveDriver"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span><br><span class="line">                            <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Connection con = DriverManager.getConnection(</span><br><span class="line"><span class="string">"jdbc:hive2://localhost:10000/default"</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">        Statement stmt = con.createStatement();</span><br><span class="line">        String tableName = <span class="string">"hive_jdbc"</span>;</span><br><span class="line">        stmt.execute(<span class="string">"drop table if exists "</span> + tableName);</span><br><span class="line">        stmt.execute(<span class="string">"create table "</span> + tableName + </span><br><span class="line">                                     <span class="string">" (key int, value string)"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Create table success!"</span>);</span><br><span class="line">        <span class="comment">// show tables</span></span><br><span class="line">        String sql = <span class="string">"show tables &amp;#39;"</span> + tableName + <span class="string">"&amp;#39;"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Running: "</span> + sql);</span><br><span class="line">        ResultSet res = stmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">if</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(res.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// describe table</span></span><br><span class="line">        sql = <span class="string">"describe "</span> + tableName;</span><br><span class="line">        System.out.println(<span class="string">"Running: "</span> + sql);</span><br><span class="line">        res = stmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(res.getString(<span class="number">1</span>) + <span class="string">"\t"</span> + res.getString(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        sql = <span class="string">"select * from "</span> + tableName;</span><br><span class="line">        res = stmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(String.valueOf(res.getInt(<span class="number">1</span>)) + <span class="string">"\t"</span></span><br><span class="line">                                               + res.getString(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        sql = <span class="string">"select count(1) from "</span> + tableName;</span><br><span class="line">        System.out.println(<span class="string">"Running: "</span> + sql);</span><br><span class="line">        res = stmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(res.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上述代码可以看出，在进行查询之前需要做的工作有：</p>
<ul>
<li><p>通过 Class.ForName(“org.apache.hive.jdbc.HiveDriver”); 来注册 Hive 驱动；</p>
</li>
<li><p>通过 Connection con = DriverManager.getConnection(<br>“jdbc:hive2://localhost:10000/default”, “”, “”); 来与 Hive 数据库建立连接；</p>
</li>
</ul>
</blockquote>
<p>运行之前需要启动 hiveserver，但目前 Hive 摒弃了 hiveserver 转而改用了 hiveserver2，反映在代码中有两点不同。一是，driverName由 <code>org.apache.hadoop.hive.jdbc.HiveDriver</code> 改成了 <code>org.apache.hive.jdbc.HiveDriver</code> ；二是，Connection 由 <code>jdbc:hive://localhost:10000/default</code> 改成了 <code>jdbc:hive2://localhost:10000/default</code>。</p>
<p>因此，在运行程序前启动 hiveserver 也改成了启动 hiveserver2，在 $HIVE_HOME/bin 目录下来启动。</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428369497384" alt="图片描述信息"></p>
<p>最后程序运行结果如下：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid775time1428334878077" alt="图片描述信息"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Implement Trie (Prefix Tree)]]></title>
      <url>http://codeinterviews.com/Implement-Trie-(Prefix%20Tree)/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Implement Trie (Prefix Tree)</p>
<blockquote>
<p>Implement a trie with insert, search, and startsWith methods.</p>
<p>####Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是实现trie树。<br>Trie，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。<br>它有3个基本性质：   </p>
<ul>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。     </li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。     </li>
<li>每个节点的所有子节点包含的字符都不相同。 </li>
</ul>
<p>此外，每个节点存在一个判断其是否是一个单词结尾的标记，用来表明该trie树中包含该单词。因此我们首先需要定义节点的数据结构。<br>节点的属性主要包含以下几点：</p>
<ul>
<li>节点字符内容</li>
<li>节点是否为一个单词结束的标记</li>
<li>该节点的所有的孩子节点</li>
</ul>
<p>trie树的定义可以参考<a href="http://blog.csdn.net/beiyetengqing/article/details/7856113" target="_blank" rel="external">该网址</a>。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize your data structure here.</span></span><br><span class="line">     <span class="keyword">char</span> content; <span class="comment">//节点内容</span></span><br><span class="line">     <span class="keyword">boolean</span> isEnd;<span class="comment">//是否为一个单词的结尾</span></span><br><span class="line">     LinkedList&lt;TrieNode&gt; childNode;<span class="comment">//该节点所有的孩子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此为根结点的构造函数，根结点不包含任何内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content=<span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">this</span>.isEnd=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.childNode=<span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此为包含内容节点的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> content)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content=content;</span><br><span class="line">        <span class="keyword">this</span>.isEnd=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.childNode=<span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在该节点的孩子节点查找某一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">subNode</span><span class="params">(<span class="keyword">char</span> content)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(childNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(TrieNode node:childNode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(node.content==content)</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(search(word)==<span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">        TrieNode current=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需要在current节点的孩子节点中查找是否存在该字符的节点。如果不存在则需要插入，否则直接往下遍历。</span></span><br><span class="line">            TrieNode node=current.subNode(word.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">                current.childNode.add(<span class="keyword">new</span> TrieNode(word.charAt(i)));</span><br><span class="line">                node=current.subNode(word.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            current=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后需要定义单词结束标记，表明该trie树包含该单词</span></span><br><span class="line">        current.isEnd=<span class="keyword">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TrieNode current=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TrieNode node=current.subNode(word.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            current=node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//虽然有这个单词序列，但是需要判断其结束标记是否为true，以便得知其在该trie中。</span></span><br><span class="line">        <span class="keyword">if</span>(current.isEnd==<span class="keyword">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode current=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prefix.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TrieNode node=current.subNode(prefix.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            current=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Trie trie = new Trie();</span></span><br><span class="line"><span class="comment">// trie.insert("somestring");</span></span><br><span class="line"><span class="comment">// trie.search("key");</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Insert Interval]]></title>
      <url>http://codeinterviews.com/Insert-Interval/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Insert Interval</p>
<blockquote>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p>####Example 1:<br>Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.</p>
<p>####Example 2:<br>Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.</p>
<p>This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Merge-Intervals.html" target="_blank" rel="external">Merge Intervals</a>类似，只不过合并是该题的一个子过程，这里首先需要考虑新时间段插入的位置，然后对插入之后，判断其插入是否会产生重叠。</p>
<p>这里的重叠问题有两个情况：</p>
<pre><code>1. 插入位置前面一个元素与插入的元素产生重叠，这时合并后仍需考虑插入位置后面的元素重叠问题
2. 插入位置前面一个元素与插入的元素不会产生重叠，这时直接插入，但是需考虑插入位置后面的元素重叠问题
</code></pre><p>这里需要注意两个细节处理，插入位置为<strong>初始位置</strong>和<strong>最后一个位置</strong>.</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * public class Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() &#123; start = 0; end = 0; &#125;</span><br><span class="line"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">insert</span><span class="params">(ArrayList&lt;Interval&gt; intervals, Interval newInterval)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Interval&gt; res=<span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals==<span class="keyword">null</span> || intervals.size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	res.add(newInterval);</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;intervals.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(intervals.get(i).start&lt;=newInterval.start)</span><br><span class="line">        	&#123;</span><br><span class="line">        		res.add(intervals.get(i));</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		<span class="comment">//找到newInterval的插入位置，然后判断其前面一个元素是否有重叠</span></span><br><span class="line">        		<span class="keyword">if</span>(res.size()!=<span class="number">0</span> &amp;&amp; newInterval.start&lt;=res.get(res.size()-<span class="number">1</span>).end)</span><br><span class="line">	        	&#123;</span><br><span class="line">	        		<span class="keyword">int</span> start=res.get(res.size()-<span class="number">1</span>).start;</span><br><span class="line">	        		<span class="keyword">int</span> end=Math.max(res.get(res.size()-<span class="number">1</span>).end,newInterval.end);</span><br><span class="line">	        		res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">	        		res.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">	        	&#125;<span class="keyword">else</span></span><br><span class="line">	        	&#123;</span><br><span class="line">	        		res.add(newInterval);</span><br><span class="line">	        	&#125;</span><br><span class="line">	        	<span class="comment">//插入之后，对插入位置后面的元素判断是否会产生重叠</span></span><br><span class="line">	        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;intervals.size();j++)</span><br><span class="line">		        &#123;</span><br><span class="line">		        	<span class="keyword">if</span>(intervals.get(j).start&lt;=res.get(res.size()-<span class="number">1</span>).end)</span><br><span class="line">		        	&#123;</span><br><span class="line">		        		<span class="keyword">int</span> start=res.get(res.size()-<span class="number">1</span>).start;</span><br><span class="line">		        		<span class="keyword">int</span> end=Math.max(res.get(res.size()-<span class="number">1</span>).end,intervals.get(j).end);</span><br><span class="line">		        		res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">		        		res.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">		        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		        		res.add(intervals.get(j));</span><br><span class="line">		        	&#125;</span><br><span class="line">		        &#125;</span><br><span class="line">		        <span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当插入位置是在最后时，只需判断插入位置前一个元素是否与newInterval产生重叠</span></span><br><span class="line">        <span class="keyword">if</span>(i==intervals.size())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(newInterval.start&lt;=res.get(res.size()-<span class="number">1</span>).end)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">int</span> start=res.get(res.size()-<span class="number">1</span>).start;</span><br><span class="line">        		<span class="keyword">int</span> end=Math.max(res.get(res.size()-<span class="number">1</span>).end,newInterval.end);</span><br><span class="line">        		res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">        		res.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">        	&#125;<span class="keyword">else</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		res.add(newInterval);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Insertion Sort List]]></title>
      <url>http://codeinterviews.com/Insertion-Sort-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Insertion Sort List </p>
<blockquote>
<p>Sort a linked list using insertion sort.</p>
<a id="more"></a>
</blockquote>
<p>##解题思路<br>该题是采用插入排序对链表进行排序，主要是需要了解插入排序的原理，以及链表的插入操作。这里通过重新设定一个空的头结点<code>newhead</code>来统一节点在头结点处插入和中间插入的步骤。可以简化程序的设计。</p>
<p>需要注意的是，其中链表之间的链接操作和跳转需要比较小心的处理。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> head;</span><br><span class="line">        ListNode newhead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        newhead.next=head;</span><br><span class="line">        ListNode prep=newhead; <span class="comment">//p的前向节点</span></span><br><span class="line">        ListNode p=head; <span class="comment">//定义遍历节点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	ListNode pnext=p.next;</span><br><span class="line">        	ListNode a=newhead;</span><br><span class="line">        	ListNode b=a.next;</span><br><span class="line">        	<span class="keyword">while</span>(b!=p)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(b.val&lt;=p.val)</span><br><span class="line">        		&#123;</span><br><span class="line">        			a=a.next;</span><br><span class="line">        			b=b.next;</span><br><span class="line">        		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        			a.next=p;</span><br><span class="line">        			p.next=b;</span><br><span class="line">        			prep.next=pnext;</span><br><span class="line">        			p=pnext;</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line"></span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(b==p)</span><br><span class="line">        	&#123;</span><br><span class="line">        		prep=p;</span><br><span class="line">        		p=pnext;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Interleaving String]]></title>
      <url>http://codeinterviews.com/Interleaving-String/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Interleaving String</p>
<blockquote>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 = <code>&quot;aabcc&quot;</code>,<br>s2 = <code>&quot;dbbca&quot;</code>,    </p>
<p>When s3 = <code>&quot;aadbbcbcac&quot;</code>, return true.<br>When s3 = <code>&quot;aadbbbaccc&quot;</code>, return false.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这是一道关于字符串操作的题目，要求是判断一个字符串能不能由两个字符串按照他们自己的顺序，每次挑取两个串中的一个字符来构造出来。</p>
<p>像这种判断能否按照某种规则来完成某个量的题目，很容易会想到用<strong>动态规划</strong>来实现。  </p>
<p>先说说维护量，res[i][j]表示用s1的前i个字符和s2的前j个字符能不能按照规则表示出s3的前i+j个字符，如此最后结果就是res[s1.length()][s2.length()]，判断是否为真即可。接下来就是递推式了，假设知道res[i][j]之前的所有历史信息，我们怎么得到res[i][j]。可以看出，其实只有两种方式来递推，一种是选取s1的字符作为s3新加进来的字符，另一种是选s2的字符作为新进字符。而要看看能不能选取，就是判断s1(s2)的第i(j)个字符是否与s3的i+j个字符相等。如果可以选取并且对应的res[i-1]<a href="res[i][j-1]">j</a>也为真，就说明s3的i+j个字符可以被表示。这两种情况只要有一种成立，就说明res[i][j]为真，是一个或的关系。所以递推式可以表示成</p>
<pre><code>res[i][j] = res[i-1][j]&amp;&amp;s1.charAt(i-1)==s3.charAt(i+j-1) || res[i][j-1]&amp;&amp;s2.charAt(j-1)==s3.charAt(i+j-1)
</code></pre><p>时间上因为是一个二维动态规划，所以复杂度是O(m*n)，m和n分别是s1和s2的长度</p>
<p>把动态规划中的二维数组如何降维成一维数组：<br>这个降下来并不是通过循环的哈~ 就是说本来是二维的历史信息，但是如果历史信息只需要用到上一行的信息，那么说明前面的信息就不需要了，只留一行即可，然后在更新当前一行覆盖上一行的信息，所以就只需要一维数组了</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> l2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> l3 = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(l1 != l3 -l2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> [][] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[l1 + <span class="number">1</span>][l2 + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= l3; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k &amp;&amp; i &lt;= l1; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = k - i;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; l2)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                res[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(k-<span class="number">1</span>) &amp;&amp; res[i-<span class="number">1</span>][j])</span><br><span class="line">                    res[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(k-<span class="number">1</span>) &amp;&amp; res[i][j-<span class="number">1</span>])</span><br><span class="line">                    res[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Intersection of Two Linked Lists]]></title>
      <url>http://codeinterviews.com/Intersection-of-Two-Linked-Lists/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Intersection of Two Linked Lists</p>
<blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<pre><code>A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
</code></pre><p>begin to intersect at node c1.</p>
<p>####Notes:</p>
<ul>
<li>If the two linked lists have no intersection at all, return null.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<p>####Credits:<br>Special thanks to @stellari for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是找到两个链表的共同的第一个节点。方法比较简单，首先对两个链表分别遍历一次，分别得到两个链表的长度为<code>m</code>,<code>n</code>,且<code>m&lt;n</code>.然后定义两个指针<code>p</code>,<code>q</code>.<code>p</code>指向长度为<code>m</code>的链表，<code>q</code>指向长度为<code>n</code>的链表，然后首先让<code>q</code>先向前遍历<code>n-m</code>个位置，然后<code>p</code>和<code>q</code>同时一起前进，当<code>q==p</code>时，此时的节点即为两个链表第一个公共节点。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="keyword">null</span> || headB==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取两个链表的长度</span></span><br><span class="line">        ListNode p=headA;</span><br><span class="line">        <span class="keyword">int</span> headAlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> headBlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	headAlen++;</span><br><span class="line">        	p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=headB;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	headBlen++;</span><br><span class="line">        	p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode longP;</span><br><span class="line">        ListNode shortP;</span><br><span class="line">        <span class="keyword">if</span>(headAlen&lt;headBlen)</span><br><span class="line">        &#123;</span><br><span class="line">        	longP=headB;</span><br><span class="line">        	shortP=headA;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        	longP=headA;</span><br><span class="line">        	shortP=headB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//longP向前历|headAlen-headBlen|</span></span><br><span class="line">        <span class="keyword">int</span> m=Math.abs(headAlen-headBlen);</span><br><span class="line">        <span class="keyword">while</span>(m!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	longP=longP.next;</span><br><span class="line">        	m--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(longP!=shortP)</span><br><span class="line">        &#123;</span><br><span class="line">        	longP=longP.next;</span><br><span class="line">        	shortP=shortP.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Isomorphic Strings]]></title>
      <url>http://codeinterviews.com/Isomorphic-Strings/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Isomorphic Strings</p>
<blockquote>
<p>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p>For example,<br>Given <code>&quot;egg&quot;</code>, <code>&quot;add&quot;</code>, return true.</p>
<p>Given <code>&quot;foo&quot;</code>, <code>&quot;bar&quot;</code>, return false.</p>
<p>Given <code>&quot;paper&quot;</code>, <code>&quot;title&quot;</code>, return true.</p>
<p>####Note:<br>You may assume both s and t have the same length.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判断两个字符串是否是同构的，即两个字符串中的字符是不是存在对应关系。因此我们对每个字符串都设定一个hashmap，在其中存储对应位置两个字符的对应关系，然后我们可以通过判断这种对应关系来解决这个问题。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//定义两个map分别存储其中元素与另一个字符串元素的对应关系</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map_s=<span class="keyword">new</span> HashMap&lt;Character,Character&gt;();</span><br><span class="line">        HashMap&lt;Character,Character&gt; map_t=<span class="keyword">new</span> HashMap&lt;Character,Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">char</span> char_s=s.charAt(i);</span><br><span class="line">        	<span class="keyword">char</span> char_t=t.charAt(i);</span><br><span class="line">        	<span class="comment">//如果该字符没有出现过</span></span><br><span class="line">        	<span class="keyword">if</span>(map_s.get(char_s)==<span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(map_t.get(char_t)!=<span class="keyword">null</span>)</span><br><span class="line">        			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        		<span class="keyword">else</span>&#123;</span><br><span class="line">        			<span class="comment">//将该两个字符的对应关系进行存储</span></span><br><span class="line">        			map_s.put(char_s,char_t);</span><br><span class="line">        			map_t.put(char_t,char_s);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">else</span>&#123;</span><br><span class="line">        		<span class="keyword">if</span>(map_t.get(char_t)==<span class="keyword">null</span>)</span><br><span class="line">        			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        		<span class="keyword">else</span>&#123;</span><br><span class="line">        			<span class="comment">//如果两个字符都出现过，则需要判断两个字符的对应关系是否是正确的，如果不相互对应，则返回false</span></span><br><span class="line">        			<span class="keyword">if</span>(!(map_s.get(char_s)==char_t &amp;&amp; map_t.get(char_t)==char_s))</span><br><span class="line">        				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Jump Game II]]></title>
      <url>http://codeinterviews.com/Jump-Game-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Jump Game II</p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = <code>[2,3,1,1,4]</code>k</p>
<p>The minimum number of jumps to reach the last index is <code>2</code>. (Jump <code>1</code> step from index 0 to 1, then <code>3</code> steps to the last index.)</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题思想主要是，扫描数组，以确定当前最远能覆盖的节点，放入maxreach。然后继续扫描，直到当前的路程超过了上一次算出的覆盖范围reach，那么更新覆盖范围，同时更新条数，因为我们是经过了多一跳才能继续前进的。</p>
<p>形象地说，这个是在争取每跳最远的greedy.</p>
<p>具体例子可以参考以下<a href="http://blog.csdn.net/lsdtc1225/article/details/39648757" target="_blank" rel="external">求解博客</a>.</p>
<p>常规的DP求解为：</p>
<pre><code>定义F(i):到第i个元素的最小跳数
则F(i)=min(F(j))+1,j=0,1,....i-1,且A[j]+j&gt;=i
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> reach=<span class="number">0</span>;   <span class="comment">//已覆盖的位置</span></span><br><span class="line">        <span class="keyword">int</span> maxreach=<span class="number">0</span>;  <span class="comment">//最大能跳到的位置</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(i&gt;reach)</span><br><span class="line">        	&#123;</span><br><span class="line">        		reach=maxreach;</span><br><span class="line">        		step++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	maxreach=Math.max(maxreach,A[i]+i);	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法（常规DP）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">       		f[i]=Integer.MAX_VALUE;</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)</span><br><span class="line">       		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">       			<span class="keyword">if</span>((A[j]+j)&gt;=i)</span><br><span class="line">       				f[i]=Math.min(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">       	<span class="keyword">return</span> f[A.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Jump Game]]></title>
      <url>http://codeinterviews.com/Jump-Game/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Jump Game</p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = <code>[2,3,1,1,4]</code>, return <code>true</code>.</p>
<p>A = <code>[3,2,1,0,4]</code>, return <code>false</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题采用动态规划的思想，定义如下：</p>
<pre><code>定义f(i):是否可以到达第i个节点
f(i)=true,只需满足0~i-1个元素中，存在一个元素j,是的f(j)=true且A[j]+j&gt;=i
</code></pre><p>题<a href="http://pisxw.com/algorithm/Jump-Game-II.html" target="_blank" rel="external">Jump Game II</a>是其提高版，同样可以采用动态规划求解。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> ||A.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] f=<span class="keyword">new</span> <span class="keyword">boolean</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">        	f[i]=<span class="keyword">false</span>;</span><br><span class="line">        f[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        		<span class="keyword">if</span>((A[j]+j)&gt;=i &amp;&amp; f[j]==<span class="keyword">true</span>)</span><br><span class="line">        		&#123;</span><br><span class="line">        			f[i]=<span class="keyword">true</span>;</span><br><span class="line">        			<span class="keyword">break</span>; <span class="comment">//因为已经判定f[i]为true了，所以后面的不需要进行判定了</span></span><br><span class="line">        		&#125;</span><br><span class="line">        <span class="keyword">return</span> f[A.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Kth Largest Element in an Array]]></title>
      <url>http://codeinterviews.com/Kth-Largest-Element-in-an-Array/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Kth Largest Element in an Array</p>
<blockquote>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given <code>[3,2,1,5,6,4]</code> and k = 2, return 5.</p>
<p>####Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>####Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题的思路在每个算法书里基本上都会有，就是找出一个无序数组中的第k大的元素。</p>
<p>首先最容易想到的就是对这个数组进行排序，然后直接得到结果，但是时间复杂度为O(nlogn)。但是由于我们关心的是第K个，所以没必要对整个数组进行排序，此时我们就会想到快速排序中的partition功能，将一个数组进行分割，得到两个部分，中间元素为x,前一部分元素都小于x,后一部分元素都大于x。根据每一部分的长度，就可以看出第K个元素在哪一部分中。这样一个partition下去，就能得到结果，时间复杂度为O(n)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//可以利用快速排序中的partition来进行求解一个未排序数组中的第K个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findK(nums,nums.length-k,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findK</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(i&gt;=j) <span class="keyword">return</span> nums[i];</span><br><span class="line">    	<span class="keyword">int</span> m=partition(nums,i,j);</span><br><span class="line">    	<span class="keyword">if</span>(m==k) <span class="keyword">return</span> nums[m];</span><br><span class="line">    	<span class="keyword">if</span>(m&lt;k)</span><br><span class="line">    		<span class="keyword">return</span> findK(nums,k,m+<span class="number">1</span>,j);</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		<span class="keyword">return</span> findK(nums,k,i,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序中的partition方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> x=nums[i];</span><br><span class="line">    	<span class="keyword">int</span> m=i;</span><br><span class="line">    	<span class="keyword">int</span> n=i+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(n&lt;=j)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(nums[n]&lt;x)</span><br><span class="line">    		&#123;</span><br><span class="line">    			m++;</span><br><span class="line">    			<span class="keyword">int</span> tmp=nums[m];</span><br><span class="line">    			nums[m]=nums[n];</span><br><span class="line">    			nums[n]=tmp;</span><br><span class="line">    		&#125;</span><br><span class="line">    		n++;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//将x与nums[m]进行互换</span></span><br><span class="line">    	<span class="keyword">int</span> tmp=nums[m];</span><br><span class="line">		nums[m]=nums[i];</span><br><span class="line">		nums[i]=tmp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Largest Number]]></title>
      <url>http://codeinterviews.com/Largest-Number/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Largest Number</p>
<blockquote>
<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p>
<p>Note: The result may be very large, so you need to return a string instead of an integer.</p>
<p>####Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>1 对于两个备选数字a和b, 如果str(a) + str(b) &gt; str(b) + str(a), 则a在b之前，否则b在a之前，按照这个原则对原数组从大到小排序即可。我们只需要写出sort函数的自定义比较函数即可。还有我们，要注意一个特殊情况，如果字符串后的字符串从0开始，我们返回“0”。</p>
<p>2 首先，我们将num转成字符串存入数组，然后根据自定义比较函数排序，之后再对排序后的字符串连接成一个字符串，最后排除特殊情况，得到所求结果。</p>
<p>因此，本题的关键就是根据以上的推导建立比较规则，借助Comparator（或者Comparable，如果你的类可以实现该接口）</p>
<p>得到顺序。使用到Arrays.sort(str[],new Comparator{});</p>
<p>本题提醒我们数字可能会很大，因此组合和比较的时候都是用字符串。还好字符串的比较可以使用comparatorTo方法。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] cur=<span class="keyword">new</span> String[num.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	cur[i]=num[i]+<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(cur,<span class="keyword">new</span> MyComparator());</span><br><span class="line">        String RST=<span class="string">""</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur.length;i++)&#123;  </span><br><span class="line">            RST+=cur[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(RST.charAt(<span class="number">0</span>)==<span class="string">'0'</span>)</span><br><span class="line">            RST=<span class="string">"0"</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> RST;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己实现比较函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> (o2+o1).compareTo(o1+o2);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LaTeX入门教程]]></title>
      <url>http://codeinterviews.com/LaTeX%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>##引言<br>由于国外的很多会议都使用LaTeX进行排版，例如自然语言处理顶级会议ACL。因此，为了投国外的期刊与会议，我也开始学习LaTeX。  </p>
<p>但是遗憾的是，现有的LaTeX入门教材都太长了，导致我这个想半天搞定它开始写论文的想法付之东流。因此，在这里，只为了能够快速入门LaTeX,本人写了这一篇入门教程，其中只涉及到写论文的基本知识点，让您能够半天搞定LaTeX。</p>
<p>当涉及到高级知识的方面，请自行找“谷哥”和“度娘”。</p>
<a id="more"></a>
<p>##LaTeX简介<br>LaTeX的介绍主要是以下三点：  </p>
<ol>
<li>LaTeX是一类用于编辑和排版的软件，用于生成PDF文档。     </li>
<li>LaTeX编辑和排版的核心思想在于，通过\section和\paragraph等语句，规定了每一句话在文章中所从属的层次，从而极大方便了对各个层次批量处理。    </li>
<li>LaTeX在使用体验方面，最不易被Word替代的有四个方面：方便美观的数学公式编辑、不会乱动的退格对齐、非所见即所得因此可以在编辑的时候用退格和换行整理思路但生成PDF出来不影响美观、部分导师和刊物不接受Word排版的文章。  </li>
</ol>
<p>##LaTeX软件的安装<br>由于国内的CTeX非常流行，因此这里可以在<a href="http://www.ctex.org/HomePage" target="_blank" rel="external">cTeX.org</a>下载ctex套装，其中包含MikTeX和WinEit。一键安装即可。</p>
<p>##建立第一个文档<br>打开<code>WinEdt</code>,建立一个新文档,在其中输入以下内容：</p>
<pre><code>\documentclass{article}
\begin{document}
    hello world!!!
\end{document}
</code></pre><p>然后进行保存，保存格式为<code>UTF-8</code>.接着在<code>WinEdt</code>的工具栏中找到编译按钮<img src="/img/LaTeX/1.png" alt="">,在下拉菜单中选择<code>LeTeX</code>,并点击进行编译。<br>如果成功的话，就会得到一个PDF文件，点击工具栏中的放大镜按钮就可以快速查看。</p>
<p>##标题、作者和注释<br>建立一个新文档，输入以下内容：</p>
<pre><code>\documentclass{article} 
    \author{My Name} 
    \title{The Title} 
\begin{document} 
      \maketitle 
      hello, world % This is comment 
\end{document} 
</code></pre><p>并保存为<code>UTF-8</code>格式，然后编译查看结果。</p>
<p>##章节和段落<br>建立一个新文档，输入以下内容：</p>
<pre><code>\documentclass{article}
  \title{Hello World}
\begin{document}
  \maketitle
  \section{Hello China} China is in East Asia.
    \subsection{Hello Beijing} Beijing is the capital of China.
      \subsubsection{Hello Dongcheng District}
        \paragraph{Tian&apos;anmen Square}is in the center of Beijing
          \subparagraph{Chairman Mao} is in the center of Tian&apos;anmen Square
      \subsection{Hello Guangzhou}
        \paragraph{Sun Yat-sen University} is the best university in Guangzhou.
\end{document}  
</code></pre><p>其实每一行前面的空格不影响编译生成的PDF的排版结果。因此，是否退格只是个人的爱好。</p>
<p>##加入目录<br>建立一个新文档，输入以下内容，编译并观察结果：</p>
<pre><code>\documentclass{article} 
\begin{document} 
  \tableofcontents  %生成目录
  \section{Hello China} China is in East Asia. 
    \subsection{Hello Beijing} Beijing is the capital of China. 
      \subsubsection{Hello Dongcheng District} 
        \paragraph{Hello Tian&apos;anmen Square}is in the center of Beijing 
          \subparagraph{Hello Chairman Mao} is in the center of Tian&apos;anmen Square 
\end{document}
</code></pre><p>##换行<br>建立一个新文档，输入以下内容，编译并观察结果：</p>
<pre><code>\documentclass{article}
\begin{document}
  Beijing is
  the capital
  of China.

  New York is

  the capital

  of America.

  Amsterdam is \\ the capital \\
  of Netherlands.
\end{document}
</code></pre><p>##数学公式<br>建立一个新文档，输入以下内容，保存并进行编译，然后观察结果：</p>
<pre><code>\documentclass{article}
  \usepackage{amsmath}
  \usepackage{amssymb}
\begin{document}
  The Newton&apos;s second law is F=ma.

  The Newton&apos;s second law is $F=ma$.

  The Newton&apos;s second law is
  $$F=ma$$

  The Newton&apos;s second law is
  \[F=ma\]

  Greek Letters $\eta$ and $\mu$

  Fraction $\frac{a}{b}$

  Power $a^b$

  Subscript $a_b$

  Derivate $\frac{\partial y}{\partial t} $

  Vector $\vec{n}$

  Bold $\mathbf{n}$

  To time differential $\dot{F}$

  Matrix (lcr here means left, center or right for each column)
  \[
    \left[
      \begin{array}{lcr}
        a1 &amp; b22 &amp; c333 \\
        d444 &amp; e555555 &amp; f6
      \end{array}
    \right]
  \]

Equations(here \&amp; is the symbol for aligning different rows)
\begin{align}
  a+b=c\\
  d=e+f+g
\end{align}

\[
  \left\{
    \begin{aligned}
      &amp;a+b=c\\
      &amp;d=e+f+g
    \end{aligned}
  \right.
\]

\end{document}
</code></pre><p>具体细节需要查看LaTeX的数学符号表。</p>
<p>公式中的空格设定如下：</p>
<pre><code>两个quad空格    a \qquad b    a \qquad b    两个m的宽度
quad空格    a \quad b    a \quad b    一个m的宽度
大空格    a\ b    a\ b    1/3m宽度
中等空格    a\;b    a\;b    2/7m宽度
小空格    a\,b    a\,b    1/6m宽度
没有空格    ab    ab\,    
紧贴    a\!b    a\!b    缩进1/6m宽度
</code></pre><p><a href="http://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="external">LaTeX在线公式编辑器</a>;</p>
<p>##插入图片<br>首先先要搜索一个将图片转成<code>eps</code>文件的软件，很容易找到，然后要将图片保存为一个名字如figure1.eps。<br>建立一个新文档，输入以下内容，保存到和图片文件同一个文件夹里，编译并观察现象。</p>
<pre><code>\documentclass{article} 
  \usepackage{graphicx} 
\begin{document} 
  \includegraphics[width=4.00in,height=3.00in]{figure1.eps} 
\end{document}
</code></pre><p>##简单表格<br>建立一个新文档，输入以下内容，进行保存编译并观察结果：</p>
<pre><code>\documentclass{article}
\begin{document}
  \begin{tabular}{|c|c|}
    a &amp; b \\
    c &amp; d\\
  \end{tabular}

  \begin{tabular}{|c|c|}
    \hline
    a &amp; b \\
    \hline
    c &amp; d\\
    \hline
  \end{tabular}

  \begin{center}
    \begin{tabular}{|c|c|}
      \hline
      a &amp; b \\ \hline
      c &amp; d\\
      \hline
    \end{tabular}
  \end{center}
\end{document} 
</code></pre><p>##总结<br>到目前为止，你已经可以用LaTeX自带的article模板来书写一篇基本的论文框架了，至少你已经能够用得起来LaTeX了。<br>在论文从框架到完整的过程中，必然还存在许多的细节问题，比如字体字号，比如图片拼合，比如复杂的表格等等。<br>那些问题，就请咨询google吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Climbing Stairs]]></title>
      <url>http://codeinterviews.com/Climbing-Stairs/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Climbing Stairs</p>
<blockquote>
<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是典型的动态规划方法，由于每次只能夸<code>1</code>步或<code>2</code>步，则到达第<code>i</code>层的方法数只依赖于到达第<code>i-1</code>层和第<code>i-2</code>层的方法数，因此动态规划定义如下：</p>
<pre><code>定义dp[i]:到达第i层共有的方法数
则dp[i]=dp[i-1]+dp[i-2]
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//dp[i]表示到达第i层共有的方法数</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        	dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-LRU Cache]]></title>
      <url>http://codeinterviews.com/LRU-Cache/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####LRU Cache</p>
<blockquote>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it &gt;should invalidate the least recently used item before inserting a new item.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这是一道非常综合的题目，主要应用在操作系统的资源管理中。</p>
<p>按照题目要求，要实现get和set功能，为了满足随机存储的需求我们首先想到的一般是用数组，如果用链表会有O(n)的访问时间。然而他又有另一个条件就是要维护least used的队列，也就是说经常用的放在前面，用的少的放在后面。这样当资源超过cache的容积的时候就可以把用得最少的资源删掉。这就要求我们要对节点有好的删除和插入操作，这个要求又会让我们想到用链表，因为数组的删除和插入是O(n)复杂度的。  </p>
<p>那么我们能不能维护一个数据结构使得访问操作和插入删除操作都是O(1)复杂度的呢？答案是肯定的。这个数据结构比较复杂，是用一个hash表加上一个双向链表来实现。基本思路是这样的，用一个hash表来维护结点的位置关系，也就是hash表的key就是资源本身的key，value是资源的结点（包含key和value的信息）。然后把结点维护成一个双向链表构成的队列，这样子如果我们要访问某一个结点，那么可以通过hash表和key来找到结点，从而取到相应的value。而当我们想要删除或者插入结点时，我们还是通过hash表找到结点，然后通过双向链表和队列的尾结点把自己删除同时插入到队尾。通过hash表访问结点我们可以认为是O(1)的操作（假设hash函数足够好），然后双向链表的插入删除操作也是O(1)的操作。如此我们便实现了用O(1)时间来完成所有LRU cache的操作。空间上就是对于每一个资源有一个hash表的的项以及一个对应的结点（包含前后指针和资源的<key, value="">）。</key,></p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        Node pre, next;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Node first, last;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node!=last)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node == first)</span><br><span class="line">                first = first.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node.pre.next = node.next;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            last.next = node;</span><br><span class="line">            node.pre = last;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            last = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node.val = value;</span><br><span class="line">            <span class="keyword">if</span>(node!=last)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(node == first)</span><br><span class="line">                    first = first.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node.pre.next = node.next;</span><br><span class="line">                node.next.pre = node.pre;</span><br><span class="line">                last.next = node;</span><br><span class="line">                node.pre = last;</span><br><span class="line">                node.next = <span class="keyword">null</span>;</span><br><span class="line">                last = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(key,value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(num&gt;=capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                map.remove(first.key);</span><br><span class="line">                first = first.next;</span><br><span class="line">                <span class="keyword">if</span>(first!=<span class="keyword">null</span>)</span><br><span class="line">                    first.pre = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    last = <span class="keyword">null</span>;</span><br><span class="line">                num--;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(first == <span class="keyword">null</span> || last == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                first = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last.next = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.pre = last;</span><br><span class="line">            last = newNode;</span><br><span class="line">            map.put(key,newNode);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Largest Rectangle in Histogram]]></title>
      <url>http://codeinterviews.com/Largest-Rectangle-in-Histogram/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Largest Rectangle in Histogram</p>
<blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br><img src="/img/Largest-Rectangle-in-Histogram/1.png" alt=""></p>
<p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].<br><img src="/img/Largest-Rectangle-in-Histogram/2.png" alt=""></p>
<p>The largest rectangle is shown in the shaded area, which has area = 10 unit.   </p>
<p>For example,<br>Given height = <code>[2,1,5,6,2,3]</code>,<br>return <code>10</code>.  </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题求最大面积的矩形，比较容易理解的思路，就是从每一个bar往两边走，以自己的高度为标准，直到两边低于自己的高度为止，然后用自己的高度乘以两边走的宽度得到矩阵面积。因为我们对于任意一个bar都计算了以自己为目标高度的最大矩阵，所以最好的结果一定会被取到。每次往两边走的复杂度是O(n)，总共有n个bar，所以时间复杂度是O(n^2)。</p>
<p>这边在求一个<code>bar</code>左边低于自己高度的最大<code>x</code>位置和右边低于自己高度的最小<code>x</code>位置时，可以采用栈来求解。以求解左边为例：如果栈顶的位置高度比<code>bar</code>的高度高，则不断出栈，如果栈为空，说明<code>bar</code>的左边界能达到最左边位置，则令其<code>left=-1</code>,否则栈顶的位置就是<code>bar</code>的左边界，然后将<code>bar</code>压入栈中，在求解下一个<code>bar</code>的左边界，这样遍历一遍就知道每个<code>bar</code>的左边界位置。</p>
<p>同理可以求解每个<code>bar</code>的右边界位置。这样每个<code>bar</code>能形成的最大矩形面积为<code>height(bar)*(right-left-1)</code>,整个时间为<code>O(n)+O(n)+O(n)</code>,分别为求左边界，求右边界，求最大面积，这样总的时间复杂度为<code>O(n)</code>.</p>
<p>下一题<a href="http://pisxw.com/algorithm/Maximal%20Rectangle.html" target="_blank" rel="external">Maximal Rectangle</a>是该题的扩展，该题是其子程序。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(height.length==<span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> height[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//使用栈来求解每个bar左边高度小于H(bar)的最大的x坐标，记为left</span></span><br><span class="line">        <span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">while</span>(stack.size()!=<span class="number">0</span> &amp;&amp;(height[stack.peek()]&gt;=height[i]))</span><br><span class="line">    		&#123;</span><br><span class="line">    			stack.pop();</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(stack.size()==<span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			left[i]=-<span class="number">1</span>;</span><br><span class="line">    			stack.push(i);</span><br><span class="line">    		&#125;		</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    		&#123;</span><br><span class="line">    			left[i]=stack.peek();</span><br><span class="line">    			stack.push(i);</span><br><span class="line">    		&#125;	</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同理使用栈来求解每个bar右边高度小于H(bar)的最小的x坐标，记为right</span></span><br><span class="line">        <span class="keyword">int</span>[] right=<span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack2=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        stack2.push(height.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=height.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">while</span>(stack2.size()!=<span class="number">0</span> &amp;&amp;(height[stack2.peek()]&gt;=height[i]))</span><br><span class="line">    		&#123;</span><br><span class="line">    			stack2.pop();</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			right[i]=height.length;</span><br><span class="line">    			stack2.push(i);</span><br><span class="line">    		&#125;   			</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    		&#123;</span><br><span class="line">    			right[i]=stack2.peek();</span><br><span class="line">    			stack2.push(i);</span><br><span class="line">    		&#125;	</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//计算每个bar能形成的矩形的面积，并求得一个最大面积</span></span><br><span class="line">    	<span class="keyword">int</span> maxRec=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> rec=(right[i]-left[i]-<span class="number">1</span>)*height[i];</span><br><span class="line">    		maxRec=Math.max(maxRec,rec);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> maxRec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Letter Combinations of a Phone Number]]></title>
      <url>http://codeinterviews.com/Letter-Combinations-of-a-Phone-Number/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Letter Combinations of a Phone Number</p>
<blockquote>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
</blockquote>
<p><img src="/img/Letter-Combinations-of-a-Phone-Number/Phone.png" alt=""></p>
<p>&gt;<br>    Input:Digit string “23”<br>    Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>####Note:</p>
<blockquote>
<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是给定一个数字，然后将在手机上该数字所对应的每一位字符进行组合，得到所有的组合。这里需要知道手机上的每一位代表的字符集。</p>
<pre><code>手机数字对应
1：&quot;&quot;
2: &quot;abc&quot;
3: &quot;def&quot;
4: &quot;ghi&quot;
5: &quot;jkl&quot;
6: &quot;mno&quot;
7: &quot;pqrs&quot;
8: &quot;tuv&quot;
9: &quot;wxyz&quot;
0: &quot; &quot;
</code></pre><p>得到一个数字代表的字符后，只需要对字符进行全排列组合即可得到结果。这里可以采用<strong>递归</strong>的方法对多个数字进行字符组合。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">		手机数字对应</span><br><span class="line">		1：""</span><br><span class="line">		2: "abc"</span><br><span class="line">		3: "def"</span><br><span class="line">		4: "ghi"</span><br><span class="line">		5: "jkl"</span><br><span class="line">		6: "mno"</span><br><span class="line">		7: "pqrs"</span><br><span class="line">		8: "tuv"</span><br><span class="line">		9: "wxyz"</span><br><span class="line">		0: " "</span><br><span class="line"></span><br><span class="line">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cdigit=digits.toCharArray();</span><br><span class="line">        ArrayList&lt;String&gt; strList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; strListPre=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; strListLast=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(cdigit.length==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            strList.add(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">return</span> strList;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(cdigit.length==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">switch</span>(cdigit[<span class="number">0</span>])</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'1'</span>:<span class="keyword">break</span>;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'2'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">"a"</span>);</span><br><span class="line">        			strList.add(<span class="string">"b"</span>);</span><br><span class="line">        			strList.add(<span class="string">"c"</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'3'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">"d"</span>);</span><br><span class="line">        			strList.add(<span class="string">"e"</span>);</span><br><span class="line">        			strList.add(<span class="string">"f"</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'4'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">"g"</span>);</span><br><span class="line">        			strList.add(<span class="string">"h"</span>);</span><br><span class="line">        			strList.add(<span class="string">"i"</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'5'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">"j"</span>);</span><br><span class="line">        			strList.add(<span class="string">"k"</span>);</span><br><span class="line">        			strList.add(<span class="string">"l"</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'6'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">"m"</span>);</span><br><span class="line">        			strList.add(<span class="string">"n"</span>);</span><br><span class="line">        			strList.add(<span class="string">"o"</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'7'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">"p"</span>);</span><br><span class="line">        			strList.add(<span class="string">"q"</span>);</span><br><span class="line">        			strList.add(<span class="string">"r"</span>);</span><br><span class="line">        			strList.add(<span class="string">"s"</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'8'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">"t"</span>);</span><br><span class="line">        			strList.add(<span class="string">"u"</span>);</span><br><span class="line">        			strList.add(<span class="string">"v"</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'9'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">"w"</span>);</span><br><span class="line">        			strList.add(<span class="string">"x"</span>);</span><br><span class="line">        			strList.add(<span class="string">"y"</span>);</span><br><span class="line">        			strList.add(<span class="string">"z"</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'0'</span>:&#123;</span><br><span class="line">        			strList.add(<span class="string">" "</span>);</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	strListPre=letterCombinations(String.valueOf(cdigit,<span class="number">0</span>,cdigit.length-<span class="number">1</span>)); <span class="comment">//前cdigit.length-1个数的字符组合结果</span></span><br><span class="line">        	strListLast=letterCombinations(String.valueOf(cdigit,cdigit.length-<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//最后一个数的字符组合结果</span></span><br><span class="line">        	<span class="keyword">for</span>(String str1:strListPre)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">for</span>(String str2:strListLast)</span><br><span class="line">        		&#123;</span><br><span class="line">        			String s=str1+str2;</span><br><span class="line">        			strList.add(s);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        		</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Length of Last Word]]></title>
      <url>http://codeinterviews.com/Length-of-Last-Word/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Length of Last Word</p>
<blockquote>
<p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>####Note:<br>A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>Given s = <code>&quot;Hello World&quot;</code>,<br>return <code>5</code>.   </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是找出最后一个单词的长度，由于单词间是用<code>空格</code>分割，因此从后往前扫描，并记录单词的长度，但是这里需要注意的是：如果后面都是<code>空格</code>，此时还没有找到最后一个单词，应该继续往前找，直到一个非空格字符。那么如果后面再次找到<code>空格</code>，说明最后一个单词结束，则可以直接返回最终长度。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] schr=s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || schr.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=schr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(schr[i]!=<span class="string">' '</span>)</span><br><span class="line">        		res++;</span><br><span class="line">        	<span class="keyword">else</span>&#123;</span><br><span class="line">        		<span class="keyword">if</span>(res==<span class="number">0</span>)</span><br><span class="line">        			<span class="keyword">continue</span>;</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Linked List Cycle II]]></title>
      <url>http://codeinterviews.com/Linked-List-Cycle-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Linked List Cycle II</p>
<blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Follow up:<br>Can you solve it without using extra space?<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Linked-List-Cycle.html" target="_blank" rel="external">Linked List Cycle</a>解法相同，同样定义两个指针，因为这两个指针即可以用来判断是否是一个环<code>（A==B）</code>，也可以得到最终他们的相遇点。</p>
<p>假设两个指针walker和runner，walker一倍速移动，runner两倍速移动。有一个链表，假设他在cycle开始前有a个结点，cycle长度是c，而我们相遇的点在cycle开始后b个结点。那么想要两个指针相遇，意味着要满足以下条件：(1) a+b+mc=s; (2) a+b+nc=2s; 其中s是指针走过的步数，m和n是两个常数。这里面还有一个隐含的条件，就是s必须大于等于a，否则还没走到cycle里面，两个指针不可能相遇。假设k是最小的整数使得a&lt;=kc，也就是说(3) a&lt;=kc&lt;=a+c。接下来我们取m=0, n=k，用(2)-(1)可以得到s=kc以及a+b=kc。由此我们可以知道，只要取b=kc-a(由(3)可以知道b不会超过c)，那么(1)和(2)便可以同时满足，使得两个指针相遇在离cycle起始点b的结点上。<br>因为s=kc&lt;=a+c=n，其中n是链表的长度，所以走过的步数小于等于n，时间复杂度是O(n)。</p>
<p>从head开始到环的起点和从想遇点到环的起点距离是一样的。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode A=head;</span><br><span class="line">        ListNode B=head;</span><br><span class="line">        <span class="keyword">while</span>(B!=<span class="keyword">null</span> &amp;&amp; B.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	A=A.next;</span><br><span class="line">        	B=B.next.next;</span><br><span class="line">        	<span class="keyword">if</span>(A==B)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="comment">//此时从head开始到环的起点和从想遇点到环的起点距离是一样的。</span></span><br><span class="line">        		ListNode C=head;</span><br><span class="line">        		<span class="keyword">while</span>(C!=A)</span><br><span class="line">        		&#123;</span><br><span class="line">        			C=C.next;</span><br><span class="line">        			A=A.next;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">return</span> C;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Linked List Cycle]]></title>
      <url>http://codeinterviews.com/Linked-List-Cycle/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Linked List Cycle</p>
<blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题是判断一个链表是否存在一个环，这里我们可以将其联想到现实生活中，我们找两个指针<code>A,B</code>，<code>A</code>每次以1步为单位前进，而<code>B</code>每次以2步为单位前行，最终我们会发现，如果链表中有环，肯定是在末尾，而且<code>A</code>最终肯定能与<code>B</code>相遇。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode A=head;<span class="comment">//定义A指针，每次以1步为单位前进</span></span><br><span class="line">        ListNode B=head;<span class="comment">//定义B指针，每次以2步为单位前进</span></span><br><span class="line">        <span class="keyword">while</span>(B!=<span class="keyword">null</span> &amp;&amp; B.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	A=A.next;</span><br><span class="line">        	B=B.next.next;</span><br><span class="line">        	<span class="keyword">if</span>(A==B)</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（一）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>ls</strong>,<strong>cd</strong>,<strong>pwd</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##ls命令<br>ls命令是linux下最常用的命令，ls命令就是list的缩写。<br>ls用来打印出当前目录的清单。如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。<br>通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</p>
<p>###命令格式：<br>ls [选项] [目录名]</p>
<p>###常用参数：</p>
<pre><code>-a       –all 列出目录下的所有文件，包括以 . 开头的隐含文件
-l       除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来
-d      –directory 将目录象文件一样显示，而不是显示其下的文件
-h       –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)
-t      以文件修改时间排序
</code></pre><p>###常用范例：<br><strong>例一：</strong>列出/home文件夹下的所有文件和目录的详细资料，可以使用如下命令：</p>
<pre><code>ls -a -l /home 
ls -al /home
</code></pre><p>上面两个命令执行结果一样，结果如下：<br><img src="http://anything-about-doc.qiniudn.com/linux1.jpg" alt="Alt text"></p>
<p>注意上面红色方框，d表示目录（directory），-表示文件，文件和目录显示的颜色也不同。</p>
<p><strong>例二：</strong>列出当前目录中所有以”d”开头的文件目录的详细内容，可以使用如下命令：</p>
<pre><code>ls -l d*
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux2.jpg" alt="Alt text"></p>
<p><strong>例三</strong>：以容易理解的格式列出/home目录中所有的文件目录的大小，可以使用如下命令：</p>
<pre><code>ls  -alh  /home
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux3.jpg" alt="Alt text"></p>
<p>###思考题<br>1.以容易理解的格式列出/home目录中所有以”d”开头的文件目录的大小。<br>2.列出/home目录中所有以”s”开头的目录。</p>
<p>##cd命令<br>cd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。cd命令是change directory的缩写,切换当前目录至指定的目录。</p>
<p>###命令格式：<br>cd [目录名]</p>
<p>###常用范例：<br><strong>例一：</strong>从当前目录进入系统根目录，可以使用如下命令：</p>
<pre><code>cd  /
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux5.jpg" alt="Alt text"></p>
<p><strong>例二：</strong>从当前目录进入父目录，可以使用如下命令：</p>
<pre><code>cd ..
</code></pre><p>..表示父目录</p>
<p><img src="http://anything-about-doc.qiniudn.com/linux6.jpg" alt="Alt text"></p>
<p><strong>例三：</strong>从当前目录进入当前用户主目录，可以使用如下命令：</p>
<pre><code>cd ~
</code></pre><p>~ 表示当前用户主目录，注意与系统根目录不是同一个概念<br><img src="http://anything-about-doc.qiniudn.com/linux7.jpg" alt="Alt text"></p>
<p><strong>例四：</strong>从当前目录进入上次所在目录，可以使用如下命令:</p>
<pre><code>cd -
</code></pre><ul>
<li>表示上次进入的目录</li>
</ul>
<p><img src="http://anything-about-doc.qiniudn.com/linux8.jpg" alt="Alt text"></p>
<p>##pwd命令<br>Linux中用 pwd 命令来查看“当前工作目录”的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。<br>pwd命令是print working directory的缩写。</p>
<p>###命令格式：<br>pwd [选项]</p>
<p>###常用参数：</p>
<pre><code>-P  显示实际物理路径，而非使用连接（link）路径
-L  当目录为连接路径时，显示连接路径
</code></pre><p>###常用范例：<br><strong>例一：</strong>显示当前目录所在路径，可以使用如下命令：</p>
<pre><code>pwd
</code></pre><p><strong>例二：</strong>显示当前目录的物理路径，可以使用如下命令：</p>
<pre><code>pwd -P
</code></pre><p><strong>例三：</strong>显示当前目录的连接路径，可以使用如下命令：</p>
<pre><code>pwd -L
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux9.png" alt="Alt text"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（三）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>more</strong>,<strong>less</strong>,<strong>head</strong>,<strong>tail</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##more命令<br>more命令，功能类似 cat ，cat命令是将整个文件的内容从上到下显示在屏幕上。 more命令会一页一页的显示，方便使用者逐页阅读，而最基本的指令就是按空白键（space）往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。</p>
<p>###命令格式：<br>more [选项] 文件</p>
<p>###常用参数：</p>
<pre><code>+n          从笫n行开始显示
-n           定义屏幕大小为n行
+/pattern     在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开                始显示  
-c           从顶部清屏，然后显示
-d          提示“Press space to continue，’q’ to quit”，禁用响铃功能
-p          通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
-s           把连续的多个空行显示为一行
-u          把文件内容中的下画线去掉
常用操作：
=            输出当前行的行号
q        退出more 
空格键      向下滚动一屏
b              返回上一屏
</code></pre><p>###常用范例：<br>下面示例中用到的shiyanlou.log文件内容如下：</p>
<p><strong>例一：</strong>从第五行开始显示shiyanlou.log文件中的内容，可以使用如下命令：</p>
<pre><code>more +5 shiyanlou.log 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux31.png" alt="Alt text"></p>
<p><strong>例二：</strong>从shiyanlou.log文件中查找第一个出现&#34;g&#34;字符串的行，并从该处前两行开始显示输出，可以使用如下命令：</p>
<pre><code>more +/g shiyanlou.log 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux32.png" alt="Alt text"></p>
<p><strong>例三：</strong>设定每屏行数为5，可以使用如下命令：</p>
<pre><code>more -5 shiyanlou.log 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux33.png" alt="Alt text"></p>
<p><strong>例四：</strong>使用ll和more命令显示/etc目录信息，可以使用如下命令：</p>
<pre><code>ll /etc | more -10
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux34.png" alt="Alt text"></p>
<p>每页显示10个文件信息，按 Ctrl+F 或者 空格键 将会显示下10条文件信息。</p>
<p>##less 命令</p>
<p>less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。</p>
<p>###命令格式：<br>less [选项] 文件</p>
<p>###常用参数：</p>
<pre><code>-e              当文件显示结束后，自动离开
-f              强迫打开特殊文件，例如外围设备代号、目录和二进制文件
-i              忽略搜索时的大小写
-m              显示类似more命令的百分比
-N              显示每行的行号
-s              显示连续空行为一行
</code></pre><p>###常用操作：</p>
<pre><code>/字符串            向下搜索“字符串”的功能
?字符串            向上搜索“字符串”的功能
n                重复前一个搜索（与 / 或 ? 有关）
N                反向重复前一个搜索（与 / 或 ? 有关）
b                  向前翻一页
d                  向后翻半页
q                  退出less 命令
空格键             向后翻一页
向上键            向上翻动一行
向下键            向下翻动一行
</code></pre><p>###常用范例：<br><strong>例一：</strong>显示shiyanlou.log文件中的内容，并显示行号，可以使用如下命令：</p>
<pre><code>less -N shiyanlou.log 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux35.png" alt="Alt text"></p>
<p><strong>例二：</strong>显示shiyanlou.log文件中的内容，搜索字符串”shiyanlou”，可以使用如下命令：</p>
<pre><code>less  shiyanlou.log
/shiyanlou
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux226.png" alt="Alt text"></p>
<p><img src="http://anything-about-doc.qiniudn.com/linux37.png" alt="Alt text"></p>
<p><strong>例三：</strong>ps查看进程信息并通过less分页显示 ，可以使用如下命令： </p>
<pre><code>ps -f | less
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux38.png" alt="Alt text"></p>
<p>###less与cat和more的区别：<br>cat命令功能用于显示整个文件的内容，单独使用没有翻页功能。因此经常和more命令搭配使用，cat命令还有就是可以将数个文件合并成一个文件的功能。    more命令功能：让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按q键停止显示。</p>
<p>less命令功能：less命令的用法与more命令类似，也可以用来浏览超过一页的文件。所不同的是less命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在less命令的提示符“：”下按q键即可。    其实这三个命令除了cat命令有合并文件的功能，其余功能上相近，只是从浏览习惯和显示方式上有所不同。</p>
<p>##head 命令<br>head命令就像它的名字一样浅显易懂，主要是用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。</p>
<p>###命令格式：<br>head [选项]  [文件]</p>
<p>###常用参数：</p>
<pre><code>-q                 隐藏文件名
-v                 显示文件名
-c&lt;字节&gt;;        显示字节数
-n&lt;行数&gt;;         显示的行数
</code></pre><p>###常用范例：<br><strong>例一：</strong>显示shiyanlou.log文件中的前5行内容，可以使用如下命令：<br>head -n 5 shiyanlou.log<br><img src="http://anything-about-doc.qiniudn.com/linux39.png" alt="Alt text"></p>
<p><strong>例二：</strong>显示shiyanlou.log和zhou.log文件中的前5行内容，可以使用如下命令：<br>head -n 5 shiyanlou.log  zhou.log<br><img src="http://anything-about-doc.qiniudn.com/linux40.png" alt="Alt text"></p>
<p><strong>例三：</strong>显示shiyanlou.log文件中除了最后5行的内容，可以使用如下命令：<br>head -n -5 shiyanlou.log<br><img src="http://anything-about-doc.qiniudn.com/linux41.png" alt="Alt text"></p>
<p>##tail 命令<br>tail 命令主要用于显示指定文件末尾内容。常用查看日志文件。</p>
<p>###命令格式：<br>tail  [选项]  [文件]</p>
<p>###常用参数：</p>
<pre><code>-f             循环读取
-q             不显示处理信息
-v             显示详细的处理信息
-c&lt;字节&gt;     显示的字节数
-n&lt;行数&gt;     显示行数
</code></pre><p>###常用范例：<br><strong>例一：</strong>显示shiyanlou.log文件中的最后5行内容，可以使用如下命令：</p>
<pre><code>tail -n 5 shiyanlou.log 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux50.png" alt="Alt text"></p>
<p><strong>例二：</strong>显示shiyanlou.log文件中的最后5行内容，当shiyanlou.log文件有新内容增加，自动更新显示。可以使用如下命令：</p>
<pre><code>tail -n 5 -f shiyanlou.log 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux51.png" alt="Alt text"></p>
<p>ping www.shiyanlou.com &gt;&gt; shiyanlou.log 这条命令作用是，ping远程主机，并将信息追加到shyanlou.log文件中。&amp; 的作用是将这条命令放在后台执行，这样shiyanlou.log文件就会一直有内容增加。说明一下，linux下执行ping命令会一直执行，必须手动停止才行。而windows下执行ping命令时，发送一定请求后会自动停止。</p>
<p><img src="http://anything-about-doc.qiniudn.com/linux52.png" alt="Alt text"></p>
<p>使用tail命令的-f选项可以即时输出文件变化后追加的内容，tail -f filename会把filename里最尾部的内容显示在屏幕上，并且不但刷新，使你看到最新的文件内容。<br>另外顺便说一下怎么查看后台正在运行的任务，及怎么停止任务。<br>jobs命令可以查看正在后台运行的任务。kill命令可以杀死一个任务，但要使用任务的id。任务的id可以通过ps命令查看获得。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（七）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>cut</strong>,<strong>paste</strong>,<strong>tr</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##cut命令<br>cut命令是一个将文本按列进行切分的小工具，它可以指定分隔每列的定界符。</p>
<p>如果一行数据包含多个字段（多列），现在想要提取其中的一列或多列，这是cut命令就可以大显身手了。</p>
<p>###命令格式：<br>cut [选项] [文件名]</p>
<p>###常用参数：</p>
<ul>
<li>-b         以字节为单位进行分割</li>
<li>-c         以字符为单位进行分割</li>
<li>-d         自定义分隔符，默认为制表符</li>
<li>-f      自定义字段</li>
<li>–complement     抽取整个文本行，除了那些由 -c 或 -f 选项指定的文本</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>取出student.txt文件中的第一列和第三列，可以使用如下命令：</p>
<pre><code>cut -f 1,3 -d ‘ ’ student.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid369time1420779726136" alt="img"></p>
<p><strong>例二：</strong>取出student.txt文件中的第一列，可以使用如下命令：</p>
<pre><code>cut -f 1 -d ‘ ’ student.txt
</code></pre><p><strong>例三：</strong>取出student.txt文件中的前三列，可以使用如下命令：</p>
<pre><code>cut -f 1-3 -d ‘ ’ student.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid369time1420779770034" alt="img"></p>
<p><strong>例四：</strong>取出student.txt文件中除第一列的其他列，可以使用如下命令：</p>
<pre><code>cut -f 1 -d ‘ ’ student.txt --complement    
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid369time1420779805413" alt="img"></p>
<p><strong>例五：</strong>给任意一字符串str，取出其最后一个字符，可以使用如下命令：</p>
<pre><code>num=$(echo -n $str | wc -c)
echo -n $str | cut -b $num 
或者
echo -n $str | cut -b `echo -n $str | wc -c`
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid369time1420779859931" alt="img"></p>
<p>##paste命令<br>paste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。</p>
<p>###命令格式：<br>paste [选项] [文件名]</p>
<p>###常用参数：</p>
<ul>
<li>-s         将每个文件合并成行而不是按行粘贴</li>
<li>-d         自定义分隔符，默认为制表符</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>将student.txt和telphone.txt文件中的内容按列拼接，可以使用如下命令：</p>
<pre><code>paste student.txt telphone.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid369time1420780031604" alt="img"></p>
<p><strong>例二：</strong>将student.txt和telphone.txt文件中的内容按列拼接，指定分隔符为’：’，可以使用如下命令：</p>
<pre><code>paste student.txt telphone.txt -d ‘:’
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid369time1420780078087" alt="img"></p>
<p><strong>例三：</strong>将student.txt和telphone.txt文件中的内容各自拼接成一行，可以使用如下命令：</p>
<pre><code>paste -s student.txt telphone.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid369time1420780124133" alt="img"></p>
<p>##tr命令<br> tr命令常被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。换字是一种把字符从一个字母转换为另一个字母的过程。tr从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。</p>
<p>tr只能通过stdin（标准输入），而无法通过命令行参数来接受输入。</p>
<p>tr是translate（转换）的缩写。</p>
<p>###命令格式：<br>tr  [选项]  SET1  SET2</p>
<p>将来自stdin的输入字符从SET1映射到SET2，并将其输出写入stdout（标准输出）。SET1和SET2是字符类或字符集。如果两个字符集的长度不相等，那么SET2会不断重复其最后一个字符，直到长度与SET1相同。如果SET2的长度大于SET1，那么在SET2中超出SET1的那部分字符则全部被忽略。</p>
<p>###常用参数：</p>
<ul>
<li>-d     删除匹配SET1的内容，并不作替换</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>将输入的字符大写转换为小写，可以使用如下命令：</p>
<pre><code>echo ‘THIS IS SHIYANLOU!’ | tr ‘A-Z’ ‘a-z’
</code></pre><p><strong>例二：</strong>将输入的字符中的数字删除，可以使用如下命令：</p>
<pre><code>echo ‘THIS 123 IS S1HIY5ANLOU!’ | tr -d ‘0-9’ 
</code></pre><p><strong>例三：</strong>tr 命令的一个有趣的用法是执行 ROT13 文本编码。ROT13 是一款微不足道的基于一种简易的替换暗码的加密类型。把 ROT13 称为“加密”是大方的，“文本模糊处理”更准确些。有时候它被用来隐藏文本中潜在的攻击内容。这个方法就是简单地把每个字符在字母表中向前移动 13 位。因为移动的位数是可能的 26 个字符的一半，所以对文本再次执行这个算法，就恢复到了它最初的形式。可以使用如下命令：</p>
<pre><code>#加密
echo ‘shiyanlou’ |  tr  ‘a-zA-Z’  ‘n-za-mN-ZA-M’ 
fuvlnaybh
#解密
echo ‘fuvlnaybh’ | tr  ‘a-zA-Z’  ‘n-za-mN-ZA-M’ 
shiyanlou
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid369time1420780277727" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（九）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>comm</strong>,<strong>diff</strong>,<strong>patch</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##comm命令<br>通常比较文本文件的内容很有帮助。对于系统管理员和软件开发者来说，这个尤为重要。一名系统管理员可能，例如，需要拿现有的配置文件与先前的版本做比较，来诊断一个系统错误。同样的，一名程序员经常需要查看程序的修改。</p>
<p>comm命令将逐行比较已经排序的两个文件。显示结果包括3列：第1列为只在第一个文件中找到的行，第2列为只在第二个文件中找到的行，第3列为两个文件的共有行。</p>
<p>注意，comm命令和join、uniq命令一样，只能用于已经排过序的数据。</p>
<p>###命令格式：<br>comm  [选项] 文件1  文件2</p>
<p>###常用参数：</p>
<ul>
<li>-1     不输出文件1特有的行</li>
<li>-2     不输出文件2特有的行</li>
<li>-3   不输出两个文件共有的行</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>比较file1.txt和file2.txt两个文件的内容，可以使用如下命令：</p>
<pre><code>comm  file1.txt  file2.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid371time1420781783879" alt="img"></p>
<p><strong>例二：</strong>比较file1.txt和file2.txt两个文件的内容，只显示两个文件共有的内容，可以使用如下命令：</p>
<pre><code>comm  -12 file1.txt  file2.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid371time1420781829807" alt="img"></p>
<p>##diff命令<br>类似comm 命令，diff命令被用来监测文件之间的差异。然而，diff 是一款更加复杂的工具，它支持许多输出格式，并且一次能处理许多文本文件。软件开发员经常使用 diff 程序来检查不同程序源码版本之间的更改，diff 能够递归地检查源码目录，经常称之为源码树。diff 程序的一个常见用例是创建 diff 文件或者补丁，它会被其它程序使用，例如 patch 程序（我们后面会讲到），来把文件从一个版本转换为另一个版本。</p>
<p>diff在命令行中打印每一个行的改动，并且diff是svn、cvs、git等版本控制工具不可或缺的一部分。</p>
<p>diff命令是differential的缩写。</p>
<p>###命令格式：<br>diff  [选项]  文件</p>
<p>###常用参数：</p>
<ul>
<li>-c       上下文模式，显示全部内文，并标出不同之处</li>
<li>-u         统一模式，以合并的方式来显示文件内容的不同</li>
<li>-a      只会逐行比较文本文件</li>
<li>-N        在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录。            若使用-N参数，则diff会将文件A与一个空白的文件比较</li>
<li>-r       递归比较目录下的文件</li>
</ul>
<p>###常用范例：<br>例一：显示file1.txt和file2.txt两个文件的差异，可以使用如下命令：</p>
<pre><code>diff  file1.txt  file2.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid371time1420781912223" alt="img"></p>
<p>上面结果显示中的“1d0”表示file1.txt文件比file2.txt文件多了第一行，“4c3,4”表示file1.txt文件的第四行和file2.txt文件的第三、四行不同。</p>
<p>diff 的normal 显示格式有三种提示:</p>
<ul>
<li>a - add</li>
<li>c - change</li>
<li>d - delete </li>
</ul>
<p><strong>例二：</strong>从上面例一的显示结果可以知道，file1.txt和file2.txt两个文件的差异不易直观看出，可以使用上下文模式显示，可以使用如下命令：</p>
<pre><code>diff  -c file1.txt  file2.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid371time1420781985260" alt="img"></p>
<p>这个输出结果以两个文件名和它们的时间戳开头。第一个文件用星号做标记，第二个文件用短横线做标记。纵观列表的其它部分，这些标记将象征它们各自代表的文件。</p>
<p><code>*** 1,4 *** 表示第一个文件中第一行到第四行的文本行。</code></p>
<p><code>--- 1,4 --- 表示第二个文件中第一行到第四行的文本行。</code></p>
<p>三种特殊字符：</p>
<p>＋ 添加行，这一行将会出现在第二个文件内，而不是第一个文件内</p>
<p>－ 删除行，这一行将会出现在第一个文件中，而不是第二个文件内</p>
<p>！ 更改行，将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分</p>
<p>这些特殊字符很容易混淆，实际上记住一点就行：<strong>所有操作目的是将第一个文件变成第二个文件</strong>。</p>
<p><strong>例三：</strong>查看file1.txt和file2.txt两个文件的差异，使用统一模式显示，可以使用如下命令：</p>
<pre><code>diff  -u file1.txt  file2.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid371time1420782103081" alt="img"></p>
<p>上下文模式和统一模式之间最显著的差异就是重复上下文的消除，这就使得统一模式的输出结果要比上下文模式的输出结果简短。</p>
<p>@@  -1,4 +1,4 @@ 表示在在更改组中描述的第一个文件中的文本行和第二个文件中的文本行。</p>
<p>特殊字符：</p>
<ul>
<li>＋ 添加这一行到第一个文件中</li>
<li>－ 在第一个文件中删除这一行</li>
</ul>
<p>##patch命令<br>patch 命令被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本。让我们考虑一个著名的例子。Linux 内核是由一个大型的，组织松散的贡献者团队开发而成，这些贡献者会提交固定的少量更改到源码包中。这个 Linux 内核由几百万行代码组成，虽然每个贡献者每次所做的修改相当少。对于一个贡献者来说，每做一个修改就给每个开发者发送整个的内核源码树，这是没有任何意义的。相反，提交一个 diff 文件。一个 diff 文件包含先前的内核版本与带有贡献者修改的新版本之间的差异。然后一个接受者使用 patch 程序，把这些更改应用到他自己的源码树中。使用 diff/patch 组合提供了两个重大优点：</p>
<ol>
<li><p>一个 diff 文件非常小，与整个源码树的大小相比较而言。</p>
</li>
<li><p>一个 diff 文件简洁地显示了所做的修改，从而允许程序补丁的审阅者能快速地评估它。</p>
</li>
</ol>
<p>当然，diff/patch 能工作于任何文本文件，不仅仅是源码文件。它同样适用于配置文件或任意其它文本。</p>
<p>准备一个 diff 文件供 patch 命令使用，GNU 文档建议这样使用 diff 命令：</p>
<p><code>diff  -Naur old_file new_file &gt; diff_file</code></p>
<p>old file 和 new file 部分不是单个文件就是包含文件的目录。这个 r 选项支持递归目录树。</p>
<p>###命令格式：<br>diff  [选项]  补丁文件</p>
<p>###常用参数：</p>
<ul>
<li>-p num  忽略几层文件夹</li>
<li>-E         如果发现了空文件，那么就删除它</li>
<li>-R      取消打过的补丁</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>生成file1.txt和file2.txt的diff文件，然后应用patch命令更新file1.txt文件，可以使用如下命令：</p>
<pre><code>diff  -Naur file1.txt  file2.txt &gt; patchdiff.txt
patch &lt; patchdiff.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid371time1420782242319" alt="img"></p>
<p><strong>例二：</strong>取消上面例一打过的补丁，可以使用如下命令：</p>
<pre><code>patch -R &lt; patchdiff.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid371time1420782287649" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（五）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>find</strong>,<strong>xargs</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##find命令（一）</p>
<p>find命令主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。Linux下find命令提供了相当多的查找条件，功能很强大，对应的学习难度也比较大。</p>
<p>###命令格式：<br>find [选项] [搜索路径] [表达式]</p>
<p>默认路径是当前目录，默认表达式为-print。</p>
<p>表达式可能由下列成份组成：操作符、选项、测试表达式以及动作。</p>
<p>###常用参数：</p>
<ul>
<li>-print         find命令将匹配的文件输出到标准输出</li>
<li>-exec         find命令对匹配的文件执行该参数所给出的shell命令</li>
<li>-name          按照文件名查找文件</li>
<li>-type          查找某一类型的文件</li>
<li>-prune          使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略</li>
<li>-user           按照文件属主来查找文件</li>
<li>-group          按照文件所属的组来查找文件</li>
<li>-mtime -n +n     按照文件的更改时间来查找文件，-n表示文件更改时间距现在小于n    天，+n表示文件更改时间距现在大于n天，find命令还有-atime和                    -ctime选项</li>
</ul>
<p>其他命令命令选项及表达式可参见下图。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485012419" alt="img"></p>
<p>###常用范例：<br><strong>例一：</strong>打印当前目录下的文件目录列表 ，可以使用如下命令：</p>
<pre><code>find  .  -print
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485049983" alt="img"></p>
<p><strong>例二：</strong>打印当前目录下所有以.txt结尾的文件名 ，可以使用如下命令（截图只显示部分）：</p>
<pre><code>find  .  -name “*.txt” -print
</code></pre><p>-iname选项跟-name选项作用一样，不同在于-iname会忽略字母大小写。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485125680" alt="img"></p>
<p><strong>例三：</strong>打印当前目录下所有以.txt或.pdf结尾的文件名 ，可以使用如下命令（截图只显示部分）：</p>
<pre><code>find  .  \(-name “*.pdf” -or -name “*.txt”\)
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485200246" alt="img"></p>
<p><strong>例四：</strong>打印当前目录下所有<strong>不</strong>以.txt结尾的文件名 ，可以使用如下命令：</p>
<pre><code>find  .  ! -name “*.txt”
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485266187" alt="img"></p>
<p>##find命令（二）</p>
<p>下面将介绍如何根据文件类型、权限、所有者及操作符来查找匹配文件。</p>
<p>根据文件类型来查找文件，使用-type选项，常见find文件类型见下表。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485465186" alt="img"></p>
<p>根据文件权限查找文件，使用-perm选项。所有者使用-user选项。</p>
<p>另外，find命令可以通过逻辑操作符来创建更复杂的逻辑关系，例如find命令（一）中的例三就使用了操作符-or。find命令的逻辑操作符见下表。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485513603" alt="img"></p>
<p>###常用范例：<br><strong>例一：</strong>打印当前目录下所有以.txt结尾的符号链接 ，可以使用如下命令：</p>
<pre><code>find  .  -type l -name “*.txt” -print
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485577965" alt="img"></p>
<p><strong>例二：</strong>打印当前目录下所有权限为777的php文件（web服务器上的php文件一般需要执行权限），可以使用如下命令：</p>
<p>find  .  -type f -name “*.php” -perm 777</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485634144" alt="img"></p>
<p><strong>例三：</strong>打印当前目录下root用户拥有的所有文件，可以使用如下命令：</p>
<pre><code>find  .  -type f -user root
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485682625" alt="img"></p>
<p><strong>例四：</strong>打印当前目录下权限不是777和664的所有文件，可以使用如下命令：</p>
<pre><code>find  .  -type f  \( ! -perm 777  -and  ! -perm 644 \)
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485725524" alt="img"></p>
<p>##find命令（三）</p>
<p>下面将介绍如何使用find命令的-exec选项来实现对查找到的文件执行指定的动作命令。</p>
<p>###常用范例：<br><strong>例一：</strong>找到当前目录下所有php文件，并显示其详细信息，可以使用如下命令：</p>
<pre><code>find . -name “*.php” -exec ls -l {} \;
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485834752" alt="img"></p>
<p>-exec是find命令对找到的文件执行的动作，这个动作就是对找到的文件执行命令，上面的命令就是ls -l {}。在这里说明一下{}和\;，{}其实它就是一个占位符，在find命令的执行过程中会不断地替换成当前找到的文件，相当于”ls -l 找到的文件”。而\;是-exec的命令结束标记，因为规定-exec后面的命令必须以;结束，但;在shell中有特殊含义，必须要转义，所以写成\;。</p>
<p><strong>例二：</strong>在实验楼环境中有很多自己编写的c语言代码文件，现在想要把所有c语言代码文件下载下来，如果一个一个的下载很麻烦，我们可以先查找到所有的c语言代码文件，然后将这些文件内容写入到一个文件中，下载该文件，可以使用如下命令：</p>
<pre><code>find . -name “*.c” -exec cat {} \; &amp;gt; all.c
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419485908149" alt="img"></p>
<p><strong>例三：</strong>默认下，-exec后面只能使用单个命令，如果想要多个命令，可以将多个命令写入脚本文件中，然后在-exec中使用这个脚本，可以使用如下命令：</p>
<pre><code>find . -name “*.c” -exec ./command.sh {} \;
</code></pre><p>脚本内容：</p>
<pre><code>#！ /bin/bash
ls -l $1       # $1表示第一个参数
cat $1
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419486194690" alt="img"></p>
<p>##xargs命令</p>
<p>我们可以用管道将一个命令的stdout（标准输出）重定向到另一个命令的stdin（标准输入）。但有些命令只能以命令行参数的形式接收数据，而无法通过stdin接收数据流。在这种情况下，无法通过管道将数据重定向给这些命令。</p>
<p>这时xargs就可以发挥它的作用了，xargs命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表。</p>
<p>###命令格式：<br>command  | xargs [选项] [command]</p>
<p>xargs命令应该紧跟在管道操作符之后，因为它以标准输入作为主要的源数据流。</p>
<p>###常用参数：</p>
<ul>
<li>-n      指定每行最大的参数数量</li>
<li>-d      指定分隔符</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>将多行输入转换为单行输出，可以使用如下命令：</p>
<pre><code>cat a.txt | xargs
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419486436814" alt="img"></p>
<p><strong>例二：</strong>将单行输入转换为多行输出，可以使用如下命令：</p>
<pre><code>echo “1 2 3 4 5 6 7” | xargs -n 3
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419486477811" alt="img"></p>
<p><strong>例三：</strong>将单行输入转换为多行输出，指定分隔符为i，可以使用如下命令：</p>
<pre><code>cat b.txt | xargs -d i -n 3
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419486635856" alt="img"></p>
<p><strong>例四：</strong>查找当前目录下所有c代码文件，统计总行数，可以使用如下命令：</p>
<pre><code>find . -type f -name “*.c” | xargs wc -l
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid348time1419486674638" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（二）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>mkdir</strong>,<strong>rm</strong>,<strong>mv</strong>,<strong>cp</strong>,<strong>cat</strong>,<strong>nl</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##mkdir命令<br>mkdir 命令用来创建指定名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。<br>mkdir 命令是make directory的缩写。</p>
<p>###命令格式：<br>mkdir [选项] 目录</p>
<p>###常用参数：<br>    -m   –mode=模式，设定权限&lt;模式&gt;;<br>    -p   –parents  可以是一个路径名称。若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录<br>    -v   –verbose  每次创建新目录都显示信息</p>
<p>###常用范例：<br><strong>例一：</strong>递归创建多个目录 ，可以使用如下命令：</p>
<pre><code>mkdir  -p  zhou/test
</code></pre><p><strong>例二：</strong>创建权限为777的目录，可以使用如下命令：</p>
<pre><code>mkdir  -m 777  zhou
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux12.jpg" alt="Alt text"></p>
<p><strong>例三：</strong>创建目录显示信息，可以使用如下命令：</p>
<pre><code>mkdir  -vp  zhou/test
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux13.jpg" alt="Alt text"></p>
<p>##rm命令<br>rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。</p>
<p>rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</p>
<p>rm命令是remove的缩写。</p>
<p>###命令格式：<br>rm [选项] 文件或目录</p>
<p>###常用参数：<br>     -f  –force             忽略不存在的文件，从不给出提示<br>     -i  –interactive   进行交互式删除<br>     -r  –recursive        指示rm将参数中列出的全部目录和子目录均递归地删除<br>     -v  –verbose           详细显示进行的步骤    </p>
<p>###常用范例：<br><strong>例一：</strong>删除文件，系统会先询问是否删除，可以使用如下命令：</p>
<pre><code>rm  shiyanlou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux14.jpg" alt="Alt text"></p>
<p><strong>例二：</strong>强行删除文件，系统不再提示，可以使用如下命令：</p>
<pre><code>rm  -f  shiyanlou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux15.jpg" alt="Alt text"></p>
<p><strong>例三：</strong>删除后缀名为.log的所有，删除前逐一询问，可以使用如下命令：</p>
<pre><code>rm   *.log   或   rm -i *.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux16.jpg" alt="Alt text"></p>
<p>##mv命令<br>mv命令功能是用来移动文件或更改文件名，是Linux系统下常用的命令，经常用来备份文件或者目录。<br>mv命令根据第二个参数类型（是目标文件还是目标目录），决定执行将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。<br>mv命令是move的缩写。</p>
<p>###命令格式：<br>mv [选项] 源文件或目录 目标文件或目录 </p>
<p>###常用参数：</p>
<pre><code>-b  --back                 若需覆盖文件，则覆盖前先行备份 
-f  --force                   如果目标文件已经存在，不会询问而直接覆盖
-i --interactive         若目标文件已经存在时，就会询问是否覆盖
-u --update             若目标文件已经存在，且源文件比较新，才会更新
-t  --target            该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后
</code></pre><p>###常用范例：<br><strong>例一：</strong>将文件shiyanlou.log重命名为zhou.log，可以使用如下命令：</p>
<pre><code>mv   shiyanlou.log   zhou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux17.jpg" alt="Alt text"></p>
<p><strong>例二：</strong>将文件zhou.log移动到test目录下(test目录必须已经存在，否则执行重命名)，可以使用如下命令：</p>
<pre><code>mv  zhou.log  test
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux18.jpg" alt="Alt text"></p>
<p><img src="http://anything-about-doc.qiniudn.com/linux19.jpg" alt="Alt text"></p>
<p><strong>例三：</strong>将文件a.txt移动到test1目录下，如果文件存在，覆盖前会询问是否覆盖，可以使用如下命令：</p>
<pre><code>mv  -i  a.txt  test1
</code></pre><p>##cp 命令<br>cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。<br>cp命令是copy的缩写。<br><strong>命令格式：</strong><br>cp [选项]  源文件  目录<br>cp [选项]  -t  目录  源文件<br><strong>常用参数：</strong></p>
<pre><code>-t   --target-directory         指定目标目录
-i   --interactive              覆盖前询问(使前面的 -n 选项失效)
-n   --no-clobber               不要覆盖已存在的文件(使前面的 -i 选项失效)
-s   --symbolic-link              对源文件建立符号链接，而非复制文件
-f   --force                    强行复制文件或目录， 不论目的文件或目录是否已经存在
-u   --update                   使用这项参数之后，只会在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件
</code></pre><p><strong>常用范例：</strong><br><strong>例一：</strong>对文件shiyanlou.log建立一个符号链接zhou.log，可以使用如下命令：</p>
<pre><code>cp   -s   shiyanlou.log   zhou.log
</code></pre><p><strong>例二：</strong>将test1目录下的所有文件复制到test2目录下，覆盖前询问，可以使用如下命令：</p>
<pre><code>cp  -i  test1/*  test2
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux21.png" alt="Alt text"></p>
<p><strong>例三：</strong>将test1目录下的最近更新的文件复制到test2目录下，覆盖前询问，可以使用如下命令：</p>
<pre><code>cp  -iu  test1/*  test2
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux22.png" alt="Alt text"></p>
<p>##cat命令<br>cat命令的功能是将文件或标准输入组合输出到标准输出。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。<br>cat命令是concatenate的缩写。</p>
<p>###命令格式：<br>cat  [选项]   [文件] </p>
<p>###常用参数：</p>
<pre><code>-A  --show-all           等价于 -vET    
-b  --number-nonblank    对非空输出行编号    
-e                       等价于 -vE    
-E  --show-ends          在每行结束处显示 $    
-n  --number             对输出的所有行编号,由1开始对所有输出的行数编号    
-s  --squeeze-blank      有连续两行以上的空白行，就代换为一行的空白行     
-t                       与 -vT 等价   
-T  --show-tabs          将跳格字符显示为 ^I   
-u                       (被忽略)   
-v  --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外  
</code></pre><p>###常用范例：<br><strong>例一：</strong>把shiyanlou.log的文件内容加上行号后输入zhou.log这个文件里，可以使用如下命令：</p>
<pre><code>cat -n shiyanlou.log &amp;gt; zhou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux23.png" alt="Alt text"></p>
<p><strong>例二：</strong>把shiyanlou.log的文件内容加上行号后输入zhou.log这个文件里，多行空行换成一行输出，可以使用如下命令：</p>
<pre><code>cat -ns shiyanlou.log &amp;gt; zhou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux24.png" alt="Alt text"></p>
<p><strong>例三：</strong>将zhou.log的文件内容反向显示，可以使用如下命令：</p>
<pre><code>tac  zhou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux25.png" alt="Alt text"></p>
<p>说明：tac 是将 cat 反写过来，所以它的功能就跟 cat 相反，cat 是由第一行到最后一行连续显示在屏幕上，而 tac 则是由最后一行到第一行反向在屏幕上显示出来。</p>
<p>##nl命令<br>nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号。其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。<br>nl命令是number of lines的缩写。</p>
<p>###命令格式：<br>nl  [选项]   [文件]</p>
<p>###常用参数：</p>
<pre><code>-b          指定行号指定的方式，主要有两种：
-b a     表示不论是否为空行，也同样列出行号(类似 cat -n)
-b t     如果有空行，空的那一行不要列出行号(默认值)
-n          列出行号表示的方法，主要有三种：
-n ln     行号在屏幕的最左方显示
-n rn     行号在自己栏位的最右方显示，且不加 0 
-n rz     行号在自己栏位的最右方显示，且加 0 
-w          行号栏位的占用的位数
</code></pre><p>###常用范例：<br>例一：把shiyanlou.log的文件内容加上行号后显示，空行不加行号，可以使用如下命令：</p>
<pre><code>nl -b t shiyanlou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux27.png" alt="Alt text"></p>
<p>例二：把shiyanlou.log的文件内容加上行号后显示，行号分别在屏幕最左方、最右方不加0和最右方加0显示，可以使用如下命令：</p>
<pre><code>nl -n ln shiyanlou.log
nl -n rn shiyanlou.log
nl -n rz shiyanlou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux28.png" alt="Alt text"></p>
<p><strong>例三：</strong>把shiyanlou.log的文件内容加上行号后显示，行号在屏幕最右方加0显示，行号栏目占位数为3，可以使用如下命令：</p>
<pre><code>nl -n rz -w 3 shiyanlou.log
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linux29.png" alt="Alt text"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（八）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>sort</strong>,<strong>uniq</strong>,<strong>join</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##sort命令<br>同文本文件打交道时，总避不开排序，那是因为对于文本处理任务而言，排序（sort）可以起到不小的作用。sort命令能够帮助我们对文本文件和stdin进行排序操作。通常，它会结合其他命令来生成所需要的输出。</p>
<p>##命令格式：<br>sort [选项] [文件名]</p>
<p>###常用参数：</p>
<ul>
<li>-n         基于字符串的长度来排序,使用此选项允许根据数字值排序，而不是字母值</li>
<li>-k         指定排序关键字</li>
<li>-b        默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致sort             程序忽略每行开头的空格，从第一个非空白字符开始排序</li>
<li>-m        只合并多个输入文件</li>
<li>-r      按相反顺序排序,结果按照降序排列，而不是升序</li>
<li>-t         自定义分隔符，默认为制表符</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>列出/usr/share/目录下使用空间最多的前10个目录文件，可以使用如下命令：</p>
<pre><code>du -s /usr/share/* | sort -nr | head -10

du -s /usr/share/* 命令显示/usr/share/目录下所有文件和目录的磁盘使用空间，目录包含目录下的子目录和文件
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420780699046" alt="img"></p>
<p><strong>例二：</strong>ls命令能显示目录下文件的详细信息，包含空间使用大小，但与du命令不同的是，ls命令不计算目录下的子目录和文件的大小。ls显示格式如下:</p>
<pre><code>-rwxrwxrwx   1  root   root  542  11月   29  test.php
</code></pre><p>现在想要对ls命令输出信息中的空间使用大小字段进行排序，可以使用如下命令：</p>
<pre><code>ls -l /usr/bin/ | sort -nr -k 5 | head -10
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420780744468" alt="img"></p>
<p><strong>例三：</strong>首先来看下下面的例子：</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420780803123" alt="img"><br>由于11由1开始，比5大，所以排在5的前面。这时排序可以通过自定义排序字段来排序。使用下面的命令就可以解决。</p>
<pre><code>sort  -k 1,1  -k 2n data.txt
</code></pre><p>第一个-k选项指明只对第一个字段排序，1,1意味着“始于并且结束于第一个字段”。<br>第二个-k选项2n表示对第二个字段按数值排序。<br>还有一种格式，如-k 3.4，表示始于第三个字段的第四个字符，按数值排序。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420780839828" alt="img"></p>
<p>-k选项的语法格式如下：</p>
<p>[ FStart [ .CStart ] ] [ Modifier ] [ , [ FEnd [ .CEnd ] ][ Modifier ] ]</p>
<p>这个语法格式可以被其中的逗号（“，”）分为两大部分，Start部分和End部分。</p>
<p>先给你灌输一个思想，那就是“如果不设定End部分，那么就认为End被设定为行尾”。这个概念很重要的，但往往你不会重视它。</p>
<p>Start部分也由三部分组成，其中的Modifier部分就是类似n和r的选项部分。我们重点说说Start部分的FStart和CStart。<br>FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算“排序首字符”。CStart是可以省略的，省略的话就表示从本域的开头部分开始。之前例子中的-k 5就是省略了CStart的例子。</p>
<p>同理，在End部分中，你可以设定FEnd.CEnd，如果你省略.CEnd，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。</p>
<p>##uniq命令<br>uniq 命令经常和sort命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。</p>
<p><strong>uniq只能用于排过序的数据输入</strong>，因此，uniq要么使用管道，要么将排过序的文件作为输入，并总是以这种方式与sort命令结合起来使用。</p>
<p>uniq命令是unique的缩写。</p>
<p>###命令格式：<br>uniq [选项] [文件名]</p>
<p>###常用参数：</p>
<ul>
<li>-c         在每行前加上表示相应行目出现次数的前缀编号</li>
<li>-d         只输出重复的行</li>
<li>-u        只显示唯一的行</li>
<li>-D        显示所有重复的行</li>
<li>-f         比较时跳过前n列</li>
<li>-i         在比较的时候不区分大小写</li>
<li>-s        比较时跳过前n个字符</li>
<li>-w        对每行第n 个字符以后的内容不作对照</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>找出/bin目录和/usr/bin目录下所有相同的命令，可以使用如下命令：</p>
<pre><code>ls /bin /usr/bin  | sort | uniq -d
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420781011797" alt="img"></p>
<p><strong>例二：</strong>现有文件内容如下，红色方框里的内容表示区号，现在要统计出各个区号的总人数。<br><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420781055838" alt="img"></p>
<p>实现思路：首先按区号对每行信息排序，然后使用uniq命令对区号进行重复行统计。使用命令如下：</p>
<pre><code>sort -k 4.1n,4.1n student.txt | uniq -c -f 3 -w 2
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420781089813" alt="img"></p>
<p>sort -k 4.1n,4.1n表示对第四个字段的第一个字符按数值排序。</p>
<p>uniq -c -f 3 -w 2中-f 3表示跳过前三列的比较，那么现在只剩下最后一列，-w 2表示第2个字符后的内容不做比较，为什么是2呢，因为跳过前三列时并没有跳过最后一列前面的空格分隔符，区号前都还有一个空格。</p>
<p>##join命令<br>join 命令类似于 paste，它会往文件中添加列，但是它使用了独特的方法来完成。一个 join 操作通常与关系型数据库有关联，在关系型数据库中来自多个享有共同关键域的表格的数据结合起来，得到一个期望的结果。这个 join 命令执行相同的操作，它把来自于多个基于共享关键域的文件的数据结合起来。</p>
<p>通俗地说，就是将两个文件中指定栏位相同的行连接起来，即按照两个文件中共同拥有的某一列，将对应的行拼接成一行。</p>
<p>###命令格式：<br>join  [选项] 文件1  文件2</p>
<p>###常用参数：</p>
<ul>
<li>-j FIELD       等同于 -1 FIELD -2 FIELD,-j指定一个域作为匹配字段</li>
<li>-1 FIELD     以file1中FIELD字段进行匹配</li>
<li>-2 FIELD     以file2中FIELD字段进行匹配</li>
<li>-t             自定义分隔符，默认为制表符</li>
</ul>
<p>###常用范例：<br>例一：将两个文件中的第一个字段作为匹配字段，连接两个文件，可以使用如下命令：</p>
<pre><code>join  a.txt  b.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420781241207" alt="img"></p>
<p><strong>例二：</strong>指定两个文件的第三个字段为匹配字段，连接两个文件，可以使用如下命令：</p>
<pre><code>join  -1 3 -2 3 c.txt d.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid370time1420781274456" alt="img"></p>
<p>从上面的结果可以看到，一开始对a.txt和b.txt文件内容执行join命令时报错，这是因为<strong>join命令跟uniq命令一样，只能用于排过序的数据</strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（六）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>wc</strong>,<strong>grep</strong>,<strong>正则表达式</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##wc命令<br>wc命令是一个统计的工具，主要用来显示文件所包含的行、字和字节数。</p>
<p>wc命令是word  count的缩写。</p>
<p>###命令格式：<br>wc  [选项]  [文件]</p>
<p>###常用参数：</p>
<ul>
<li>-c         统计字节数</li>
<li>-l         统计行数</li>
<li>-m         统计字符数，这个标志不能与 -c 标志一起使用</li>
<li>-w         统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</li>
<li>-L         打印最长行的长度</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>统计文件的字节数、行数、字符数，可以使用如下命令：</p>
<pre><code>wc -c c.txt
wc -l c.txt
wc -m c.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920359258" alt="img"></p>
<p>注意每行结尾的换行符也算一个字符，空格也算一个字符。另外，由于系统采用UTF-8编码，所以一个汉字为3字节，9个汉字加上一个换行，一共28个字节。</p>
<p><strong>例二：</strong>统计文件的字节数、行数、字符数，只打印数字，不打印文件名，可以使用如下命令：</p>
<pre><code>cat c.txt | wc -c 
cat c.txt | wc -l 
cat c.txt | wc -m
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920413153" alt="img"></p>
<p><strong>例三：</strong>统计/bin目录下的命令个数，可以使用如下命令：</p>
<pre><code>ls /bin | wc -l
</code></pre><p>##grep 命令<br>grep是个很强大的命令，用来找到文件中的匹配文本，并且能够接受正则表达式和通配符，同时可以用多个grep命令选项来生成各种格式的输出。</p>
<p>grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p>
<p>grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p>
<p>##命令格式：<br>grep [选项] pattern [file]</p>
<p>##常用参数：</p>
<ul>
<li>-c         计算找到 &#39;搜寻字符串&#39;(即pattern) 的次数</li>
<li>-i         忽略大小写的不同，所以大小写视为相同</li>
<li>-n         输出行号</li>
<li>-v         反向选择，打印不匹配的行</li>
<li>-r      递归搜索</li>
<li>–color=auto     将找到的关键词部分加上颜色显示</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>将/etc/passwd文件中出现root的行取出来，关键词部分加上颜色显示，可以使用如下命令：</p>
<pre><code>grep “root” /etc/passwd --color=auto
cat /etc/passwd | grep “root” --color=auto
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920596878" alt="img"></p>
<p><strong>例二：</strong>将/etc/passwd文件中没有出现root和nologin的行取出来，可以使用如下命令：</p>
<pre><code>grep -v “root” /etc/passwd | grep -v “nologin”
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920644630" alt="img"></p>
<p><strong>例三：</strong>在当前目录下递归搜索文件中包含main()的文件，经常用于查找某些函数位于哪些源代码文件中，可以使用如下命令：</p>
<pre><code>grep -r “main()” . 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920683927" alt="img"></p>
<p>##正则表达式与grep命令<br>正则表达式是一种符号表示法，被用来识别文本模式。在某种程度上，它们与匹配文件和路径名的 shell 通配符比较相似，但其规模更大。许多命令行工具和大多数的编程语言都支持正则表达式，以此来帮助解决文本操作问题。</p>
<p>正则表达式元字符由以下字符组成：</p>
<p>^ $ . [ ] { } - ? * + ( ) | \</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920809160" alt="img"></p>
<p>###常用范例：<br><strong>例一：</strong>利用Linux系统自带的字典查找一个五个字母的单词，第三个字母为j,最后一个字母为r ，/usr/share/dict目录下存放字典文件，可以使用如下命令：</p>
<pre><code>grep ‘^..j.r$’ linux.words
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920858625" alt="img"></p>
<p><strong>例二：</strong>验证固定电话，打印符合条件的电话，固定电话格式基本都是带有0的区号+连接符“-”＋电话号码，另外还有可能有分机号，区号有3位、4位，电话号码有7位和8位的，可以使用如下命令：</p>
<pre><code>grep “^0[0-9]{2,3}-[0-9]{7,8}(-[0-9]{3,4})?$” telphone.txt
</code></pre><p>区号：前面一个0，后面跟2-3位数字 ： 0[0-9]{2,3}</p>
<p>电话号码：7-8位数字： [0-9]{7,8}</p>
<p>分机号：一般都是3-4位数字： [0-9]{3,4}</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920922420" alt="img"></p>
<p>注意执行下面的命令时没有任何匹配输出，这是因为没有加-E选项，那例一没加为什么可以呢，这是因为grep把.当成shell通配符，不是正则表达式的元字符。</p>
<p><img src="http://anything-about-doc.qiniudn.com/userid3372labid353time1419920941988" alt="img"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（四）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>which</strong>,<strong>whereis</strong>,<strong>locate</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##which命令<br>which命令的作用是，在PATH变量指定的路径中搜索可执行文件的所在位置。它一般用来确认系统中是否安装了指定的软件。</p>
<p>###命令格式：<br>which  可执行文件名称</p>
<p>###常用范例：</p>
<p><strong>例一：</strong>确认是否安装了gcc，可以使用如下命令：</p>
<pre><code>which gcc 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linuxcommand/which1.png" alt="Alt text"></p>
<p><strong>例二：</strong>查看cd命令的位置路径，可以使用如下命令：</p>
<pre><code>which cd
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linuxcommand/which2.png" alt="Alt text"></p>
<p>从上面的显示信息可以看到在实验楼的系统中cd是一个shell函数。</p>
<p>再来在我本地linux系统上执行which cd命令，显示的结果如下：</p>
<p><img src="http://anything-about-doc.qiniudn.com/linuxcommand/which3.png" alt="Alt text"></p>
<p>显示在PATH变量指定的路径下没有cd命令。为什么显示没有呢？这是因为cd是shell内建命令，而which 默认是找 PATH 内所指定的目录，内建命令不在其指定的目录中，所以当然一定找不到。</p>
<p>那么就有个问题，为什么实验楼环境中cd是一个shell函数，而其他linux环境中cd是内建命令呢？这跟所使用的bash有关。</p>
<p><img src="http://anything-about-doc.qiniudn.com/linuxcommand/which4.png" alt="Alt text"></p>
<p><img src="http://anything-about-doc.qiniudn.com/linuxcommand/which5.png" alt="Alt text"></p>
<p>echo $SHELL命令查看当前使用的shell。</p>
<p>###补充知识<br>到底什么是命令？</p>
<p>命令可以是下面四种形式之一：</p>
<ol>
<li><p>是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 属于这一类的程序，可以编译成二进制文件，诸如用 C 和 C++语言写成的程序, 也可以是由脚本语言写成的程序，比如说 shell，perl，python，ruby，等等。</p>
</li>
<li><p>是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，上面我本地环境中的cd命令，就是一个 shell 内部命令。</p>
</li>
<li><p>是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 比如上面讲到的cd命令，在实验楼环境中就是一个shell函数。</p>
</li>
<li><p>是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。</p>
</li>
</ol>
<p>##whereis命令<br>whereis命令主要用于定位可执行文件、源代码文件、帮助文件在文件系统中的位置。whereis 命令还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。</p>
<p>whereis命令查找速度非常快，这是因为它根本不是在磁盘中漫无目的乱找，而是在一个数据库中（/var/lib/mlocate/）查询。这个数据库是Linux系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行updatedb命令更新一次。也正是因为这个数据库要每天才更新一次，就会使得whereis命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到。</p>
<p>###命令格式：<br>whereis [选项] 文件</p>
<p>###常用参数：</p>
<ul>
<li><p>-b   定位可执行文件</p>
</li>
<li><p>-m   定位帮助文件</p>
</li>
<li><p>-s   定位源代码文件</p>
</li>
<li><p>-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件</p>
</li>
<li><p>-B   指定搜索可执行文件的路径</p>
</li>
<li><p>-M   指定搜索帮助文件的路径</p>
</li>
<li><p>-S   指定搜索源代码文件的路径</p>
</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>搜索gcc可执行文件的路径，可以使用如下命令：</p>
<pre><code>whereis -b gcc
</code></pre><p><strong>例二：</strong>搜索gcc帮助文件的路径，可以使用如下命令：</p>
<pre><code>whereis -m gcc 
</code></pre><p><strong>例三：</strong>搜索gcc源代码的路径，可以使用如下命令：</p>
<pre><code>whereis -s gcc 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linuxcommand/whereis1.png" alt="Alt text"></p>
<p>##locate命令<br>locate 命令跟whereis命令类似，且它们使用的是相同的数据库。但whereis命令只能搜索可执行文件、联机帮助文件盒源代码文件，如果要获得更全面的搜索结果，可以使用locate命令。</p>
<p>locate命令使用了十分复杂的匹配语法，可以使用特殊字元（如’*’和’?’）来指定需要查找的样本。</p>
<p>###命令格式：<br>locate [选项] [搜索字符串]</p>
<p>###常用参数：</p>
<ul>
<li>-q      安静模式，不会显示任何错误讯息</li>
<li>-n     至多显示n个输出</li>
<li>-r     使用正规表达式做寻找的条件</li>
<li>-V     显示版本讯息</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>搜索etc目录下所有以sh开头的文件，可以使用如下命令：</p>
<pre><code>locate /etc/sh
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linuxcommand/locate1.png" alt="Alt text"></p>
<p>注意在实验楼环境中一开始执行这个命令会报错：locate 无法执行 <code>stat() ‘/var/lib/mlocate/mlocate.db’</code>：没有那个文件或目录。解决办法是执行<code>sudo updatedb</code>命令。</p>
<p><strong>例二：</strong>搜索etc目录下文件名包含lou的文件，可以使用如下命令：</p>
<pre><code>locate /etc/*lou*
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/linuxcommand/locate2.png" alt="Alt text"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Longest Consecutive Sequence]]></title>
      <url>http://codeinterviews.com/Longest-Consecutive-Sequence/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Longest Consecutive Sequence</p>
<blockquote>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given <code>[100, 4, 200, 1, 3, 2]</code>,<br>The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.</p>
<p>Your algorithm should run in O(n) complexity.  </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是要求出最长的整数连续串。我们先说说简单直接的思路，就是先排序，然后做一次扫描，记录当前连续串长度，如果连续串中断，则比较是否为当前最长连续串，并且把当前串长度置0。这样时间复杂度是很明确，就是排序的复杂度加上一次线性扫描。如果不用特殊的线性排序算法，复杂度就是O(nlogn)。<br>其实这个题看起来是数字处理，排序的问题，但是如果要达到好的时间复杂度，还得从图的角度来考虑。思路是把这些数字看成图的顶点，而边就是他相邻的数字，然后进行深度优先搜索。通俗一点说就是先把数字放到一个集合中，拿到一个数字，就往其两边搜索，得到包含这个数字的最长串，并且把用过的数字从集合中移除（因为连续的关系，一个数字不会出现在两个串中）。最后比较当前串是不是比当前最大串要长，是则更新。如此继续直到集合为空。如果我们用HashSet来存储数字，则可以认为访问时间是常量的，那么算法需要一次扫描来建立集合，第二次扫描来找出最长串，所以复杂度是O(2*n)=O(n)，空间复杂度是集合的大小，即O(n)   </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;Integer&gt;();<span class="comment">//存放num的值</span></span><br><span class="line">		<span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)</span><br><span class="line">			set.add(num[i]);</span><br><span class="line">		<span class="keyword">while</span>(!set.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			Iterator it = set.iterator();</span><br><span class="line">			<span class="keyword">int</span> item=(Integer)it.next();<span class="comment">//获取一个元素</span></span><br><span class="line">			set.remove(item);<span class="comment">//需要将这个元素删除</span></span><br><span class="line">			<span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> i=item-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(set.contains(i)) <span class="comment">//向下求连续串的长度</span></span><br><span class="line">			&#123;</span><br><span class="line">				len++;</span><br><span class="line">				set.remove(i);</span><br><span class="line">				i--;</span><br><span class="line">			&#125;</span><br><span class="line">			i=item+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(set.contains(i)) <span class="comment">//向上求连续串的长度</span></span><br><span class="line">			&#123;</span><br><span class="line">				len++;</span><br><span class="line">				set.remove(i);</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(len&gt;res)</span><br><span class="line">				res=len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux操作命令（十）]]></title>
      <url>http://codeinterviews.com/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>该节主要讲解<strong>df</strong>,<strong>du</strong>,<strong>time</strong> 命令。</p>
<p>这里对linux常用的命令进行整理，以便日后查看。<br>–来自实验楼。</p>
<a id="more"></a>
<p>##df命令<br>linux中df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>df命令是disk free的缩写。</p>
<p>###命令格式：<br>df [选项]  文件</p>
<p>###常用参数：</p>
<ul>
<li>-a                         全部文件系统列表</li>
<li>-h                         方便阅读方式显示</li>
<li>-i                         显示inode信息</li>
<li>-T                         文件系统类型</li>
<li>-t&lt;文件系统类型&gt;         只显示选定文件系统的磁盘信息</li>
<li>-x&lt;文件系统类型&gt;         不显示选定文件系统的磁盘信息</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>显示磁盘使用情况，可以使用如下命令：</p>
<pre><code>df
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740116614" alt="img"></p>
<p> <strong>例二：</strong>以inode模式来显示磁盘使用情况，可以使用如下命令：</p>
<pre><code>df  -i
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740127431" alt="img"></p>
<p><strong>例三：</strong>列出文件系统的类型，可以使用如下命令：</p>
<pre><code>df  -T
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740135464" alt="img"></p>
<p><strong>例四：</strong>显示指定类型磁盘，可以使用如下命令：</p>
<pre><code>df  -t ext4
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740147180" alt="img"></p>
<p>##du命令<br>linux中du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看。</p>
<p>du命令是disk usage的缩写。</p>
<p>###命令格式：<br>du  [选项]  文件</p>
<p>###常用参数：</p>
<ul>
<li>-a      显示目录中个别文件的大小。   </li>
<li>-b         显示目录或文件大小时，以byte为单位。   </li>
<li>-c         除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 </li>
<li>-k        以KB(1024bytes)为单位输出。</li>
<li>-m         以MB为单位输出。   </li>
<li>-s        仅显示总计，只列出最后加总的值。</li>
<li>-h        以K，M，G为单位，提高信息的可读性</li>
</ul>
<p>###常用范例：<br><strong>例一：</strong>显示指定文件所占空间，以方便阅读的格式显示，可以使用如下命令：</p>
<pre><code>du  -h  file1.txt 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740343106" alt="img"></p>
<p><strong>例二：</strong>显示指定目录所占空间，以方便阅读的格式显示，可以使用如下命令：</p>
<pre><code>du  -h  Desktop 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740370569" alt="img"></p>
<p><strong>例三：</strong>显示几个文件或目录各自占用磁盘空间的大小，并且统计总和，使用如下命令：</p>
<pre><code>du  -ch file1.txt file2.txt
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740386138" alt="img"></p>
<p><strong>例四：</strong>按照空间大小逆序排序显示，使用如下命令：</p>
<pre><code>du  -h  | sort -nr | head -10
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740400752" alt="img"></p>
<p>##time命令<br>time命令常用于测量一个命令的运行时间，包括实际使用时间（real time）、用户态使用时间（the process spent in user mode）、内核态使用时间（the process spent in kernel mode）。</p>
<p>实际时间: 从command命令行开始执行到运行终止的时间。</p>
<p>用户态使用时间：命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和。</p>
<p>内核态使用时间：命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和。</p>
<p>###命令格式：<br>time 命令</p>
<p>###常用范例：<br><strong>例一：</strong>测量date命令运行的时间，可以使用如下命令：</p>
<pre><code>time date 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740854918" alt="img"></p>
<p>从上面的结果可以到：实际运行时间为0.05s，用户cpu时间为0.001s，系统cpu时间为0.001s。</p>
<p>其中，用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。</p>
<p><strong>例二：</strong>将time命令的执行结果保存到文件中，可以使用如下命令：</p>
<pre><code>{ time date; } 2&gt;1.txt
(time date) 2&gt;2.txt 
</code></pre><p><img src="http://anything-about-doc.qiniudn.com/userid3372labid393time1421740877117" alt="img"></p>
<p>time是shell的关键字，shell做了特殊处理，它会把time命令后面的命令行作为一个整体来进行处理，在重定向时，实际上是针对后面的命令来的，time命令本身的输出并不会被重定向的。比如，执行time date 2&gt;3.txt，3.txt内容为空。另外，time命令的输出信息是打印在标准错误输出上的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Longest Valid Parentheses]]></title>
      <url>http://codeinterviews.com/Longest-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Longest Valid Parentheses </p>
<blockquote>
<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For <code>&quot;(()&quot;</code>, the longest valid parentheses substring is <code>&quot;()&quot;</code>, which has length = 2.</p>
<p>Another example is <code>&quot;)()())&quot;</code>, where the longest valid parentheses substring is <code>&quot;()()&quot;</code>, which has length = 4.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是求最长的括号序列，比较容易想到用栈这个数据结构。<br>基本思路就是维护一个栈，遇到左括号就进栈，遇到右括号则出栈，并且判断当前合法序列是否为最长序列。不过这道题看似思路简单，但是有许多比较刁钻的测试集。具体来说，主要问题就是遇到右括号时如何判断当前的合法序列的长度。 </p>
<pre><code>比较健壮的方式如下：
(1) 如果当前栈为空，则说明加上当前右括号没有合法序列（有也是之前判断过的）；
(2) 否则弹出栈顶元素，如果弹出后栈为空，则说明当前括号匹配，我们会维护一个合法开始的起点start，合法序列的长度即为当前元素的位置-start+1；否则如果栈内仍有元素，则当前合法序列的长度为当前栈顶元素的位置下一位到当前元素的距离，因为栈顶元素后面的括号对肯定是合法的，而且左括号出过栈了。
</code></pre><p>因为只需要一遍扫描，算法的时间复杂度是O(n)，空间复杂度是栈的空间，最坏情况是都是左括号，所以是O(n)。</p>
<p>当然使用DP也可以解答，不过时间复杂度略高，解题如下：</p>
<pre><code>用longestValid[i][j]表示从S串中的字符i到j的最长well-formed表达式的长度；isValid[i][j]表示从i到j是否是一个valid的表达式。
如何判断longestValid[i][j]的取值呢？有下面几种情况：
假定有一个maxlength变量。
1. 如果i=&apos;(&apos; 并且 j=&apos;)&apos;，
    a. 如果j = i+1,那这是一个valid的表达式；
      b. 如果isValid[i+1][j-1]为真，那这也是一个valid表达式；
    c. 对所有在i到j之间的k，如果isValid[i,k]&amp;&amp;isValid[k+1,j]为真，那么这是一个valid表达式，这三种情况maxlength都是i到j的距离；
    d.其他情况，maxlength = longestValid[i][j-1]和 longestValid[i+1][j]比较大的那个。
2. 如果i=&apos;(&apos; 并且 j=&apos;(&apos;, maxlength等于longestValid[i][j-1]。
3. 如果i=&apos;)&apos; 并且 j=&apos;)&apos;, maxlength等于longestValid[i+1][j]。
4. 如果i=&apos;)‘ 并且 j=&apos;(&apos;, maxlength等于longestValid[i+1][j-1].
判断完成后，longestValid[i][j]赋值于maxlength。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(c[i]==<span class="string">'('</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		stack.push(i);</span><br><span class="line">        	&#125;<span class="keyword">else</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(stack.size()==<span class="number">0</span>)</span><br><span class="line">        			start=i+<span class="number">1</span>;</span><br><span class="line">        		<span class="keyword">else</span>&#123;</span><br><span class="line">        			stack.pop();</span><br><span class="line">        			max=stack.size()==<span class="number">0</span>?Math.max(max,i-start+<span class="number">1</span>):Math.max(max,i-stack.peek());</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Map和Reduce阶段内部细节和调节参数]]></title>
      <url>http://codeinterviews.com/Map%E5%92%8CReduce%E9%98%B6%E6%AE%B5%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82%E5%92%8C%E8%B0%83%E8%8A%82%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>##一、实验内容<br>本节介绍Map和Reduce阶段内部细节和调节参数.</p>
<a id="more"></a>
<p>##二、Map阶段内部细节和调节参数</p>
<ul>
<li>Map计算阶段</li>
</ul>
<ol>
<li>如果Reduce number设置为0, Map阶段会直接将结果写入HDFS中。</li>
<li>一般情况下，map包括以下几个阶段：<br>a. read阶段<br>从一个或者多个输入目录中读取输入文件，通过RecordReader，从InputSplit中解析出一个个的&lt; key,value&gt;。<br>b. map阶段<br>执行用户编写的map函数，产生新的&lt; key,value&gt;<br>c. collect阶段<br>OutputCollection.collect函数一般在map函数内部调用，接受新的&lt; key,value&gt;，然后它的内部会调用Partitioner对数据分组，最后数据&lt; key,value,partition&gt;会被写入缓冲区（一般是环形缓冲区)MapOutputBuffer中。<br>d. spill阶段（包含combiner)<br>如果缓冲区写满到一定程度，就会进入spill阶段往本地磁盘上写临时文件。<br>首先会将需要spill的数据按照partition排序，每个partition的数据又按照key进行排序。<br>然后按照partition的增序写到本地磁盘临时output/spillN.out， N表示spill的次数。如果自定义了combiner，就在这个阶段被调用用来对数据再做一次聚集操作。<br>e. merge阶段<br>将所有临时文件合并成一个文件，供reduce阶段使用。</li>
</ol>
<ul>
<li>MapOutputBuffer<br>对于每一个Map，都有一个环形内存buffer用来缓存中间结果，这不仅可以缓存，而且还可以用来排序，被称为MapOutputBuffer, 设置这个buffer大小的配置是<br>io.sort.mb<br>默认值是100MB.<br>一般当buffer被使用到一定比例，就会将Map的中间结果往磁盘上写，这个比例的配置是：<br>io.sort.spill.percent<br>默认值是80%或者0.8.<br>在内存中排序缓存的过程叫做sort，而当超过上面的比例在磁盘上写入中间结果的过程称之为spill.<br>如果能够追踪到sort和spill的状态，就可以通过调整上面两个参数对Map进行优化。<br>MapOutputBuffer内部有二级索引，第一级是对partition在二级索引中的位置建立索引，第二级是对partition内部的key,value在缓存中的位置建立索引。<br>这两级索引所占用的内存大小在整个缓存大小的比例由一个参数来控制：<br>io.sort.record.percent，默认是0.05.</li>
<li>Merge<br>Map的输出结果在combine阶段，最后会将多个spill临时文件合并成一个文件<br>每次并行merge多少个spill文件，有一个配置参数：io.sort.factor。这个参数名称特别奇怪，很容易理解成是collect或者spill阶段的调优。<br>默认为100, 如果文件很多，影响到了merge阶段完成的速度，可以适当调大以减少磁盘I/O。</li>
<li>压缩<br>设置mapred.output.compress为true或者false，可以控制map的输出结果文件变为压缩或者不压缩。<br>同时可以指定压缩格式，用参数mapred.output.compression.codec，可选值为：zipCodec，LzoCodec，BZip2Codec，LzmaCodec<br>选择压缩主要的时机是当磁盘I/O成了瓶颈，而不是CPU计算成瓶颈时。<br>压缩格式的选择也是在压缩时间，CPU利用率和磁盘空间三者间做平衡。</li>
</ul>
<p>其他参数参考官方文档：<br><a href="https://hadoop.apache.org/docs/r1.0.4/mapred-default.html" target="_blank" rel="external">https://hadoop.apache.org/docs/r1.0.4/mapred-default.html</a></p>
<p>##三、Reduce阶段内部细节和调节参数</p>
<ul>
<li>Reduce计算分为若干阶段</li>
</ul>
<ol>
<li>copy(或者叫shuffle)阶段和merge阶段并行<br>之前Map产生的结果被存放在本地磁盘上，这时需要从reduce节点将数据从map节点复制过来。放得下进内存，比较大的则写到本地磁盘。<br>同时，有两个线程对已经获得的内存中和磁盘上的数据进行merge操作。<br>具体细节是：<br>通过RPC调用询问task tracker已经完成的map task列表，shuffle（洗牌）是对所有的task tracker host的洗牌操作，这样可以打乱copy数据的顺序，防止出现网络热点（大量进程读取一个task tracker节点的数据）。<br>可以复制的任务被存放在scheduledCopies中。<br>一旦有了要复制到数据，会启动多个MapOutputCopier线程，通过HTTP GET请求复制数据，如果数据较大，存入磁盘，否则存入缓存。<br>对于缓存中，有线程InMemoryFSMerge线程负责merge，对文件，有LocalFSMerger线程负责merge。<br>因此观察jobtracker会看到map操作还没有完全结束，reduce操作已经开始了，就是进入了copy阶段。</li>
<li>sort阶段和调用reducer的reduce函数的并行<br>sort对Map阶段传来的&lt; key,value&gt; 数据针对key执行归并排序，产生&lt; key, values&gt;<br>用户编写的reduce将上面的&lt; key, values&gt;传递进ruduce函数处理<br>并行的算法提高了程序性能，具体算法以后再探讨。</li>
<li>write<br>将结果写到HDFS上。</li>
</ol>
<ul>
<li>Reduce的调优参数<br>mapred.reduce.parallel.copies 默认是5，表示有多少个并发线程去从task tracker节点复制数据<br>io.sort.factor 又出现了，默认10,仍然指的是并行合并文件的数目<br>mapred.job.shuffle.merge.percent 默认是0.66, 超过66%，就会将开始合并，然后往磁盘上写数据<br>mapred.inmem.merge.threshold 默认是1000，超过这个临界值，就会将开始合并，然后往磁盘上写数据</li>
</ul>
<h2 id="三、结合"><a href="#三、结合" class="headerlink" title="三、结合"></a>三、结合</h2><p>MapReduce中Map阶段主要可分为read阶段、map阶段、collect阶段、spill阶段、merge阶段，Reduce阶段主要可分为copy阶段和merge阶段并行、sort阶段和调用reducer的reduce函数的并行、write阶段，我们可以通过修改一些参数来进行调优。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Majority Element]]></title>
      <url>http://codeinterviews.com/Majority-Element/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Majority Element</p>
<blockquote>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>####Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>首先根据超过一半的这个信息，我们可以知道，如果我们对该数组进行排序，那么第<code>n/2</code>个数就是所求的那个数。</p>
<p>或者我们仔细观察可以看到，这个元素由于超过一半，那么将它与其余的元素进行相互抵消，则剩下的肯定是我们要找的元素，我们在对数组进行遍历的时候，记录次数，如果否元素次数为0，说明前面正好相互抵消，则令当前元素为起始元素。</p>
<p>##算法代码<br>代码采用JAVA实现：<br>方法一：使用排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="keyword">return</span> num[num.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：使用相互抵消，看次数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> nTimes=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> element=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(nTimes==<span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		element=num[i];</span><br><span class="line">        		nTimes++;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		<span class="keyword">if</span>(num[i]==element)</span><br><span class="line">        			nTimes++;</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        			nTimes--;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MapReduce程序日志查看]]></title>
      <url>http://codeinterviews.com/MapReduce%E7%A8%8B%E5%BA%8F%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B/</url>
      <content type="html"><![CDATA[<p>##一、实验内容<br>首先，如果需要打印日志，不需要用log4j这些东西，直接用System.out.println即可，这些输出到stdout的日志信息可以在jobtracker站点最终找到。</p>
<p>其次，如果在main函数启动的时候用System.out.println打印的日志，直接在控制台就可以看到。</p>
<p>再其次，jobtracker站点很重要。</p>
<pre><code>http://localhost:50030
</code></pre><p>注意，在这里看到Map 100%不一定正确，有时候会卡在Map阶段并没有完成，而此时居然显示Map 100%，所以要一层层的点进去，直到看到日志为止。</p>
<p>另外，在cluster summary表格中可以看到map/reduce slots的情况，方便了解集群计算资源。可以写个脚本定时收集slots信息，方便分析出集群高峰和空闲时间段。</p>
<a id="more"></a>
<p>##二、执行流程</p>
<p><img src="http://anything-about-doc.qiniudn.com/mapreduce%2F2.jpg" alt=""></p>
<p>##三、执行原理</p>
<p><img src="http://anything-about-doc.qiniudn.com/mapreduce%2F3.jpg" alt=""></p>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>我们可以访问<a href="http://localhost:50030" target="_blank" rel="external">http://localhost:50030</a> 查看运行详情。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Max Points on a Line]]></title>
      <url>http://codeinterviews.com/Max-Points-on-a-Line/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Max Points on a Line</p>
<blockquote>
<p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<a id="more"></a>
</blockquote>
<p>##解题思路<br>基本思路是这样的， 每次迭代以某一个点为基准， 看后面每一个点跟它构成的直线， 维护一个HashMap， key是跟这个点构成直线的斜率的值， 而value就是该斜率对应的点的数量， 计算它的斜率， 如果已经存在， 那么就多添加一个点， 否则创建新的key。 这里只需要考虑斜率而不用考虑截距是因为所有点都是对应于一个参考点构成的直线， 只要斜率相同就必然在同一直线上。 最后取map中最大的值， 就是通过这个点的所有直线上最多的点的数量。 对于每一个点都做一次这种计算， 并且后面的点不需要看扫描过的点的情况了， 因为如果这条直线是包含最多点的直线并且包含前面的点， 那么前面的点肯定统计过这条直线了。 因此算法总共需要两层循环， 外层进行点的迭代， 内层扫描剩下的点进行统计</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for a point.</span><br><span class="line"> * class Point &#123;</span><br><span class="line"> *     int x;</span><br><span class="line"> *     int y;</span><br><span class="line"> *     Point() &#123; x = 0; y = 0; &#125;</span><br><span class="line"> *     Point(int a, int b) &#123; x = a; y = b; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points==<span class="keyword">null</span> || points.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//对每个节点维护一个HashMap,其中key为斜率，value为在这个斜率上的点数</span></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	HashMap&lt;Double,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Double,Integer&gt;();</span><br><span class="line">        	<span class="keyword">int</span> samenum=<span class="number">0</span>;<span class="comment">//定义相同的节点数</span></span><br><span class="line">        	<span class="keyword">int</span> localmax=<span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">double</span> rado=<span class="number">0.0</span>;</span><br><span class="line">        		<span class="comment">//如果遇到相同的节点，此时需要记录</span></span><br><span class="line">        		<span class="keyword">if</span>(points[i].x==points[j].x &amp;&amp; points[i].y==points[j].y)</span><br><span class="line">        		&#123;	</span><br><span class="line">        			samenum++;</span><br><span class="line">        			<span class="keyword">continue</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">else</span> <span class="keyword">if</span>(points[i].x==points[j].x)</span><br><span class="line">        		&#123;</span><br><span class="line">        			rado=(<span class="keyword">double</span>)Integer.MAX_VALUE;</span><br><span class="line">        		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(points[i].y==points[j].y)</span><br><span class="line">        		&#123;</span><br><span class="line">        			rado=<span class="number">0.0</span>;</span><br><span class="line">        		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        			rado=(<span class="keyword">double</span>)(points[j].y-points[i].y)/(points[j].x-points[i].x);</span><br><span class="line">        		&#125;</span><br><span class="line"></span><br><span class="line">        		<span class="keyword">if</span>(map.containsKey(rado))</span><br><span class="line">        		&#123;</span><br><span class="line">        			map.put(rado,map.get(rado)+<span class="number">1</span>);</span><br><span class="line">        		&#125;<span class="keyword">else</span></span><br><span class="line">        		&#123;</span><br><span class="line">        			map.put(rado,<span class="number">2</span>);  <span class="comment">//包含源节点</span></span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">    		<span class="keyword">for</span>(Integer value:map.values())</span><br><span class="line">    		&#123;</span><br><span class="line">    			localmax=Math.max(localmax,value);</span><br><span class="line">    		&#125;</span><br><span class="line">    		localmax+=samenum;</span><br><span class="line">  			max=Math.max(max,localmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MapReduce快速入门]]></title>
      <url>http://codeinterviews.com/MapReduce%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>##一、MapReduce介绍<br>MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。概念&#34;Map（映射）&#34;和&#34;Reduce（归约）&#34;，和他们的主要思想，都是从函数式编程语言里借来的，还有从矢量编程语言里借来的特性。他极大地方便了编程人员在不会分布式并行编程的情况下，将自己的程序运行在分布式系统上。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p>
<a id="more"></a>
<p>##二、搭建MapReduce工程<br>使用Eclipse创建一个名为MapReduce1的Java Project，在MapReduce1下创建一个名为lib的文件夹，放入hadoop-core-1.2.1.jar（在主文件夹下的Downloads/hadoop-1.2.1文件夹下），并把它添加到Build Path，最后在src下创建一个com.shiyanlou.mapreduce的包。</p>
<p><img src="http://anything-about-doc.qiniudn.com/mapreduce/1.png" alt=""></p>
<p>##三、MapReduce基本流程<br>MapReduce的基本流程是，框架会使用FileInputFormat读取文件，默认会根据文件大小的进行记录拆分，这里拆分器叫做InputSplitter。通过InputSplitter将文件拆成若干块，后面也就有若干个mapper与之对应。</p>
<p>InputSplitter里面使用RecordReader对文件块的记录进行读取，生成key/value的pair，调用mapper的map函数去处理。</p>
<p>当然这些流程中有些可以定制，比如InputSplitter的算法可以修改，RecordReader也是可以定制。</p>
<p>而且还有一个非常有效的方法，可以避免mapper将过多的数据传递给reducer。</p>
<p>比如有个例子都是1, 其实可以先用一个HashMap对key做分组，有则value加1, 无则添加到HashMap中。</p>
<p>最后将分组统计后的key/value数据通过context.write方法发送给reducer，能够大大提高效率。</p>
<p>##四、编写简单mapper<br>现在想从日志中提取数据，部分日志文件如下：</p>
<pre><code>2014-05-10 13:36:40,140307000287,536dbacc4700aab274729cca,login
2014-05-10 13:37:46,140310000378,536dbae74700aab274729ccb,login
2014-05-10 13:39:20,140310000382,536dbb284700aab274729ccd,login
2014-05-10 13:39:31,140331001080,536dbb864700aab274729ccf,login
2014-05-10 13:39:45,140331001105,536dbba04700aab274729cd4,login
2014-05-10 13:39:45,140328000969,536dbba04700aab274729ce4,login
2014-05-10 13:39:45,140408001251,536dbba04700aab274729cd8,login
2014-05-10 13:39:45,140328000991,536dbba04700aab274729ce9,login
2014-05-10 13:39:45,140324000633,536dbba14700aab274729cf5,login
2014-05-10 13:39:45,140331001077,536dbba04700aab274729cdd,login
2014-05-10 13:39:45,140408001242,536dbba04700aab274729cd7,login
2014-05-10 13:39:45,140327000941,536dbba14700aab274729cf1,login
2014-05-10 13:39:45,140408001265,536dbba04700aab274729ce5,login
2014-05-10 13:39:45,140324000673,536dbba04700aab274729cd3,login
2014-05-10 13:39:45,140331001066,536dbba04700aab274729cd5,login
2014-05-10 13:39:45,140408001292,536dbba14700aab274729cee,login
2014-05-10 13:39:45,140328000966,536dbba14700aab274729cec,login
2014-05-10 13:39:45,140312000501,536dbba04700aab274729ce1,login
2014-05-10 13:39:45,140306000216,536dbba14700aab274729d02,login
2014-05-10 13:39:45,140327000856,536dbba04700aab274729ce2,login
2014-05-10 13:39:46,140328000985,536dbba14700aab274729cf7,login
2014-05-10 13:39:46,140306000245,536dbba14700aab274729d0d,login
2014-05-10 13:39:46,140326000797,536dbba14700aab274729cf6,login
2014-05-10 13:39:46,140328000993,536dbba14700aab274729d12,login
2014-05-10 13:39:46,140331001115,536dbba14700aab274729d10,login
2014-05-10 13:39:46,140325000744,536dbba04700aab274729ce0,login
2014-05-10 13:39:46,140328000982,536dbba14700aab274729d0a,login
2014-05-10 13:39:46,140331001063,536dbba04700aab274729ce3,login
2014-05-10 13:39:46,140331001067,536dbba14700aab274729d1c,login
2014-05-10 13:39:46,140401001157,536dbba04700aab274729ce8,login
2014-05-10 13:39:46,140408001216,536dbba14700aab274729cef,login
2014-05-10 13:39:46,140401001174,536dbba14700aab274729d27,login
2014-05-10 13:39:46,140306000215,536dbba04700aab274729cde,login
2014-05-10 13:39:46,140331001064,536dbba04700aab274729cdc,login
2014-05-10 13:39:46,140326000825,536dbba04700aab274729cd9,login
2014-05-10 13:39:46,140408001294,536dbba14700aab274729d0f,login
</code></pre><p>希望将login前面的设备ID取出来，进行数量的统计，最后得到结果。<br>例如：</p>
<pre><code>536dbba04700aab274729cdc    1
536dbba04700aab274729cdd    91
536dbba04700aab274729cde    152
</code></pre><p>我们可以创建一个LogMapper类，该类负责做数据的Map，前两个模板参数用于KeyIn和ValueIn, 后两个模板参数用于KeyOut和ValueOut，都是代表类型。</p>
<p>假定一个&lt; KeyIn， ValueIn&gt;组成一个pair，输入的很多pair在一个组里面, 这些pair被一定的算法Map之后，会变成很多组pair。</p>
<p>官方文档：<a href="http://hadoop.apache.org/docs/r2.4.1/api/org/apache/hadoop/mapreduce/Mapper.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.4.1/api/org/apache/hadoop/mapreduce/Mapper.html</a></p>
<pre><code>Maps input key/value pairs to a set of intermediate key/value pairs.
</code></pre><p>注意，这里的Mapper类用的包是mapreduce，以前有一个老的叫mapred。<br>这里介绍了两者的区别：</p>
<p><a href="http://stackoverflow.com/questions/7598422/is-it-better-to-use-the-mapred-or-the-mapreduce-package-to-create-a-hadoop-job" target="_blank" rel="external">http://stackoverflow.com/questions/7598422/is-it-better-to-use-the-mapred-or-the-mapreduce-package-to-create-a-hadoop-job</a></p>
<p>有两个类LongWritable和IntWritable，用于帮助创建可以Long和Int类型的变量。它们能够帮助将Long和Int的值序列化成字节流，因此都有两个关键方法读入和写出：<br><img src="http://anything-about-doc.qiniudn.com/mapreduce%2F1.jpg" alt=""><br>这个和Hadoop内部RPC调用时采用的序列化算法有关。<br>在com.shiyanlou.mapreduce包下新建一个名为LogMapper的类，代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiyanlou.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable ONE = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		String[] line = value.toString().split(<span class="string">","</span>);</span><br><span class="line">		<span class="keyword">if</span> (line.length == <span class="number">4</span>) &#123;</span><br><span class="line">			String dId = line[<span class="number">2</span>];</span><br><span class="line">			context.write(<span class="keyword">new</span> Text(dId), ONE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个Mapper的子类覆盖了map函数，将字符串用,号拆开后，取出第三个元素作为设备ID, 然后作为key写入context对象。<br>这里value设置为1, 因为后面reduce阶段会简单的求和。</p>
<p>Context类文档参考： <a href="http://hadoop.apache.org/docs/r1.1.1/api/org/apache/hadoop/mapreduce/Mapper.Context.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r1.1.1/api/org/apache/hadoop/mapreduce/Mapper.Context.html</a></p>
<p>write方法不是一般概念的hasmap添加key,value，而是生成一个新的pair对象，里面包含了key和value。 如果多个key相同，也会产生多个pair对象，交给reduce阶段处理。</p>
<p>##六、编写简单reducer<br>Reduce就是做加和统计，在com.shiyanlou.mapreduce包下新建一个名为LogReducer的类，代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiyanlou.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogReducer</span> <span class="keyword">extends</span></span><br><span class="line">		<span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Key key, Iterable&lt;IntWritable&gt; values, Context context)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		result.set(sum);</span><br><span class="line">		context.write(key, result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里框架保证在调用reduce方法之前，相同的key的value已经被放在values中，从而组成一个pair &lt; key, values&gt;，这些pair之间也已经用key做了排序。</p>
<p>参考文档：<a href="https://hadoop.apache.org/docs/stable/api/org/apache/hadoop/mapreduce/Reducer.html" target="_blank" rel="external">https://hadoop.apache.org/docs/stable/api/org/apache/hadoop/mapreduce/Reducer.html</a></p>
<p>迭代遍历values，取出所有的value，都是1, 简单加和。<br>然后结果写入到context中。 注意，这里的context是Reducer包的Context。</p>
<p>最后，在com.shiyanlou.mapreduce包下新建一个名为LogJob的类，将初始环境设置好。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiyanlou.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		Job job = Job.getInstance(conf, <span class="string">"sum_did_from_log_file"</span>);</span><br><span class="line">		job.setJarByClass(LogJob.class);</span><br><span class="line"></span><br><span class="line">		job.setMapperClass(LogMapper.class);</span><br><span class="line">		job.setCombinerClass(LogReducer.class);</span><br><span class="line">		job.setReducerClass(LogReducer.class);</span><br><span class="line"></span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##七、MapReduce例子程序运行<br>在Eclipse中将MapReduce1工程打成jar包，取名为MapReduce1.jar，放到主文件夹下。</p>
<p><img src="http://anything-about-doc.qiniudn.com/mapreduce/2.png" alt=""></p>
<p>接下来进入主文件夹的Downloads/hadoop-1.2.1/bin下，右键打开命令行，首先格式化HDFS：</p>
<pre><code>$ ./hadoop namenode -format
</code></pre><p>然后启动Hadoop所有进程：</p>
<pre><code>$ ./start-all.sh
</code></pre><p>gitclone下来源代码，在主文件夹新建一个input文件夹，把源代码中的log文件放进去，再把input文件夹上传到HDFS：</p>
<pre><code>$ ./hadoop dfs -put ~/input input/
</code></pre><p>同时还要确保output目录不存在，该目录会被MapReduce程序创建，用于存放输出结果：</p>
<pre><code>$ ./hadoop dfs -rmr output
</code></pre><p>运行程序，观察输出结果：</p>
<pre><code>$ ./hadoop jar ~/MapReduce1.jar com.shiyanlou.mapreduce.LogJob input output
</code></pre><p>现在将output目录都复制到本地磁盘，查看结果：</p>
<pre><code>$ ./hadoop dfs -get output/ ~/output
</code></pre><p>然后进入本地output目录查看：</p>
<pre><code>$ cd ~/output
$ ll -alh
$ gedit part-r-00000
</code></pre><p>打开part-r-00000文件，可以看到结果如下：</p>
<pre><code>536dbacc4700aab274729cca    91
536dbae74700aab274729ccb    91
536dbb284700aab274729ccd    91
536dbb864700aab274729ccf    91
536dbba04700aab274729cd3    91
536dbba04700aab274729cd4    91
536dbba04700aab274729cd5    91
536dbba04700aab274729cd7    91
536dbba04700aab274729cd8    91
536dbba04700aab274729cd9    1
536dbba04700aab274729cdc    1
536dbba04700aab274729cdd    91
536dbba04700aab274729cde    152
536dbba04700aab274729ce0    87
536dbba04700aab274729ce1    87
536dbba04700aab274729ce2    87
536dbba04700aab274729ce3    87
536dbba04700aab274729ce4    91
536dbba04700aab274729ce5    91
536dbba04700aab274729ce8    152
536dbba04700aab274729ce9    91
536dbba14700aab274729cec    87
536dbba14700aab274729cee    87
536dbba14700aab274729cef    138
536dbba14700aab274729cf1    91
536dbba14700aab274729cf5    91
536dbba14700aab274729cf6    87
536dbba14700aab274729cf7    87
536dbba14700aab274729d02    87
536dbba14700aab274729d0a    87
536dbba14700aab274729d0d    87
536dbba14700aab274729d0f    1
536dbba14700aab274729d10    87
536dbba14700aab274729d12    87
536dbba14700aab274729d1c    152
536dbba14700aab274729d27    152
</code></pre><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>前面介绍了如何编写一个简单的日志提取程序，读取HDFS input目录下的日志文件，然后提取数据后，最终输出到output目录下。</p>
<p>现在梳理一下主要过程，然后提出新的改进目标。</p>
<ul>
<li>可比较的序列化<br>第一个是序列化，这是各种编程技术中常用的。MapReduce的特别之处在于由于key用来排序，所有它既要支持序列化和反序列化，同时也要支持比较大小的操作。因此通常使用的都是接口WritableComparable&lt; T&gt;，这个接口分别从Writable接口和java.lang.Comparable&lt; T&gt;接口继承。前者负责序列化，实现的就是类似流(stream)的功能，后者负责比较。</li>
<li>MapReduce计算流程<br>这里只是概括的介绍主要步骤：</li>
</ul>
<ol>
<li>通过<strong>InputFormat</strong>读取HDFS目录的日志文件的所有行，进行内容分块。然后每个块都会对应一个mapper</li>
<li>调用每个<strong>Mapper</strong>的map函数， 将内容块的数据按照行变成&lt; key, value&gt;格式，作为参数传递. map函数的代码由程序员自己实现，通常key是数据，value是整数，便于做统计。这样，也就将参数&lt; key, value&gt;改成了另一种符合业务逻辑的&lt; key, value&gt;, 通过Context.write方法写出去，随后会被框架交给Reducer</li>
<li><strong>Partitioner</strong>目前这个程序中没有实现自己的类，只是简单使用了Reducer，后面会增加这部分的说明</li>
<li>框架会根据key进行分组，组成&lt; key, values&gt;对， 调用<strong>Reducer</strong>的reduce函数，函数接受到Mapper传递来的&lt; key, values&gt;后再做统计</li>
<li>输出成什么样的格式文件由<strong>OutputFormat</strong>来控制。<br>注意上面的几个粗体字，就是5大MapReduce组件。每个组件都是我们可以继承的类，然后MapReduce框架通过多态的方式来回调我们的子类实现的方法。</li>
</ol>
<ul>
<li>MapReduce Job的配置<br>有了上面的实现，还需要配置Job，并且在hadoop命令行中提交。<br>配置的话，直接new一个Job类，调用set方法进行相应的设置即可。 Job的父类是JobContext。<br>就在这里可以设置上面的5大组件类，用自己的类来替换。还可以设置Reducer的数量。</li>
</ul>
<h2 id="九-MultipleOutputs使用"><a href="#九-MultipleOutputs使用" class="headerlink" title="九.MultipleOutputs使用"></a>九.MultipleOutputs使用</h2><p>在前面的例子中，输出文件名是默认的：</p>
<pre><code>_logs   part-r-00000    _SUCCESS
</code></pre><p>part-r-00000<br>还有一个_SUCCESS文件标志job运行成功。<br>还有一个目录_logs。</p>
<p>但是实际情况中，我们有时候需要根据情况定制我的输出文件名。</p>
<p>比如我要根据did的值分组，产生不同的输出文件。所有did出现次数在[0, 60)的都输出到a文件中，在[60, 100)的输出到b文件，其他输出到c文件。</p>
<p>这里涉及到的输出类是MultipleOutputs类。下面是介绍如何实现。</p>
<p>复制前面一节的MapReduce1工程，命名为MapReduce2，在LogJob.java文件添加几行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiyanlou.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		Job job = Job.getInstance(conf, <span class="string">"sum_did_from_log_file"</span>);</span><br><span class="line">		job.setJarByClass(LogJob.class);</span><br><span class="line"></span><br><span class="line">		job.setMapperClass(LogMapper.class);</span><br><span class="line">		job.setCombinerClass(LogReducer.class);</span><br><span class="line">		job.setReducerClass(LogReducer.class);</span><br><span class="line"></span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">//添加MultipleOutputs</span></span><br><span class="line">		MultipleOutputs.addNamedOutput(job, <span class="string">"a"</span>, TextOutputFormat.class,Text.class, IntWritable.class);</span><br><span class="line">		MultipleOutputs.addNamedOutput(job, <span class="string">"b"</span>, TextOutputFormat.class,Text.class, IntWritable.class);</span><br><span class="line">		MultipleOutputs.addNamedOutput(job, <span class="string">"c"</span>, TextOutputFormat.class,Text.class, IntWritable.class);</span><br><span class="line"></span><br><span class="line">		FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">		FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MultipleOutputs.addNamedOutput 函数被调用了三次，设置了文件名为a，b和c，最后两个参数分别是output key和output value类型，应该和job.setOutputKeyClass以及job.setOutputValueClass保持一致。<br>最后修改LogReducer类的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiyanlou.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MultipleOutputs outputs;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"enter LogReducer:::setup method"</span>);</span><br><span class="line">		outputs = <span class="keyword">new</span> MultipleOutputs(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">			InterruptedException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"enter LogReducer:::cleanup method"</span>);</span><br><span class="line">		outputs.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"enter LogReducer::reduce method"</span>);</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		result.set(sum);</span><br><span class="line">		System.out.println(<span class="string">"key: "</span> + key.toString() + <span class="string">" sum: "</span>+ sum);</span><br><span class="line">		<span class="keyword">if</span> ((sum &lt; <span class="number">60</span>) &amp;&amp; (sum &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">			outputs.write(<span class="string">"a"</span>, key, sum);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">100</span>) &#123;</span><br><span class="line">			outputs.write(<span class="string">"b"</span>, key, sum);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			outputs.write(<span class="string">"c"</span>, key, sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据相同key(did)sum的结果大小，写入到不同的文件中。运行后观察一下结果（运行步骤跟前一节一样）：</p>
<pre><code>$ ls
a-m-00000  b-m-00000  c-m-00000  _logs  part-r-00000  _SUCCESS
</code></pre><p>打开a-m-00000文件：</p>
<pre><code>536dbba04700aab274729cd9    1
536dbba04700aab274729cdc    1
536dbba14700aab274729d0f    1
</code></pre><p>打开b-m-00000文件：</p>
<pre><code>536dbacc4700aab274729cca    91
536dbae74700aab274729ccb    91
536dbb284700aab274729ccd    91
536dbb864700aab274729ccf    91
536dbba04700aab274729cd3    91
536dbba04700aab274729cd4    91
536dbba04700aab274729cd5    91
536dbba04700aab274729cd7    91
536dbba04700aab274729cd8    91
536dbba04700aab274729cdd    91
536dbba04700aab274729ce0    87
536dbba04700aab274729ce1    87
536dbba04700aab274729ce2    87
536dbba04700aab274729ce3    87
536dbba04700aab274729ce4    91
536dbba04700aab274729ce5    91
536dbba04700aab274729ce9    91
536dbba14700aab274729cec    87
536dbba14700aab274729cee    87
536dbba14700aab274729cf1    91
536dbba14700aab274729cf5    91
536dbba14700aab274729cf6    87
536dbba14700aab274729cf7    87
536dbba14700aab274729d02    87
536dbba14700aab274729d0a    87
536dbba14700aab274729d0d    87
536dbba14700aab274729d10    87
536dbba14700aab274729d12    87
</code></pre><p>打开c-m-00000文件：</p>
<pre><code>536dbba04700aab274729cde    152
536dbba04700aab274729ce8    152
536dbba14700aab274729cef    138
536dbba14700aab274729d1c    152
536dbba14700aab274729d27    152
</code></pre><p>结果正确，使用MultipleOutputs根据sum值对设备ID进行分组成功了。<br>MapReduce仍然会默认生成part文件，不用理会，都是空文件。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Maximal Rectangle]]></title>
      <url>http://codeinterviews.com/Maximal%20Rectangle/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Maximal Rectangle </p>
<blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题的解法灵感来自于<a href="http://pisxw.com/algorithm/Largest-Rectangle-in-Histogram.html" target="_blank" rel="external">Largest Rectangle in Histogram</a>这道题，假设我们把矩阵沿着某一行切下来，然后把切的行作为底面，将自底面往上的矩阵看成一个直方图（histogram）。直方图的中每个项的高度就是从底面行开始往上1的数量。根据<a href="http://pisxw.com/algorithm/Largest-Rectangle-in-Histogram.html" target="_blank" rel="external">Largest Rectangle in Histogram</a>我们就可以求出当前行作为矩阵下边缘的一个最大矩阵。接下来如果对每一行都做一次<a href="http://pisxw.com/algorithm/Largest-Rectangle-in-Histogram.html" target="_blank" rel="external">Largest Rectangle in Histogram</a>，从其中选出最大的矩阵，那么它就是整个矩阵中面积最大的子矩阵。<br>算法的基本思路已经出来了，剩下的就是一些节省时间空间的问题了。<br>我们如何计算某一行为底面时直方图的高度呢？ 如果重新计算，那么每次需要的计算数量就是当前行数乘以列数。然而在这里我们会发现一些动态规划的踪迹，如果我们知道上一行直方图的高度，我们只需要看新加进来的行（底面）上对应的列元素是不是0，如果是，则高度是0，否则则是上一行直方图的高度加1。利用历史信息，我们就可以在线行时间内完成对高度的更新。     </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//以每一行最为低求解最大矩形面积</span></span><br><span class="line">        <span class="keyword">int</span>[] height=<span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> maxrec=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line">        &#123;	</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">				<span class="comment">//对高度进行更新</span></span><br><span class="line">        		<span class="keyword">if</span>(matrix[i][j]==<span class="string">'1'</span>)</span><br><span class="line">	        	&#123;</span><br><span class="line">	        		height[j]+=<span class="number">1</span>;</span><br><span class="line">	        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	        		height[j]=<span class="number">0</span>;</span><br><span class="line">	        	&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	maxrec=Math.max(maxrec,largestRectangleArea(height));      	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxrec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(height.length==<span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> height[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//使用栈来求解每个bar左边高度小于H(bar)的最大的x坐标，记为left</span></span><br><span class="line">        <span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">while</span>(stack.size()!=<span class="number">0</span> &amp;&amp;(height[stack.peek()]&gt;=height[i]))</span><br><span class="line">    		&#123;</span><br><span class="line">    			stack.pop();</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(stack.size()==<span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			left[i]=-<span class="number">1</span>;</span><br><span class="line">    			stack.push(i);</span><br><span class="line">    		&#125;		</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    		&#123;</span><br><span class="line">    			left[i]=stack.peek();</span><br><span class="line">    			stack.push(i);</span><br><span class="line">    		&#125;	</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同理使用栈来求解每个bar右边高度小于H(bar)的最小的x坐标，记为right</span></span><br><span class="line">        <span class="keyword">int</span>[] right=<span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack2=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        stack2.push(height.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=height.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">while</span>(stack2.size()!=<span class="number">0</span> &amp;&amp;(height[stack2.peek()]&gt;=height[i]))</span><br><span class="line">    		&#123;</span><br><span class="line">    			stack2.pop();</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			right[i]=height.length;</span><br><span class="line">    			stack2.push(i);</span><br><span class="line">    		&#125;   			</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    		&#123;</span><br><span class="line">    			right[i]=stack2.peek();</span><br><span class="line">    			stack2.push(i);</span><br><span class="line">    		&#125;	</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//计算每个bar能形成的矩形的面积，并求得一个最大面积</span></span><br><span class="line">    	<span class="keyword">int</span> maxRec=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> rec=(right[i]-left[i]-<span class="number">1</span>)*height[i];</span><br><span class="line">    		maxRec=Math.max(maxRec,rec);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> maxRec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Maximum Gap]]></title>
      <url>http://codeinterviews.com/Maximum-Gap/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Maximum Gap</p>
<blockquote>
<p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Try to solve it in linear time/space.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>
<p>####Credits:<br>Special thanks to @porker2008 for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题首先一定要有“排序”的思想，但是常用的排序算法复杂度至少是O(NlogN)，不满足题意。进一步思考可以得出，这里的“排序”不一定非要“完整排序”，可以只要“部分排序”即可，这可以想到桶排序，只要意识到了桶排序，这道题就解决了一大半。</p>
<p>假设有取值范围为A到B的N个元素，则他们的最大gap不会小于celling[(B - A) / (N - 1)]。<br>让桶的长度len = celling[(B - A) / (N - 1)]，则我们最多会有num = (B - A) / len + 1个桶。<br>对于数组中的任意元素K，我们可以通过计算toc = (K - A) / len轻松的找到它属于哪一个桶，然后我们维护每个桶中的最大值和最小值。<br>由于同一个桶中元素的最大差值是len - 1，所有最后的答案不会是来自同一个桶中的两个元素。<br>对于每一个非空的桶p，找到下一个非空的桶q，然后q.min - p.max就是该问题的潜在的最大值。返回这些值的最大值。           </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">bucket</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		bucket(<span class="keyword">int</span> min,<span class="keyword">int</span> max)&#123;</span><br><span class="line">			<span class="keyword">this</span>.min=min;</span><br><span class="line">			<span class="keyword">this</span>.max=max;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length&lt;<span class="number">2</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxnum=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minnum=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:num)</span><br><span class="line">        &#123;</span><br><span class="line">        	maxnum=Math.max(maxnum,val);</span><br><span class="line">        	minnum=Math.min(minnum,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bucketlen=(<span class="keyword">int</span>)Math.ceil((<span class="keyword">double</span>)(maxnum-minnum)/(num.length-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> bucketnum=(maxnum-minnum)/bucketlen+<span class="number">1</span>;</span><br><span class="line">        bucket[] bucketsum=<span class="keyword">new</span> bucket[bucketnum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketsum.length;i++)</span><br><span class="line">        	bucketsum[i]=<span class="keyword">new</span> bucket(Integer.MAX_VALUE,Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:num)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> index=(val-minnum)/bucketlen;</span><br><span class="line">        	bucketsum[index].min=Math.min(bucketsum[index].min,val);</span><br><span class="line">        	bucketsum[index].max=Math.max(bucketsum[index].max,val);</span><br><span class="line">        	bucketsum[index].count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxdef=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//放置不为空的桶</span></span><br><span class="line">        ArrayList&lt;bucket&gt; arraylist = <span class="keyword">new</span> ArrayList&lt;bucket&gt;();  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bucketsum.length;i++)&#123;  </span><br><span class="line">             <span class="keyword">if</span>(bucketsum[i].count!=<span class="number">0</span>)&#123;  </span><br><span class="line">                    arraylist.add(bucketsum[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求最大间隔</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arraylist.size()-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	</span><br><span class="line">        	maxdef=Math.max(maxdef,Math.abs(arraylist.get(i).max-arraylist.get(i+<span class="number">1</span>).min));</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxdef;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Maximum Product Subarray]]></title>
      <url>http://codeinterviews.com/Maximum-Product-Subarray/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Maximum Product Subarray</p>
<blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array <code>[2,3,-2,4]</code>,<br>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题跟<a href="http://pisxw.com/algorithm/Maximum-Subarray.html" target="_blank" rel="external">Maximum Subarray</a>模型上和思路上都比较类似，还是用一维动态规划中的“局部最优和全局最优法”。这里的区别是维护一个局部最优不足以求得后面的全局最优，这是由于乘法的性质不像加法那样，累加结果只要是正的一定是递增，乘法中有可能现在看起来小的一个负数，后面跟另一个负数相乘就会得到最大的乘积。不过事实上也没有麻烦很多，我们只需要在维护一个局部最大的同时，在维护一个局部最小，这样如果下一个元素遇到负数时，就有可能与这个最小相乘得到当前最大的乘积和，这也是利用乘法的性质得到的。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.length==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> global=A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxlocal=A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minlocal=A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> maxcopy=maxlocal;</span><br><span class="line">        	maxlocal=Math.max(Math.max(maxlocal*A[i],A[i]),minlocal*A[i]);</span><br><span class="line">        	minlocal=Math.min(Math.min(maxcopy*A[i],A[i]),minlocal*A[i]);</span><br><span class="line">        	global=Math.max(global,maxlocal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Maximum Depth of Binary Tree]]></title>
      <url>http://codeinterviews.com/Maximum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Maximum Depth of Binary Tree</p>
<blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是树中求解最大深度的问题，该题可以采用深度优先遍历，然后使用递归求解比较方便，因为整个树的最大深度为左子树和右子树中最大深度中较大的一个+1.因此可以很容易的写出递归代码。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Math.max(maxDepth(root.left),maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Maximum Subarray]]></title>
      <url>http://codeinterviews.com/Maximum-Subarray/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Maximum Subarray</p>
<blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[−2,1,−3,4,−1,2,1,−5,4]</code>,<br>the contiguous subarray <code>[4,−1,2,1]</code> has the largest sum = <code>6</code>.</p>
<p>####More practice:<br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是典型的动态规划求解，可以定义局部最优和全局最优</p>
<pre><code>定义dp[i]:以i为结尾的最大连续字符串之和  局部最优
dp[i]=max(dp[i-1]+A[i],A[i]) //需要考虑dp[i-1]是负的情况，这时候就不需要加上它了

这样遍历之后将会得到所有节点，以其为结尾的最大连续字符串之和。此时可以定义全局最优

定义dpglobal[i]：从0到i节点中最长连续字串之和  全局最优
dpglobal[i]=max(dpglobal[i-1],dp[i]);
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i]表示以i为结尾的最大连续字串之和  局部最优</span></span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[A.length]; </span><br><span class="line">        <span class="comment">//dpglobal[i]表示从0到i节点中最长连续字串之和  全局最优</span></span><br><span class="line">       	<span class="keyword">int</span>[] dpglobal=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">       	dp[<span class="number">0</span>]=A[<span class="number">0</span>];</span><br><span class="line">       	dpglobal[<span class="number">0</span>]=A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	dp[i+<span class="number">1</span>]=Math.max(dp[i]+A[i+<span class="number">1</span>],A[i+<span class="number">1</span>]);</span><br><span class="line">        	dpglobal[i+<span class="number">1</span>]=Math.max(dpglobal[i],dp[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpglobal[A.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Merge Intervals]]></title>
      <url>http://codeinterviews.com/Merge-Intervals/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Merge Intervals</p>
<blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given <code>[1,3],[2,6],[8,10],[15,18]</code>,<br>return <code>[1,6],[8,10],[15,18]</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是合并重叠的时间区间，首先先按照<code>start</code>时间进行排序，然后遍历，如果一个时间段的<code>start</code>时间小于上一时间段的<code>end</code>时间（这里是上一时间段，因为已经按照<code>start</code>时间进行排序了），则合并两个时间段，<code>end</code>时间为两个时间段<code>end</code>中最大的那个。</p>
<p>下面举一个例子：</p>
<pre><code>定义t1=[start1,end1],t2=[start2,end2]
按start排序后，使得start1&lt;=start2

如果start2&lt;end2,则进行合并得到t3=[start1,max(end1,end2)]
否则则不需要合并。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * public class Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() &#123; start = 0; end = 0; &#125;</span><br><span class="line"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    	ArrayList&lt;Interval&gt; res=<span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals==<span class="keyword">null</span> || intervals.size()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//对interval以start进行排序</span></span><br><span class="line">        Collections.sort(intervals, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">	      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">	          Interval in1=(Interval)o1;</span><br><span class="line">	          Interval in2=(Interval)o2;</span><br><span class="line">	          <span class="keyword">if</span>(in1.start&gt;in2.start)</span><br><span class="line">	                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	          <span class="keyword">else</span>&#123;</span><br><span class="line">	          	<span class="keyword">if</span>(in1.start==in2.start)</span><br><span class="line">	                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	               <span class="keyword">else</span></span><br><span class="line">	                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	          &#125;</span><br><span class="line">	      &#125;</span><br><span class="line">   		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历进行合并判断</span></span><br><span class="line">        res.add(intervals.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(intervals.get(i).start&lt;=res.get(res.size()-<span class="number">1</span>).end)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">int</span> start=res.get(res.size()-<span class="number">1</span>).start;</span><br><span class="line">        		<span class="keyword">int</span> end=Math.max(res.get(res.size()-<span class="number">1</span>).end,intervals.get(i).end);</span><br><span class="line">        		res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">        		res.add(<span class="keyword">new</span> Interval(start,end));</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		res.add(intervals.get(i));</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Merge Sorted Array]]></title>
      <url>http://codeinterviews.com/Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Merge Sorted Array </p>
<blockquote>
<p>Given two sorted integer arrays A and B, merge B into A as one sorted array.</p>
<p><strong>Note</strong>:<br>You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与合并两个有序链表<a href="http://pisxw.com/algorithm/Merge-Two-Sorted-Lists.html" target="_blank" rel="external">Merge Two Sorted Lists</a>一样，对每个数组维护一个指针，然后比较指针所指的值，每次迭代中A和B指向的元素大的便加入结果数组中，然后index-1，另一个不动。这里从后往前扫是因为这个题目中结果仍然放在A中，如果从前扫会有覆盖掉未检查的元素的可能性。 </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || B==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index1=m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index3=A.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index1&gt;=<span class="number">0</span> &amp;&amp; index2&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(A[index1]&gt;B[index2])</span><br><span class="line">        	&#123;</span><br><span class="line">        		A[index3]=A[index1];</span><br><span class="line">        		index3--;</span><br><span class="line">        		index1--;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		A[index3]=B[index2];</span><br><span class="line">        		index3--;</span><br><span class="line">        		index2--;</span><br><span class="line">        	&#125;	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index2&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	A[index3]=B[index2];</span><br><span class="line">        	index3--;</span><br><span class="line">        	index2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Merge k Sorted Lists]]></title>
      <url>http://codeinterviews.com/Merge-k-Sorted-Lists/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Merge k Sorted Lists</p>
<blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对多个已经排好序的链表进行合并，从而生成最后一个有序的链表。我们知道，对两个链表进行合并是非常简单的，时间复杂度为<code>O(m+n)</code>,<code>m</code>和<code>n</code>分别为两个链表的长度。但是，这里却是对多个链表进行合并，因此我们可以采用<strong>分治算法</strong>进行求解。</p>
<pre><code>分治算法主要分为以下三步：
* 分解（这里可以采用二分）
* 求解（这里无需求解，因为每个链表已经有序）
* 合并（这里为对两个有序链表进行合并）
</code></pre><p>时间复杂度分析：假设总共有k个list，每个list的最大长度是n，那么运行时间满足递推式T(k) = 2T(k/2)+O(n*k)。根据主定理，可以算出算法的总复杂度是O(nklogk)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用分治法求解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(List&lt;ListNode&gt; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=lists.size();</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       	<span class="keyword">return</span> mergeLists(lists,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeLists</span><span class="params">(List&lt;ListNode&gt; lists,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(start==end)</span><br><span class="line">    		<span class="keyword">return</span> lists.get(start);</span><br><span class="line">    	<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">int</span> middle=(end+start)/<span class="number">2</span>; <span class="comment">//分解操作</span></span><br><span class="line">	    	ListNode left=mergeLists(lists,start,middle);</span><br><span class="line">	        ListNode right=mergeLists(lists,middle+<span class="number">1</span>,end);</span><br><span class="line">	        <span class="keyword">return</span> merge(left,right); <span class="comment">//合并操作</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1,ListNode head2)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head1==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> head2;</span><br><span class="line">    	<span class="keyword">if</span>(head2==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> head1;</span><br><span class="line">    	ListNode head3=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    	ListNode p=head1;</span><br><span class="line">    	ListNode q=head2;</span><br><span class="line">    	ListNode r=head3;</span><br><span class="line">    	<span class="keyword">if</span>(p.val&lt;=q.val)&#123;</span><br><span class="line">    		head3.val=p.val;</span><br><span class="line">    		p=p.next;		</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		head3.val=q.val;</span><br><span class="line">    		q=q.next;	</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(p.val&lt;=q.val)&#123;</span><br><span class="line">	    		ListNode m=<span class="keyword">new</span> ListNode(p.val);</span><br><span class="line">	    		r.next=m;</span><br><span class="line">	    		r=m;</span><br><span class="line">	    		p=p.next;		</span><br><span class="line">	    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    		ListNode m=<span class="keyword">new</span> ListNode(q.val);</span><br><span class="line">	    		r.next=m;</span><br><span class="line">	    		r=m;</span><br><span class="line">	    		q=q.next;	</span><br><span class="line">	    	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">    		r.next=p;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		r.next=q;</span><br><span class="line">    	<span class="keyword">return</span> head3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Merge Two Sorted Lists]]></title>
      <url>http://codeinterviews.com/Merge-Two-Sorted-Lists/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Merge Two Sorted Lists</p>
<blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是将两个有序链表进行合并，方法很简单，只要对每个链表维持一个指针，然后比较大小，进行链表的链接操作就行了，该题是<a href="http://pisxw.com/algorithm/Merge-k-Sorted-Lists.html" target="_blank" rel="external">Merge k Sorted Lists</a>这题的子过程。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode l3=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p=l1;</span><br><span class="line">        ListNode q=l2;</span><br><span class="line">        ListNode k=l3;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span> &amp;&amp; q!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(p.val&lt;=q.val)</span><br><span class="line">        	&#123;</span><br><span class="line">        		k.next=p;</span><br><span class="line">        		p=p.next;</span><br><span class="line">        		k=k.next;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		k.next=q;</span><br><span class="line">        		q=q.next;</span><br><span class="line">        		k=k.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">        	k.next=p;</span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="keyword">null</span>)</span><br><span class="line">        	k.next=q;</span><br><span class="line">        <span class="keyword">return</span> l3.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Minimum Depth of Binary Tree]]></title>
      <url>http://codeinterviews.com/Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Minimum Depth of Binary Tree</p>
<blockquote>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Maximum-Depth-of-Binary-Tree.html" target="_blank" rel="external">Maximum Depth of Binary Tree</a>的解题思路非常类似，但是在条件方面有一些区别。因为求得是最小深度，当遇到子树为空的情况下，该子树就不应该为考虑。因此条件可以分为如下5种：</p>
<pre><code>1. 该树为一个空树，则其最小深度为0；
2. 该树不为空且其左右子树都不为空，则最小深度为左子树最小深度和右子树最小深度中较小的那一个+1；
3. 该树不为空，但是其左子树为空，右子树不为空，则最小深度为右子树的最小深度+1；
4. 该树不为空，但是其左子树不为空，右子树为空，则最小深度为左子树的最小深度+1；
5. 该树不为空，但是其左子树和右子树都为空，则最小深度为1；
</code></pre><p>根据上述的5种条件，可以判断一棵树的最小深度，然后在采用<strong>递归</strong>的方式进行求解即可。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这与求一个树的最大深度类似，依旧采用递归的方法</span></span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果为空树，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果两个子树都不为空</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span> &amp;&amp; root.right!=<span class="keyword">null</span>)</span><br><span class="line">			num=<span class="number">1</span>+Math.min(minDepth(root.left),minDepth(root.right));</span><br><span class="line">		<span class="comment">//如果左子树为空，右子树不为空</span></span><br><span class="line">		<span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right!=<span class="keyword">null</span>)</span><br><span class="line">			num=<span class="number">1</span>+minDepth(root.right);</span><br><span class="line">		<span class="comment">//如果左子树不为空，右子树为空</span></span><br><span class="line">		<span class="keyword">if</span>(root.left!=<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)</span><br><span class="line">			num=<span class="number">1</span>+minDepth(root.left);</span><br><span class="line">		<span class="comment">//如果两个子树都为空</span></span><br><span class="line">		<span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)</span><br><span class="line">			num=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Minimum Size Subarray Sum]]></title>
      <url>http://codeinterviews.com/Minimum-Size-Subarray-Sum/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Minimum Size Subarray Sum</p>
<blockquote>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p>
<p>click to show more practice.</p>
<p>#####More practice:<br>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</p>
<p>#####Credits:<br>Special thanks to @Freezen for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解和大于目标值的最小长度，比较容易想到的方法是采用滑动窗口的方法，满足滑动窗口中的元素和大于目标元素，且维护一个最小长度值，但是这种方法需要遍历一遍数组，整个时间复杂度为<code>O(n)</code>。</p>
<p>有没有更加快速的方法，其实是有的，我们可以通过一个数组sum,sum[i]记录从0到i-1的所有元素之和，思路就是记录每个位置上到当前位置前面的和：sum[i] 为0-&gt;i-1的所有数字和，如果sum[i]&gt;= 目标数字，就2分查找比sum[i]-target+1小且是最大的数字。如果找到，index=j那么j到i-1就是这个subarray， length=i-1-j+1=i-j。整体的时间复杂度能够达到<code>O(nlogn)</code><br>。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度为O(n)的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//采用滑动窗口的方法</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span> || nums==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>,cursum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(tail&lt;nums.length)</span><br><span class="line">        &#123;</span><br><span class="line">        	cursum+=nums[tail];</span><br><span class="line">        	<span class="keyword">while</span>(cursum&gt;=s)&#123;</span><br><span class="line">        		min=Math.min(min,tail-head+<span class="number">1</span>);</span><br><span class="line">        		cursum-=nums[head];</span><br><span class="line">        		head++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	tail++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==Integer.MAX_VALUE?<span class="number">0</span>:min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度为O(nlogn)的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(nums.length==<span class="number">0</span> || nums==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="comment">//定义一个sum数组，其中存放当前位置之前的左右元素之和</span></span><br><span class="line">	    <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">	    <span class="keyword">int</span>[] sum=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	sum[i+<span class="number">1</span>]=sum[i]+nums[i];</span><br><span class="line">	    	<span class="keyword">if</span>(sum[i+<span class="number">1</span>]&gt;=s)&#123;</span><br><span class="line">	    		<span class="keyword">int</span> j=binarySearch(<span class="number">0</span>,i,sum[i+<span class="number">1</span>]-s+<span class="number">1</span>,sum);</span><br><span class="line">	    		<span class="keyword">if</span>(j&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">	    			min=Math.min(min,i-j+<span class="number">1</span>);</span><br><span class="line">	    		&#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> min==Integer.MAX_VALUE?<span class="number">0</span>:min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target, <span class="keyword">int</span>[] sum)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right-<span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">int</span> m = left + (right-left)/<span class="number">2</span>;  </span><br><span class="line">            <span class="keyword">if</span> (sum[m] &gt;= target) &#123;  </span><br><span class="line">                right = m-<span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum[m] &lt; target) &#123;  </span><br><span class="line">                left = m;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (sum[right] &lt; target) &#123;  </span><br><span class="line">            <span class="keyword">return</span> right;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum[left] &lt; target) &#123;  </span><br><span class="line">            <span class="keyword">return</span> left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Min Stack]]></title>
      <url>http://codeinterviews.com/Min-Stack/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Min Stack</p>
<blockquote>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题实现一个最小栈的问题，这里通过压入每个元素的同时，在压入此时整个栈中的最小值。这样栈里的元素其实是压入元素与当前最小值间的交叉排列。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">	LinkedList&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">    	&#123;</span><br><span class="line">    		stack.push(x);</span><br><span class="line">    		stack.push(x);</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">int</span> min=stack.peek();</span><br><span class="line">    		stack.push(x);</span><br><span class="line">	        <span class="keyword">if</span>(x&gt;min)</span><br><span class="line">	        &#123;</span><br><span class="line">	        	stack.push(min);</span><br><span class="line">	        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	        	stack.push(x);</span><br><span class="line">	        &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		stack.pop();</span><br><span class="line">        	stack.pop();</span><br><span class="line">    	&#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">int</span> num=stack.pop();</span><br><span class="line">	        <span class="keyword">int</span> res=stack.peek();</span><br><span class="line">	        stack.push(num);</span><br><span class="line">	        <span class="keyword">return</span> res;</span><br><span class="line">    	&#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Minimum Path Sum]]></title>
      <url>http://codeinterviews.com/Minimum-Path-Sum/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Minimum Path Sum</p>
<blockquote>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p><strong>Note</strong>: You can only move either down or right at any point in time.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Unique-Paths.html" target="_blank" rel="external">Unique Paths</a>非常类似，不过该题是求一条最短路径。同样采用<strong>动态规划</strong>求解：</p>
<pre><code>定义dp[i][j]:表示从左上点到[i,j]点所有路径中的最小和
由于只能向下和向右移动，所以[i,j]的最小路径只依赖于[i-1,j]和[i,j-1]两个位置
即dp[i][j]=min(dp[i-1][j]，dp[i][j-1])+grid[i][j]
但是第一行和第一列要特殊处理。    
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length;</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">//dp[i][j]表示从左上点到[i,j]点所有路径的最小和</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)  <span class="comment">//初始化第一行</span></span><br><span class="line">        	dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i-<span class="number">1</span>]+grid[<span class="number">0</span>][i]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)  <span class="comment">//初始化第一列</span></span><br><span class="line">        	dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        		dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Minimum Window Substring]]></title>
      <url>http://codeinterviews.com/Minimum-Window-Substring/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Minimum Window Substring</p>
<blockquote>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,<br><strong>S</strong> = <code>&quot;ADOBECODEBANC&quot;</code><br><strong>T</strong> = <code>&quot;ABC&quot;</code><br>Minimum window is <code>&quot;BANC&quot;</code>.    </p>
<p><strong>Note</strong>:<br>If there is no such window in S that covers all characters in T, return the emtpy string <code>&quot;&quot;</code>.    </p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.   </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是字符串处理的题目，和<a href="http://pisxw.com/algorithm/Substring-with-Concatenation-of-All-Words.html" target="_blank" rel="external">Substring with Concatenation of All Words</a>思路非常类似，同样是建立一个字典，然后维护一个窗口，上一题是固定的窗口大小，而这题不是固定的窗口大小，区别是在这道题目中，因为可以跳过没在字典里面的字符，所以遇到没在字典里面的字符可以继续移动窗口右端，而移动窗口左端的条件是当找到满足条件的串之后，一直移动窗口左端直到有字典里的字符不再在窗口里。在实现中就是维护一个HashMap，一开始key包含字典中所有字符，value就是该字符的数量，然后遇到字典中字符时就将对应字符的数量减一。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S==<span class="keyword">null</span> || T==<span class="keyword">null</span> ||S.length()==<span class="number">0</span> ||T.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(S.length()&lt;T.length())</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> tLength=T.length();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Character,Integer&gt;(); <span class="comment">//表示T中的字符是否被包含</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(map.containsKey(T.charAt(i)))  </span><br><span class="line">	        &#123;  </span><br><span class="line">	            map.put(T.charAt(i),map.get(T.charAt(i))+<span class="number">1</span>);  </span><br><span class="line">	        &#125;  </span><br><span class="line">	        <span class="keyword">else</span>  </span><br><span class="line">	        &#123;  </span><br><span class="line">	            map.put(T.charAt(i),<span class="number">1</span>);  </span><br><span class="line">	        &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="keyword">int</span> start=<span class="number">0</span>; <span class="comment">//start ~ end是包含的窗口</span></span><br><span class="line">       	<span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">//对存在T中的字符进行计数</span></span><br><span class="line">       	<span class="keyword">int</span> minstart=<span class="number">0</span>; <span class="comment">//最小窗口的起始位置</span></span><br><span class="line">       	<span class="keyword">int</span> minlen=S.length()+<span class="number">1</span>;<span class="comment">//最小窗口的长度</span></span><br><span class="line">       	<span class="keyword">for</span>(;end&lt;S.length();end++)</span><br><span class="line">       	&#123;</span><br><span class="line">       		<span class="keyword">if</span>(map.containsKey(S.charAt(end)))</span><br><span class="line">       		&#123;</span><br><span class="line">       			map.put(S.charAt(end),map.get(S.charAt(end))-<span class="number">1</span>);</span><br><span class="line">       			<span class="keyword">if</span>(map.get(S.charAt(end))&gt;=<span class="number">0</span>)  </span><br><span class="line">	            &#123;  </span><br><span class="line">	                count++;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            <span class="keyword">while</span>(count==T.length())</span><br><span class="line">	       		&#123;</span><br><span class="line">	       			<span class="keyword">if</span>(end-start+<span class="number">1</span>&lt;minlen)</span><br><span class="line">	       			&#123;</span><br><span class="line">	       				minlen=end-start+<span class="number">1</span>;</span><br><span class="line">	       				minstart=start;</span><br><span class="line">	       			&#125;</span><br><span class="line">	       			<span class="comment">//移动start</span></span><br><span class="line">	       			<span class="keyword">if</span>(map.containsKey(S.charAt(start)))</span><br><span class="line">	       			&#123;</span><br><span class="line">	       				map.put(S.charAt(start),map.get(S.charAt(start))+<span class="number">1</span>);</span><br><span class="line">	       				<span class="keyword">if</span>(map.get(S.charAt(start))&gt;<span class="number">0</span>)  </span><br><span class="line">	                    &#123;  </span><br><span class="line">	                        count--;  </span><br><span class="line">	                    &#125;  </span><br><span class="line">	       			&#125;</span><br><span class="line">	       			start++;</span><br><span class="line">	       		&#125;</span><br><span class="line">       		&#125;</span><br><span class="line">       		</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">if</span>(minlen&gt;S.length())</span><br><span class="line">       		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">       		<span class="keyword">return</span> S.substring(minstart,minstart+minlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-N-Queens II]]></title>
      <url>http://codeinterviews.com/N-Queens-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####N-Queens II</p>
<blockquote>
<p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total number of distinct solutions.</p>
</blockquote>
<p><img src="/img/N-Queens/1.png" alt=""></p>
<a id="more"></a>
<p>##解题思路<br>该题和<a href="http://pisxw.com/algorithm/N-Queens.html" target="_blank" rel="external">N-Queens</a>基本相同，只是最后返回的是解得个数。但是这里需要注意的是:用java写的时候，基本数据类型是<strong>值传递</strong>，因此不能用<code>int</code>来作为递归的结果参数。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//这里不能用int类型</span></span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        helper(n,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">int</span>[n],res);</span><br><span class="line">        <span class="keyword">return</span> res.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//columnForRow 记录每一行中皇后的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> row,<span class="keyword">int</span>[] columnForRow, ArrayList&lt;Integer&gt; res)</span> </span><br><span class="line">    </span>&#123;	</span><br><span class="line">    	<span class="keyword">if</span>(row==n)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> num=res.get(<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">    		res.set(<span class="number">0</span>,num);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			columnForRow[row]=i;</span><br><span class="line">    			<span class="keyword">if</span>(check(row,columnForRow))</span><br><span class="line">		        &#123;</span><br><span class="line">		            helper(n,row+<span class="number">1</span>,columnForRow,res);</span><br><span class="line">		        &#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span>[] columnForRow)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(columnForRow[row]==columnForRow[i] || Math.abs(columnForRow[row]-columnForRow[i])==(row-i))</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MongoDB数据库介绍和基本操作]]></title>
      <url>http://codeinterviews.com/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文主要介绍了mongoDB的基本内容和其一些基本操作。</p>
<a id="more"></a>
<p>##一、mongoDB简介</p>
<p>###1、简介<br>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p>
<p>###2、面向集合的存储<br>MongoDB 中，一个数据库包含多个集合，类似于MySql中一个数据库包含多个表；一个集合包含多个文档，类似于MySql中一个表包含多条数据。</p>
<p>###3、虚拟机开机配置</p>
<p>启动MongoDB服务，因为mongoDB并不随系统一起启动，可能以下命令运行后会等一小段的时间才会启动完毕。</p>
<pre><code>$ sudo service mongodb start
</code></pre><p>进入MongoDB命令行操作界面(可能会出现connect failed，多试几次就行)，在命令行中敲<strong>exit</strong>可以退出</p>
<pre><code>$ mongo
</code></pre><p>实验中的布尔类型的ture用1代替，false用0代替</p>
<p>##二、基本概念</p>
<p>###1、数据库</p>
<ul>
<li>一个mongoDB可以创建多个数据库</li>
<li>使用show dbs可以查看所有数据库的列表</li>
<li>执行db命令则可以查看当前数据库对象或者集合</li>
<li>运行use命令可以连接到指定的数据库</li>
</ul>
<pre><code>$ mongo      #进入到mongo命令行
&gt; use test            #连接到test数据库
</code></pre><p>注意：数据库名可以是任何字符，但是不能有空格、点号和$字符</p>
<p>###2、文档<br>文档是mongoDB的核心，类似于SQLite数据库（关系数据库）中的每一行数据。多个键及其关联的值放在一起就是文档。在mongodb中使用一种类json的bson存储数据，bson数据可以理解为在json的基础上添加了一些json中没有的数据类型。</p>
<p>例：</p>
<pre><code>{&quot;company&quot;:&quot;Chenshi keji&quot;}
</code></pre><p>###3、文档的逻辑联系</p>
<p>假设有两个文档：</p>
<pre><code>{
   &quot;name&quot;: &quot;Tom Hanks&quot;,
   &quot;contact&quot;: &quot;987654321&quot;,
   &quot;dob&quot;: &quot;01-01-1991&quot;
}#user文档

{
   &quot;building&quot;: &quot;22 A, Indiana Apt&quot;,
   &quot;pincode&quot;: 123456,
   &quot;city&quot;: &quot;chengdu&quot;,
   &quot;state&quot;: &quot;sichuan&quot;
}#address文档
</code></pre><p>关系1：嵌入式关系：把address文档嵌入到user文档中</p>
<pre><code>{
   &quot;name&quot;: &quot;Tom Hanks&quot;,
   &quot;contact&quot;: &quot;987654321&quot;,
   &quot;dob&quot;: &quot;01-01-1991&quot;,
   &quot;address&quot;:
   [{
   &quot;building&quot;: &quot;22 A, Indiana Apt&quot;,
   &quot;pincode&quot;: 123456,
   &quot;city&quot;: &quot;chengdu&quot;,
   &quot;state&quot;: &quot;sichuan&quot;
    },
    {
    &quot;building&quot;: &quot;170 A, Acropolis Apt&quot;,
    &quot;pincode&quot;: 456789,
    &quot;city&quot;: &quot;beijing&quot;,
    &quot;state&quot;: &quot;beijing&quot;
    }]
}#这就是嵌入式的关系
</code></pre><p>关系2：引用式关系：将两个文档分开，通过引用文档的_id字段来建立关系</p>
<pre><code>{
   &quot;contact&quot;: &quot;987654321&quot;,
   &quot;dob&quot;: &quot;01-01-1991&quot;,
   &quot;name&quot;: &quot;Tom Benzamin&quot;,
   &quot;address_ids&quot;: [
      ObjectId(&quot;52ffc4a5d85242602e000000&quot;)    #对应address文档的id字段
   ]
}#这就是引用式关系
</code></pre><p>###4、集合<br>集合就是一组文档的组合，就相当于是<strong>关系数据库中的表</strong>，在mongodb中可以存储不同的文档结构的文档<br>例:</p>
<pre><code>{&quot;company&quot;:&quot;Chenshi keji&quot;} {&quot;people&quot;:&quot;man&quot;,&quot;name&quot;:&quot;peter&quot;}
</code></pre><p>上面两个文档就可以存储在同一个集合中</p>
<p>###5. 元数据</p>
<p>数据库的信息存储在集合中，他们统一使用系统的命名空间：DBNAME.system.*<br>DBNAME可用db或数据库名替代</p>
<ul>
<li>DBNAME.system.namespaces ：列出所有名字空间</li>
<li>DBNAME.system.indexs      ：列出所有索引</li>
<li>DBNAME.system.profile      ：列出数据库概要信息</li>
<li>DBNAME.system.users       ：列出访问数据库的用户</li>
<li>DBNAME.system.sources     ：列出服务器信息</li>
</ul>
<p>##三、数据库的创建和销毁</p>
<p>###1、创建数据库<br>启动服务后，进入 MongoDB 命令行操作界面：</p>
<pre><code>$ mongo
</code></pre><p>使用 use 命令创建数据库：</p>
<pre><code>&gt; use mydb
</code></pre><p>查看当前连接的数据库：</p>
<pre><code>&gt; db
</code></pre><p>查看所有的数据库：</p>
<pre><code>&gt; show dbs
</code></pre><p>列出的所有数据库中看不到 mydb或者显示mydb(empty) ，因为 mydb 为空，里面没有任何东西，MongoDB不显示或显示mydb(empty)。</p>
<p>###2、销毁数据库<br>使用 db.dropDatabase() 销毁数据库：</p>
<pre><code>&gt; use local
 switched to db local
&gt; db.dropDatabase()
</code></pre><p>查看所有的数据库：</p>
<pre><code>&gt; show dbs
</code></pre><p>##四、集合（collection）的创建和删除</p>
<p>###1、创建集合<br>在数据库 mydb 中创建一个集合</p>
<pre><code>&gt; use mydb
switched to db test
&gt; db.createCollection(&quot;users&quot;)
</code></pre><p>查看创建的集合：</p>
<pre><code>&gt; show collections
</code></pre><p>###2、删除集合<br>删除集合的方法如下：（删除 users 集合）</p>
<pre><code>&gt; show collections
&gt; db.users.drop()
</code></pre><p>查看是否删除成功：</p>
<pre><code>&gt; show collections
</code></pre><p>##五、向集合中插入数据</p>
<p>###1、使用 insert()<br>插入数据时，如果 users 集合没有创建会自动创建。</p>
<pre><code>&gt; use mydb
switched to db test
&gt; db.users.insert([
... { name : &quot;jam&quot;,
... email : &quot;jam@qq.com&quot;
... },
... { name : &quot;tom&quot;,
... email : &quot;tom@qq.com&quot;
... }
... ])
</code></pre><p>###2、使用 save()<br>插入数据时，如果 users 集合没有创建会自动创建。</p>
<pre><code>&gt; use mydb2
switched to db test
&gt; db.users.save([
... { name : &quot;jam&quot;,
... email : &quot;jam@qq.com&quot;
... },
... { name : &quot;tom&quot;,
... email : &quot;tom@qq.com&quot;
... }
... ])
</code></pre><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>本节介绍了MongoDB和集合的基本操作，在mongodb中使用一种类json的bson存储数据，可以使用use创建和切换数据库，show dbs可以查看有哪些数据库，dropDatabase可以删除数据库，createCollection可以创建集合，show collections可以查看集合，insert()和save()可以插入数据。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Multiply Strings]]></title>
      <url>http://codeinterviews.com/Multiply-Strings/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Multiply Strings</p>
<blockquote>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: The numbers can be arbitrarily large and are non-negative.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题需要知道，<code>m</code>和<code>n</code>位数的乘积，最终结果为<code>m+n-1</code>位或是<code>m+n</code>位(进位时)。乘法计算中可以发现，结果中第<code>i</code>位，应该由第一个字符串中的第<code>1</code>位乘以第二个字符串中的第<code>i</code>位，第一个字符串中的第<code>2</code>位乘以第二个字符串中的第<code>i-1</code>位，…….第一个字符串中的第<code>i</code>位乘以第二个字符串中的第<code>1</code>位,最后累加求得，最后我们取个位上的数值，然后剩下的作为进位放到下一轮循环中。</p>
<p>举个例子：</p>
<pre><code>1000=1*1000 第4位=第1位*第4位
1000=10*100 第4位=第2位*第3位
1000=100*10 第4位=第3位*第2位
1000=1000*1 第4位=第4位*第1位
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1==<span class="keyword">null</span> || num2==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(num1.charAt(<span class="number">0</span>)==<span class="string">'0'</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span>(num2.charAt(<span class="number">0</span>)==<span class="string">'0'</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> num1length=num1.length();</span><br><span class="line">        <span class="keyword">int</span> num2length=num2.length();</span><br><span class="line">        <span class="comment">//分别对两个开始字符串进行转置，便于后面的下标遍历</span></span><br><span class="line">        num1=<span class="keyword">new</span> StringBuilder(num1).reverse().toString();</span><br><span class="line">        num2=<span class="keyword">new</span> StringBuilder(num2).reverse().toString();</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> jinwei=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从低位开始计算，最后乘积的位数为m+n-1,如果进位则是m+n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num1length+num2length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> multi=jinwei;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        	&#123;     		</span><br><span class="line">        		<span class="keyword">if</span>(j&lt;num1length &amp;&amp; (i-j)&lt;num2length)</span><br><span class="line">        		&#123;</span><br><span class="line">        			multi+=(num1.charAt(j)-<span class="string">'0'</span>)*(num2.charAt(i-j)-<span class="string">'0'</span>);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	res.append(multi%<span class="number">10</span>);</span><br><span class="line">        	jinwei=multi/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑最后一位是否有进位</span></span><br><span class="line">        <span class="keyword">if</span>(jinwei!=<span class="number">0</span>)</span><br><span class="line">        	res.append(jinwei);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();   	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-N-Queens]]></title>
      <url>http://codeinterviews.com/N-Queens/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####N-Queens</p>
<blockquote>
<p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>
<p><img src="/img/N-Queens/1.png" alt=""><br>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>For example,</p>
<p>There exist two distinct solutions to the 4-queens puzzle:</p>
<pre><code>[
 [&quot;.Q..&quot;,  // Solution 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // Solution 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>用一个循环递归处理子问题。这个问题中，在每一层递归函数中，我们用一个循环把一个皇后填入对应行的某一列中，如果当前棋盘合法，我们就递归处理先一行，找到正确的棋盘我们就存储到结果集里面。<br>这种题目都是使用这个套路，就是用一个循环去枚举当前所有情况，然后把元素加入，递归，再把元素移除，这道题目中不用移除的原因是我们用一个一维数组去存皇后在对应行的哪一列，因为一行只能有一个皇后，如果二维数组，那么就需要把那一行那一列在递归结束后设回没有皇后，所以道理是一样的。</p>
<p>这道题最后一个细节就是怎么实现检查当前棋盘合法性的问题，因为除了刚加进来的那个皇后，前面都是合法的，我们只需要检查当前行和前面行是否冲突即可。检查是否同列很简单，检查对角线就是行的差和列的差的绝对值不要相等就可以。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> ArrayList&lt;String[]&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        ArrayList&lt;String[]&gt; res = <span class="keyword">new</span> ArrayList&lt;String[]&gt;();</span><br><span class="line">        helper(n,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">int</span>[n], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[] columnForRow, ArrayList&lt;String[]&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)</span><br><span class="line">        &#123;</span><br><span class="line">            String[] item = <span class="keyword">new</span> String[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                StringBuilder strRow = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(columnForRow[i]==j)</span><br><span class="line">                        strRow.append(<span class="string">'Q'</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        strRow.append(<span class="string">'.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                item[i] = strRow.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(item);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            columnForRow[row] = i;</span><br><span class="line">            <span class="keyword">if</span>(check(row,columnForRow))</span><br><span class="line">            &#123;</span><br><span class="line">                helper(n,row+<span class="number">1</span>,columnForRow,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[] columnForRow)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(columnForRow[row]==columnForRow[i] || Math.abs(columnForRow[row]-columnForRow[i])==row-i)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Next Permutation]]></title>
      <url>http://codeinterviews.com/Next-Permutation/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Next Permutation </p>
<blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是找下一个排列的问题。该题需要知道如何进行变换。下面我们用一个例子进行说明：</p>
<pre><code>比如排列是(2,3,6,5,4,1)。
求下一个排列的基本步骤是这样：
    1) 先从后往前找到第一个不是依次增长的数，记录下位置p。比如例子中的3，对应的位置是1;
    2) 接下来分两种情况：
        (1) 如果上面的数字都是依次增长的，那么说明这是最后一个排列，下一个就是第一个，其实把所有数字反转过来即可(比如(6,5,4,3,2,1)下一个是(1,2,3,4,5,6));
          (2) 否则，如果p存在，从p开始往后找，找到下一个数就比p对应的数小的数字，然后两个调换位置，比如例子中的4。调换位置后得到(2,4,6,5,3,1)。最后把p之后的所有数字倒序，比如例子中得到(2,4,1,3,5,6), 这个即是要求的下一个排列。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=num.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(num[i]&lt;num[i+<span class="number">1</span>])</span><br><span class="line">        	&#123;</span><br><span class="line">        		p=i;  <span class="comment">//找到p位置</span></span><br><span class="line">        		<span class="keyword">int</span> j=p+<span class="number">1</span>;</span><br><span class="line">        		<span class="keyword">for</span>(;j&lt;len;j++)</span><br><span class="line">        		&#123;</span><br><span class="line">        			<span class="keyword">if</span>(num[j]&lt;=num[p])</span><br><span class="line">        			&#123;</span><br><span class="line">        				<span class="keyword">break</span>;</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">int</span> temp=num[p];</span><br><span class="line">				num[p]=num[j-<span class="number">1</span>];</span><br><span class="line">				num[j-<span class="number">1</span>]=temp;</span><br><span class="line">				reverse(num,p+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(num,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;     	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> index)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> s=index;</span><br><span class="line">    	<span class="keyword">int</span> e=num.length-<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(s&lt;e)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> temp=num[s];</span><br><span class="line">    		num[s]=num[e];</span><br><span class="line">    		num[e]=temp;</span><br><span class="line">    		s++;</span><br><span class="line">    		e--;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Nth Highest Salary]]></title>
      <url>http://codeinterviews.com/Nth-Highest-Salary/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Nth Highest Salary</p>
<blockquote>
<p>Write a SQL query to get the nth highest salary from the <code>Employee</code> table.</p>
<pre><code>+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
</code></pre><p>For example, given the above Employee table, the nth highest salary where n = 2 is <code>200</code>. If there is no nth highest salary, then the query should return <code>null</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是找到表中第n大的元素，这里通过排序后，使用limit进行选去，这里需要注意的是，如果不加<code>SET M=N-1;</code>,将<code>LIMIT M, 1</code>改为<code>LIMIT N-1, 1</code>则会出错，原因是由于mysql有值的限制，而对预先定义的变量除外，详见<a href="https://oj.leetcode.com/discuss/21320/why-using-limit-n-1-1-will-cause-error" target="_blank" rel="external">Why using LIMIT N-1,1 will cause error</a>。</p>
<p>##算法代码<br>代码采用mysql实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE M INT;</span><br><span class="line">SET M=N-1;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT M, 1</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设置Reducer数目]]></title>
      <url>http://codeinterviews.com/%E8%AE%BE%E7%BD%AEReducer%E6%95%B0%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p>##一、实验内容<br>本篇介绍如何控制reduce的数目。当结果文件很多时，都会发现一般是以part-r-00000 形式出现多个文件，其实这个reducer的数目有关系，reducer数目多，结果文件数目就多。</p>
<a id="more"></a>
<p>在初始化job的时候，是可以设置reducer的数目的。复制一份MapReduce3工程，取名为MapReduce4，</p>
<p>LogJob.java代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiyanlou.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 输入路径</span></span><br><span class="line">		String inputPath = args[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (inputPath.endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			inputPath = inputPath.substring(<span class="number">0</span>, inputPath.length() - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出路径</span></span><br><span class="line">		String outputPath = inputPath + <span class="string">"/output"</span>;</span><br><span class="line">		<span class="comment">// reducer数目</span></span><br><span class="line">		<span class="keyword">int</span> numReducer = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"sum_did_from_log_file"</span>);</span><br><span class="line">		job.setJarByClass(LogJob.class);</span><br><span class="line"></span><br><span class="line">		job.setMapperClass(LogMapper.class);</span><br><span class="line">		job.setReducerClass(LogReducer.class);</span><br><span class="line">		job.setNumReduceTasks(numReducer);</span><br><span class="line"></span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">		Path path1 = <span class="keyword">new</span> Path(inputPath);</span><br><span class="line">		Path path2 = <span class="keyword">new</span> Path(outputPath);</span><br><span class="line"></span><br><span class="line">		removeFolder(path2, conf);</span><br><span class="line"></span><br><span class="line">		MultipleOutputs.addNamedOutput(job, <span class="string">"result"</span>, TextOutputFormat.class,</span><br><span class="line">				Text.class, IntWritable.class);</span><br><span class="line"></span><br><span class="line">		FileInputFormat.addInputPath(job, path1);</span><br><span class="line">		FileOutputFormat.setOutputPath(job, path2);</span><br><span class="line"></span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 清除目录</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> path</span><br><span class="line">	 * <span class="doctag">@param</span> conf</span><br><span class="line">	 * <span class="doctag">@throws</span> IOException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeFolder</span><span class="params">(Path path, Configuration conf)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileSystem fs = path.getFileSystem(conf);</span><br><span class="line">		<span class="keyword">if</span> (fs.exists(path)) &#123;</span><br><span class="line">			fs.delete(path);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果，通过观察jobtracker，的确reducer数目为1了。并且结果文件也变成了只有一个：</p>
<pre><code>./hadoop dfs -ls input/output/
</code></pre><h2 id="二、小结"><a href="#二、小结" class="headerlink" title="二、小结"></a>二、小结</h2><p>MapReduce中可以通过setNumReduceTasks设置Reducer的数目，从而改变结果文件的数目。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Number of 1 Bits]]></title>
      <url>http://codeinterviews.com/Number-of-1-Bits/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Number of 1 Bits</p>
<blockquote>
<p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation <code>00000000000000000000000000001011</code>, so the function should return 3.</p>
<p>####Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判断一个数的二进制中1的个数，我们可以通过不断移位，然后判断最后一个数的思想，分别对每位进行判断，如果为1，则将个数+1。最后即可得到1的总个数。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="keyword">if</span>((n &amp; <span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">	    		res++;</span><br><span class="line">	    	n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Palindrome Partitioning II]]></title>
      <url>http://codeinterviews.com/Palindrome-Partitioning-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Palindrome Partitioning II</p>
<blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = <code>&quot;aab&quot;</code>,<br>Return <code>1</code> since the palindrome partitioning <code>[&quot;aa&quot;,&quot;b&quot;]</code> could be produced using 1 cut.<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题是只需要求得切割的最小次数，并不需要返回结果信息。因此可以采用动态规划的思想进行求解。<br>这道题仍然是动态规划的题目，我们总结一下动态规划题目的基本思路。首先我们要决定要存储什么历史信息以及用什么数据结构来存储信息。然后是最重要的递推式，就是如从存储的历史信息中得到当前步的结果。最后我们需要考虑的就是起始条件的值.<br>我们定义如下：</p>
<pre><code>维护量：dp[i]:表示从第一个字符到第i个字符中切割的最小数。
递推式：这与这i个字符怎么切隔有关，这里设k为切割位置，可以得到以下递推式：
    if(s(k,i)为回文），则 dp[i+1]=min(dp[i+1],dp[k]+1), 0&lt;=k&lt;=i    
这里的起始条件为dp[0]=-1
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> ||s.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isP=isPalindrome(s);</span><br><span class="line">        <span class="comment">//定义维护量</span></span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=-<span class="number">1</span>; <span class="comment">//起始条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	dp[i+<span class="number">1</span>]=i;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=i;k++)</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				<span class="keyword">if</span>(isP[k][i]==<span class="keyword">true</span>)</span><br><span class="line"> 					dp[i+<span class="number">1</span>]=Math.min(dp[i+<span class="number">1</span>],dp[k]+<span class="number">1</span>);</span><br><span class="line"> 			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//得到S所有字串的回文情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[][] isPalindrome(String s)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">boolean</span>[][] res=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">    	<span class="keyword">char</span>[] charS=s.toCharArray();</span><br><span class="line">    	<span class="comment">//单个字符</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;charS.length;i++)</span><br><span class="line">    		res[i][i]=<span class="keyword">true</span>;</span><br><span class="line">    	<span class="comment">//两个字符</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;charS.length-<span class="number">1</span>;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(charS[i]==charS[i+<span class="number">1</span>])</span><br><span class="line">    			res[i][i+<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//三个以上字符</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=charS.length;len++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;charS.length-len+<span class="number">1</span>;i++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>((charS[i]==charS[i+len-<span class="number">1</span>])&amp;&amp;(res[i+<span class="number">1</span>][i+len-<span class="number">1</span>-<span class="number">1</span>]==<span class="keyword">true</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    res[i][i+len-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Number of Islands]]></title>
      <url>http://codeinterviews.com/Number-of-Islands/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Number of Islands</p>
<blockquote>
<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>####Example 1:</p>
<pre><code>11110
11010
11000
00000
</code></pre><p>Answer: 1</p>
<p>####Example 2:</p>
<pre><code>11000
11000
00100
00011
</code></pre><p>Answer: 3</p>
<p>####Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>这道题其实本质上就是统计联通子图的个数，即从一个没有被访问的1出发，进行广度或者深度遍历，肯定能得到一个联通子图，即一个岛，那么通过查看有多少个联通子图即可，这里采用深度优先搜索，但是这里需要判断节点是否访问过。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//使用深度优先搜索</span></span><br><span class="line">        <span class="keyword">int</span> rows=grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(isVisited[i][j]==<span class="keyword">false</span> &amp;&amp; grid[i][j]==<span class="string">'1'</span>)</span><br><span class="line">        		&#123;	</span><br><span class="line">        			helper(grid,i,j,isVisited);</span><br><span class="line">        			res++;</span><br><span class="line">        		&#125;</span><br><span class="line">        			</span><br><span class="line">        	&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">boolean</span>[][] isVisited)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="comment">//四个方面</span></span><br><span class="line">    	isVisited[row][col]=<span class="keyword">true</span>;</span><br><span class="line">    	<span class="comment">//上方</span></span><br><span class="line">		<span class="keyword">if</span>(row&gt;<span class="number">0</span> &amp;&amp; isVisited[row-<span class="number">1</span>][col]==<span class="keyword">false</span> &amp;&amp; grid[row-<span class="number">1</span>][col]==<span class="string">'1'</span>)</span><br><span class="line">			helper(grid,row-<span class="number">1</span>,col,isVisited);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//下方</span></span><br><span class="line">		<span class="keyword">if</span>(row&lt;grid.length-<span class="number">1</span> &amp;&amp; isVisited[row+<span class="number">1</span>][col]==<span class="keyword">false</span> &amp;&amp; grid[row+<span class="number">1</span>][col]==<span class="string">'1'</span>)</span><br><span class="line">			helper(grid,row+<span class="number">1</span>,col,isVisited);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//左方</span></span><br><span class="line">		<span class="keyword">if</span>(col&gt;<span class="number">0</span> &amp;&amp; isVisited[row][col-<span class="number">1</span>]==<span class="keyword">false</span> &amp;&amp; grid[row][col-<span class="number">1</span>]==<span class="string">'1'</span>)</span><br><span class="line">			helper(grid,row,col-<span class="number">1</span>,isVisited);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//右方</span></span><br><span class="line">		<span class="keyword">if</span>(col&lt;grid[<span class="number">0</span>].length-<span class="number">1</span> &amp;&amp; isVisited[row][col+<span class="number">1</span>]==<span class="keyword">false</span> &amp;&amp; grid[row][col+<span class="number">1</span>]==<span class="string">'1'</span>)</span><br><span class="line">			helper(grid,row,col+<span class="number">1</span>,isVisited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Palindrome Partitioning]]></title>
      <url>http://codeinterviews.com/Palindrome-Partitioning/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Palindrome Partitioning</p>
<blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.    </p>
<p>For example, given s = “aab”,<br>Return    </p>
<pre><code>[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题既需要判定每个字串是否为回文串，又要对字符串进行分割，采用循环处理递归子问题的方法，如果当前字串满足回文串，就递归处理字符串剩下的字串，如果到达终点则返回当前结果。</p>
<p>判断字串是否为回文串可以采用<a href="http://pisxw.com/algorithm/leetcode-Longest-Palindromic-Substring.html" target="_blank" rel="external">Longest Palindromic Substring</a>中的动态规划的方法求得是否为回文的字典。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        helper(s,isPalindrome(s),<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;String&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//循环处理子问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">boolean</span>[][] isP,<span class="keyword">int</span> start,ArrayList&lt;String&gt; cur,ArrayList&lt;ArrayList&lt;String&gt;&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(start==s.length())</span><br><span class="line">    	&#123;</span><br><span class="line">    		res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(cur));</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.length();i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(isP[start][i]==<span class="keyword">true</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			cur.add(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">    			helper(s,isP,i+<span class="number">1</span>,cur,res);</span><br><span class="line">    			cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到S所有字串的回文情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[][] isPalindrome(String s)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">boolean</span>[][] res=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">    	<span class="keyword">char</span>[] charS=s.toCharArray();</span><br><span class="line">    	<span class="comment">//单个字符</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;charS.length;i++)</span><br><span class="line">    		res[i][i]=<span class="keyword">true</span>;</span><br><span class="line">    	<span class="comment">//两个字符</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;charS.length-<span class="number">1</span>;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(charS[i]==charS[i+<span class="number">1</span>])</span><br><span class="line">    			res[i][i+<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//三个以上字符</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=charS.length;len++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;charS.length-len+<span class="number">1</span>;i++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>((charS[i]==charS[i+len-<span class="number">1</span>])&amp;&amp;(res[i+<span class="number">1</span>][i+len-<span class="number">1</span>-<span class="number">1</span>]==<span class="keyword">true</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    res[i][i+len-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Partition List]]></title>
      <url>http://codeinterviews.com/Partition-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Partition List </p>
<blockquote>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <code>x = 3</code>,<br>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>本题主要是链表操作，这里为了实现指针的变化，维护两个指针<code>i</code>,<code>j</code>使得<code>i.next==j</code>，让这两个指针一起推进，并用指针<code>k</code>始终指向比<code>x</code>小的元素序中的最后一个元素位置。如果<code>j</code>指的元素比<code>x</code>小，则该元素应该放到<code>k</code>后面。这里只要进行指针指向的变换操作。如果<code>j</code>指的元素比<code>x</code>大，则将<code>i</code>,<code>j</code>往前推进。依次处理直到<code>j==null</code>。</p>
<p>这里有个细节需要判定，当<code>j</code>指的元素比<code>x</code>小时，如果<code>k==i</code>，说明<code>j</code>就是下一个比<code>x</code>小的元素，则不用变换指针操作，直接<code>i=i.next</code>,<code>j=j.next</code>,<code>k=k.next</code>即可。 </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> head;</span><br><span class="line">        ListNode newhead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        newhead.next=head;</span><br><span class="line">        ListNode k=newhead;</span><br><span class="line">        ListNode i=newhead;</span><br><span class="line">        ListNode j=head;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(j.val&gt;=x)</span><br><span class="line">        	&#123;</span><br><span class="line">        		j=j.next;</span><br><span class="line">        		i=i.next;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        		<span class="keyword">if</span>(k==i)&#123;  <span class="comment">//说明j就是下一个比X小的元素</span></span><br><span class="line">	        		i=i.next;</span><br><span class="line">	        		j=j.next;</span><br><span class="line">	        		k=k.next;</span><br><span class="line">	        	&#125;<span class="keyword">else</span>&#123;    <span class="comment">//将j移到k的后面</span></span><br><span class="line">	        		ListNode tmp=j;</span><br><span class="line">	        		i.next=j.next;</span><br><span class="line">	        		j=j.next;</span><br><span class="line">	        		tmp.next=k.next;</span><br><span class="line">	        		k.next=tmp;</span><br><span class="line">	        		k=k.next;</span><br><span class="line">        		&#125;</span><br><span class="line">       		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Path Sum II]]></title>
      <url>http://codeinterviews.com/Path-Sum-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Path Sum II</p>
<blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and <code>sum = 22</code>,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre><p>return</p>
<pre><code>[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题与<a href="http://pisxw.com/algorithm/Path-Sum.html" target="_blank" rel="external">Path Sum</a>的解题思路相同，只不过该题的最终需要把满足条件路径上的每个节点值进行保存。因此该题需要一个递归保存的过程。但是需要注意的是，递归回溯上来的时候要进行清理工作，代码框架与前面写的需要保存递归中间结果的方法都基本类似。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    	ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    	helper(root,sum,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),res);</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum,ArrayList&lt;Integer&gt; cur,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//到达叶子节点且根结点的值等于sum</span></span><br><span class="line">    	<span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; root.val==sum)</span><br><span class="line">    	&#123;</span><br><span class="line">    		cur.add(root.val);</span><br><span class="line">    		res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">    		<span class="comment">//清除操作</span></span><br><span class="line">    		cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//没有到达叶子节点，左子树不为空</span></span><br><span class="line">    	<span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		cur.add(root.val);</span><br><span class="line">			<span class="comment">//对左子树进行递归调用</span></span><br><span class="line">    		helper(root.left,sum-root.val,cur,res);</span><br><span class="line">    		<span class="comment">//返回时，清除操作</span></span><br><span class="line">    		cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">	    <span class="comment">//没有到达叶子节点，右子树不为空</span></span><br><span class="line">    	<span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		cur.add(root.val);</span><br><span class="line">			<span class="comment">//对右子树进行递归调用</span></span><br><span class="line">    		helper(root.right,sum-root.val,cur,res);</span><br><span class="line">    		<span class="comment">//返回时，清除操作</span></span><br><span class="line">    		cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Pascal's Triangle II]]></title>
      <url>http://codeinterviews.com/Pascal's-Triangle-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Pascal’s Triangle II</p>
<blockquote>
<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].    </p>
<p>####Note:<br>Could you optimize your algorithm to use only O(k) extra space?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题跟<a href="http://pisxw.com/algorithm/Pascal&#39;s-Triangle.html" target="_blank" rel="external">Pascal’s Triangle</a>很类似，只是这里只需要求出某一行的结果。<a href="http://pisxw.com/algorithm/Pascal&#39;s-Triangle.html" target="_blank" rel="external">Pascal’s Triangle</a>中因为是求出全部结果，所以我们需要上一行的数据就很自然的可以去取。而这里我们只需要一行数据，就得考虑一下是不是能只用一行的空间来存储结果而不需要额外的来存储上一行呢？这里确实是可以实现的。对于每一行我们知道如果从前往后扫，res[i]=res[i-1]+res[i]， res[i+1]=res[i]+res[i+1]，可以看到res[i]会被覆盖掉。所以这里采取的方法是从后往前扫，res[i]=res[i]+res[i-1]，res[i-1]=res[i-1]+res[i-2],我们需要的数据不会被覆盖，因为需要的res[i]只在当前步用，下一步就不需要了。这个技巧在动态规划省空间时也经常使用，主要就是看我们需要的数据是原来的数据还是新的数据来决定我们遍历的方向。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(rowIndex&lt;<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        res.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=rowIndex;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//从后往前进行求解</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=res.size()-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)  </span><br><span class="line">	        &#123;  </span><br><span class="line">	            res.set(j+<span class="number">1</span>,res.get(j)+res.get(j+<span class="number">1</span>));  </span><br><span class="line">	        &#125;  </span><br><span class="line">	        res.add(<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Path Sum]]></title>
      <url>http://codeinterviews.com/Path-Sum/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Path Sum</p>
<blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and <code>sum = 22</code>,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是树操作的题目，判断是否从根到叶子的路径和跟给定sum相同的。还是用常规的递归方法来做，递归条件是看左子树或者右子树有没有满足条件的路径，也就是子树路径和等于当前sum减去当前节点的值。结束条件是如果当前节点是空的，则返回false，如果是叶子，那么如果剩余的sum等于当前叶子的值，则找到满足条件的路径，返回true。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">   		<span class="comment">//树为空</span></span><br><span class="line">	    <span class="keyword">if</span>(root ==<span class="keyword">null</span>)</span><br><span class="line">	    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    <span class="comment">//已到叶子节点，且满足根结点的值等于sum</span></span><br><span class="line">	    <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; root.val==sum)</span><br><span class="line">	    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	    <span class="comment">//判断左右子树是否有满足sum-root.val值的情况。</span></span><br><span class="line">	    <span class="keyword">return</span> hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Pascal's Triangle]]></title>
      <url>http://codeinterviews.com/Pascal's-Triangle/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Pascal’s Triangle</p>
<blockquote>
<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br>Return</p>
</blockquote>
<pre><code>[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</code></pre><a id="more"></a>
<p>##解题思路<br>该题主要是生成帕斯卡三角形。该题通过找规律可以发现，每一行的首位和末尾都为1，从第二位到第length()-1位，其第i位等于上一层的第i-1位与第i位的和。通过不断顺序生成每一行的数据即可求出结果。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//首先需要放入1</span></span><br><span class="line">        ArrayList&lt;Integer&gt; first=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        first.add(<span class="number">1</span>);</span><br><span class="line">       	res.add(first);</span><br><span class="line">       	<span class="keyword">if</span>(numRows==<span class="number">1</span>);</span><br><span class="line">       		<span class="keyword">return</span> res;</span><br><span class="line">        ArrayList&lt;Integer&gt; cur=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果行数大于1，则从第二行开始计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=numRows-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//第一位为1</span></span><br><span class="line">        	cur=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        	cur.add(<span class="number">1</span>);</span><br><span class="line">        	<span class="comment">//计算中间位置的值</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i-<span class="number">1</span>;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		cur.add(res.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+res.get(i-<span class="number">1</span>).get(j));</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="comment">//最后一位为1</span></span><br><span class="line">        	cur.add(<span class="number">1</span>);</span><br><span class="line">        	res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Permutation Sequence]]></title>
      <url>http://codeinterviews.com/Permutation-Sequence/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Permutation Sequence</p>
<blockquote>
<p>The set <code>[1,2,3,…,n]</code> contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>Given n and k, return the kth permutation sequence.</p>
<p><strong>Note</strong>: Given n will be between 1 and 9 inclusive.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题可以发现如下规律，如果元素个数为<code>n</code>,则相同的其实元素会有<code>(n-1)!</code>种可能，也就是<code>(n-1)!</code>排列后会换一个起始元素，因此只要当前的<code>k</code>进行<code>(n-1)!</code>取余，得到的数字就是当前剩余数组的<code>index</code>，如此就可以得到对应的元素。如此递推直到数组中没有元素结束。实现中我们要维护一个数组来记录当前的元素，每次得到一个元素加入结果数组，然后从剩余数组中移除。</p>
<p>这里一开始把<code>k--</code>，目的是让下标从<code>0</code>开始，这样下标就是从<code>0</code>到<code>n-1</code>，不用考虑<code>n</code>时去取余，更好地跟数组下标匹配。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//n个元素的列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	list.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fac=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        	fac*=i;                <span class="comment">//计算(n-1)!</span></span><br><span class="line">        k--;                   <span class="comment">//首先将k-1作为小标 这样与下边从0开始进行对应</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> index=k/fac;</span><br><span class="line">        	k%=fac;</span><br><span class="line">        	res.append(list.get(index));</span><br><span class="line">        	list.remove(index);</span><br><span class="line">        	<span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        		fac/=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Permutations II]]></title>
      <url>http://codeinterviews.com/Permutations-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Permutations II</p>
<blockquote>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,</p>
<p><code>[1,1,2]</code> have the following unique permutations:</p>
<p><code>[1,1,2]</code>, <code>[1,2,1]</code>, and <code>[2,1,1]</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Permutations.html" target="_blank" rel="external">Permutations</a>类似，只是这题数组中存在重复的元素，需要考虑会产生重复的结果问题。对于重复的元素循环时跳过递归函数的调用，只对第一个未被使用的进行递归，我们那么这一次结果会出现在第一个的递归函数结果中，而后面重复的会被略过。如果第一个重复元素前面的元素还没在当前结果中，那么我们不需要进行递归。如果第一个重复元素前面的元素还没在当前结果中，那么我们不需要进行递归</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">    	ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] used=<span class="keyword">new</span> <span class="keyword">int</span>[num.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)</span><br><span class="line">        	used[i]=<span class="number">0</span>;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        helper(num,used,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span>[] used,ArrayList&lt;Integer&gt; cur,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(cur.size()==num.length)</span><br><span class="line">    	&#123;</span><br><span class="line">    		res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; num[i]==num[i-<span class="number">1</span>] &amp;&amp; used[i-<span class="number">1</span>]==<span class="number">0</span>) <span class="comment">//对于重复的元素循环时跳过递归函数的调用，只对第一个未被使用的进行递归</span></span><br><span class="line">    				<span class="keyword">continue</span>;</span><br><span class="line">    			<span class="keyword">if</span>(used[i]==<span class="number">0</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				used[i]=<span class="number">1</span>;</span><br><span class="line">    				cur.add(num[i]);</span><br><span class="line">    				helper(num,used,cur,res);</span><br><span class="line">    				cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    				used[i]=<span class="number">0</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Permutations]]></title>
      <url>http://codeinterviews.com/Permutations/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Permutations</p>
<blockquote>
<p>Given a collection of numbers, return all possible permutations.</p>
<p>For example,</p>
<p><code>[1,2,3]</code> have the following permutations:</p>
<p><code>[1,2,3]</code>, <code>[1,3,2]</code>, <code>[2,1,3]</code>, <code>[2,3,1]</code>, <code>[3,1,2]</code>, and <code>[3,2,1]</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题可以采用递归的思想，求解循环子问题。区别是这里并不是一直往后推进的，前面的数有可能放到后面，所以我们需要维护一个used数组来表示该元素是否已经在当前结果中，因为每次我们取一个元素放入结果，然后递归剩下的元素，所以不会出现重复。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">    	ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">   		<span class="keyword">if</span>(num==<span class="keyword">null</span> || num.length==<span class="number">0</span>)</span><br><span class="line">   			<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] used=<span class="keyword">new</span> <span class="keyword">int</span>[num.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)</span><br><span class="line">        	used[i]=<span class="number">0</span>;</span><br><span class="line">       	helper(num,used,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),res);</span><br><span class="line">       	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span>[] used,ArrayList&lt;Integer&gt; cur,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(cur.size()==num.length)</span><br><span class="line">    	&#123;</span><br><span class="line">    		res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;<span class="keyword">else</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>(used[i]==<span class="number">0</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				used[i]=<span class="number">1</span>;</span><br><span class="line">    				cur.add(num[i]);</span><br><span class="line">    				helper(num,used,cur,res);</span><br><span class="line">    				cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    				used[i]=<span class="number">0</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Plus One]]></title>
      <url>http://codeinterviews.com/Plus-One/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Plus One</p>
<blockquote>
<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对用数组表示的数进行加一，每一位的进位最多为<code>1</code>,思路是维护一个进位，对每一位进行加一，然后判断进位，如果有继续到下一位，否则就可以返回了，因为前面不需要计算了。如果最高位进位存在,其必为<code>1</code>,则需要重新开辟一个<code>digit.length+1</code>的空间，其中第一位为<code>1</code>,其余为都为<code>0</code>,因为只是加一操作，其余位一定是0，否则不会进最高位</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(digits ==<span class="keyword">null</span> || digits.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> digits;</span><br><span class="line">        <span class="keyword">int</span> jinwei=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> digit=(digits[i]+jinwei)%<span class="number">10</span>;</span><br><span class="line">        	jinwei=(digits[i]+jinwei)/<span class="number">10</span>;</span><br><span class="line">        	digits[i]=digit;</span><br><span class="line">        	<span class="keyword">if</span>(jinwei==<span class="number">0</span>)</span><br><span class="line">        		<span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明最高位有进位</span></span><br><span class="line">    	<span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    	res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Populating Next Right Pointers in Each Node II]]></title>
      <url>http://codeinterviews.com/Populating-Next-Right-Pointers-in-Each-Node-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Populating Next Right Pointers in Each Node II</p>
<blockquote>
<p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>####Note:</p>
<ul>
<li>You may only use constant extra space.</li>
</ul>
<p>For example,<br>Given the following binary tree,</p>
<pre><code>     1
   /  \
  2    3
 / \    \
4   5    7
</code></pre><p>After calling your function, the tree should look like:</p>
<pre><code>    1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \    \
4-&gt; 5 -&gt; 7 -&gt; NULL
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是<a href="http://pisxw.com/algorithm/Populating-Next-Right-Pointers-in-Each-Node.html" target="_blank" rel="external">Populating Next Right Pointers in Each Node</a>的延伸。该树可能不是一个完美二叉树，而是一个任意的二叉树。但是，上题中的方法并没有对树是否是完美二叉树有要求。所以，上题的求解方法在此处依旧适用。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeLinkNode left, right, next;</span><br><span class="line"> *     TreeLinkNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode lastnode=root;<span class="comment">//每一行的头结点</span></span><br><span class="line">        TreeLinkNode curhead=<span class="keyword">null</span>;<span class="comment">//定义当前行的头结点</span></span><br><span class="line">        TreeLinkNode prenode=<span class="keyword">null</span>;<span class="comment">//定义当前行向后遍历的节点</span></span><br><span class="line">        <span class="keyword">while</span>(lastnode!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeLinkNode nextnode=lastnode; <span class="comment">//定义当前行的遍历节点</span></span><br><span class="line">        	<span class="keyword">while</span>(nextnode!=<span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(nextnode.left!=<span class="keyword">null</span>)  <span class="comment">//说明有左孩子节点</span></span><br><span class="line">	        	&#123;</span><br><span class="line">	        		<span class="comment">//判断当前有没有头结点，即该节点是不是下一行第一个节点</span></span><br><span class="line">	        		<span class="keyword">if</span>(curhead==<span class="keyword">null</span>) <span class="comment">//没有头结点</span></span><br><span class="line">	        		&#123;</span><br><span class="line">	        			curhead=nextnode.left;</span><br><span class="line">	        			prenode=curhead;</span><br><span class="line">	        		&#125;<span class="keyword">else</span>&#123; <span class="comment">//有头结点,prenode向后前进</span></span><br><span class="line">	        			prenode.next=nextnode.left;</span><br><span class="line">	        			prenode=prenode.next;</span><br><span class="line">	        		&#125;</span><br><span class="line">	        	&#125;</span><br><span class="line"></span><br><span class="line">	        	<span class="keyword">if</span>(nextnode.right!=<span class="keyword">null</span>) <span class="comment">//说明有右孩子节点</span></span><br><span class="line">	        	&#123;</span><br><span class="line">	        		<span class="comment">//同样需要判断当前有没有头结点</span></span><br><span class="line">	        		<span class="keyword">if</span>(curhead==<span class="keyword">null</span>) <span class="comment">//没有头结点</span></span><br><span class="line">	        		&#123;</span><br><span class="line">	        			curhead=nextnode.right;</span><br><span class="line">	        			prenode=curhead;</span><br><span class="line">	        		&#125;<span class="keyword">else</span>&#123; <span class="comment">//有头结点,prenode向后前进</span></span><br><span class="line">	        			prenode.next=nextnode.right;</span><br><span class="line">	        			prenode=prenode.next;</span><br><span class="line">	        		&#125;</span><br><span class="line">	        	&#125;</span><br><span class="line">	        	nextnode=nextnode.next;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">//当前行结束,进入下一行</span></span><br><span class="line">	        lastnode=curhead;</span><br><span class="line">	        curhead=<span class="keyword">null</span>;   <span class="comment">//需要置为null，因为是新的一层需要建立 	</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Pow(x, n)]]></title>
      <url>http://codeinterviews.com/Pow(x,%20n)/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Pow(x, n)</p>
<blockquote>
<p>Implement pow(x, n).</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>如果对n进行遍历求解，时间复杂度为<code>O(n)</code>,这里可以采用二分方法进行优化，是的时间复杂度为O(logn),每次对n进行二分，且只需计算一边即可。</p>
<p>这里需要注意的是：</p>
<pre><code>1. n的正负
2. n的奇，偶性（二分时有影响）
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对n进行二分，这样时间复杂度为O(logn)</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">return</span> myPow(x,n);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>/myPow(x,-n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    		<span class="keyword">return</span> x;</span><br><span class="line">    	<span class="keyword">double</span> temp=myPow(x,n/<span class="number">2</span>);</span><br><span class="line">    	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> temp*temp;   <span class="comment">//n为偶数</span></span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		<span class="keyword">return</span> temp*temp*x;  <span class="comment">//n为奇数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Populating Next Right Pointers in Each Node]]></title>
      <url>http://codeinterviews.com/Populating-Next-Right-Pointers-in-Each-Node/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Populating Next Right Pointers in Each Node</p>
<blockquote>
<p>Given a binary tree</p>
</blockquote>
<pre><code>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
</code></pre><blockquote>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p>####Note:</p>
</blockquote>
<pre><code>1. You may only use constant extra space.     
2. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
</code></pre><blockquote>
<p>For example,<br>Given the following perfect binary tree,</p>
<pre><code>     1
   /  \
  2    3
 / \  / \
4  5  6  7
</code></pre><p>After calling your function, the tree should look like:</p>
<pre><code>     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \  / \
4-&gt;5-&gt;6-&gt;7 -&gt; NULL
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对树中的每一层建立链表。这与层次遍历非常相似。但是，这里需要常量的空间，因此不可以使用队列进行存储。由于是链表，因此我们可以通过上一层的链表操作从而进行层次遍历，当当前行遍历结束后，下一行的链表关系其实已经建立好了。因此可以通过获取下一行的头结点，从而遍历到下一层。这样依次遍历，就可以得到最终的结果。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree with next pointer.</span><br><span class="line"> * public class TreeLinkNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeLinkNode left, right, next;</span><br><span class="line"> *     TreeLinkNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        TreeLinkNode lastnode=root;<span class="comment">//每一行的头结点</span></span><br><span class="line">        TreeLinkNode curhead=<span class="keyword">null</span>;<span class="comment">//定义当前行的头结点</span></span><br><span class="line">        TreeLinkNode prenode=<span class="keyword">null</span>;<span class="comment">//定义当前行向后遍历的节点</span></span><br><span class="line">        <span class="keyword">while</span>(lastnode!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	TreeLinkNode nextnode=lastnode; <span class="comment">//定义当前行的遍历节点</span></span><br><span class="line">        	<span class="keyword">while</span>(nextnode!=<span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(nextnode.left!=<span class="keyword">null</span>)  <span class="comment">//说明有左孩子节点</span></span><br><span class="line">	        	&#123;</span><br><span class="line">	        		<span class="comment">//判断当前有没有头结点，即该节点是不是下一行第一个节点</span></span><br><span class="line">	        		<span class="keyword">if</span>(curhead==<span class="keyword">null</span>) <span class="comment">//没有头结点</span></span><br><span class="line">	        		&#123;</span><br><span class="line">	        			curhead=nextnode.left;</span><br><span class="line">	        			prenode=curhead;</span><br><span class="line">	        		&#125;<span class="keyword">else</span>&#123; <span class="comment">//有头结点,prenode向后前进</span></span><br><span class="line">	        			prenode.next=nextnode.left;</span><br><span class="line">	        			prenode=prenode.next;</span><br><span class="line">	        		&#125;</span><br><span class="line">	        	&#125;</span><br><span class="line"></span><br><span class="line">	        	<span class="keyword">if</span>(nextnode.right!=<span class="keyword">null</span>) <span class="comment">//说明有右孩子节点</span></span><br><span class="line">	        	&#123;</span><br><span class="line">	        		<span class="comment">//同样需要判断当前有没有头结点</span></span><br><span class="line">	        		<span class="keyword">if</span>(curhead==<span class="keyword">null</span>) <span class="comment">//没有头结点</span></span><br><span class="line">	        		&#123;</span><br><span class="line">	        			curhead=nextnode.right;</span><br><span class="line">	        			prenode=curhead;</span><br><span class="line">	        		&#125;<span class="keyword">else</span>&#123; <span class="comment">//有头结点,prenode向后前进</span></span><br><span class="line">	        			prenode.next=nextnode.right;</span><br><span class="line">	        			prenode=prenode.next;</span><br><span class="line">	        		&#125;</span><br><span class="line">	        	&#125;</span><br><span class="line">	        	nextnode=nextnode.next;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">//当前行结束,进入下一行</span></span><br><span class="line">	        lastnode=curhead;</span><br><span class="line">	        curhead=<span class="keyword">null</span>;   <span class="comment">//需要置为null，因为是新的一层需要建立 	</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Recover Binary Search Tree]]></title>
      <url>http://codeinterviews.com/Recover-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Recover Binary Search Tree</p>
<blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>####Note:<br>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?<br>confused what <code>&quot;{1,#,2,3}&quot;</code> means? &gt; read more on how binary tree is serialized on OJ.</p>
<p>####OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example:</p>
<pre><code>  1
 / \
2   3
   /
  4
   \
    5
</code></pre><p>The above binary tree is serialized as <code>&quot;{1,2,3,#,#,4,#,#,5}&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是在二叉查找树中有一对元素顺序出现了调换，需要将其恢复出来。根据二叉查找树的性质，自身中序遍历后肯定是有序的，如果有两个元素被调换，则中序遍历的有序性将会被打破，那么调换的是哪两个元素呢？<br>可以发现，有两种情况的元素会被调用，一是相邻的元素，二是不相邻的元素。第一种情况，如果是相邻的元素，此时在中序顺序中只有一对逆序，此时只需要调换他们两个即可。第二种情况，如果不相邻，则在中序顺序中会出现两对逆序，例如：<code>1234567</code>,调换<code>5</code>和<code>1</code>，此时得到<code>5234167</code>，会发现<code>52</code>和<code>41</code>是逆序，此时需要调换的是第一个逆序的第一个元素和第二个逆序的第二个元素。因此需要对逆序的个数进行判定。<br>搞清楚了规律就容易实现了，中序遍历寻找逆序情况，调换的第一个元素，永远是第一个逆序的第一个元素，而调换的第二个元素如果只有一次逆序，则是那一次的后一个，如果有两次逆序则是第二次的后一个.</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//pre中存放前缀节点，因为java是值传递，所以保存在全局变量中</span></span><br><span class="line">    	ArrayList&lt;TreeNode&gt; pre=<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    	pre.add(<span class="keyword">null</span>);</span><br><span class="line">    	<span class="comment">//res中存在的是需要调换的两个节点</span></span><br><span class="line">    	ArrayList&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        helper(root,pre,res); <span class="comment">//进行中序遍历处理</span></span><br><span class="line">        <span class="keyword">if</span>(res.size()!=<span class="number">0</span>) <span class="comment">//说明有需要调换的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> tmp=res.get(<span class="number">0</span>).val;</span><br><span class="line">        	res.get(<span class="number">0</span>).val=res.get(<span class="number">1</span>).val;</span><br><span class="line">        	res.get(<span class="number">1</span>).val=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,ArrayList&lt;TreeNode&gt; pre,ArrayList&lt;TreeNode&gt; res)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	helper(root.left,pre,res);</span><br><span class="line">    	<span class="comment">//如果前缀的值比root值大，说明出现了逆序</span></span><br><span class="line">    	<span class="keyword">if</span>(pre.get(<span class="number">0</span>)!=<span class="keyword">null</span> &amp;&amp; pre.get(<span class="number">0</span>).val&gt;root.val)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">//判断这是第几个逆序</span></span><br><span class="line">    		<span class="keyword">if</span>(res.size()==<span class="number">0</span>)<span class="comment">//说明是第一个逆序</span></span><br><span class="line">    		&#123;</span><br><span class="line">    			res.add(pre.get(<span class="number">0</span>));</span><br><span class="line">    			res.add(root);</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123; <span class="comment">//说明是第二个逆序</span></span><br><span class="line">    			res.set(<span class="number">1</span>,root); <span class="comment">//只需要修改第二个交换的值，因为第二个值是第二个逆序的后一个元素</span></span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//设定前缀值为root</span></span><br><span class="line">    	pre.set(<span class="number">0</span>,root);</span><br><span class="line">    	helper(root.right,pre,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis数据类型]]></title>
      <url>http://codeinterviews.com/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>本文主要对Redis的数据类型进行介绍。（来自实验楼）<br><a id="more"></a></p>
<p>##一、Redis的数据类型</p>
<p>  Redis不仅仅是简单的key-value 存储器，同时也是一种data structures server。传统的key-value是指支持使用一个key字符串来索引value字符串的存储，而Redis中，value不仅仅支持字符串，还支持更多的复杂结构，包括列表，集合，哈希表等。现在我们一一讲解：Redis keys是采用二进制安全，这就意味着你可以使用任何二进制序列作为重点，从像”foo”可以联系一个 JPEG 文件。空字符串也是一个有效的密钥。</p>
<p>##二、Redis strings<br> 字符串是一种最基本的Redis值类型。Redis字符串是二进制安全的，这意味着一个Redis字符串能包含任意类型的数据，例如： 一张JPEG格式的图片或者一个序列化的Ruby对象。一个字符串类型的值最多能存储512M字节的内容。</p>
<p>  我们继续上一个实验,启动redis-cli来看看Redis strings数据类型。</p>
<pre><code>$ sudo service redis-server start
$ redis-cli

&gt; set mykey somevalue

&gt; get mykey
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429495788778?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>如上例所示，可以SET和GET命令来创建和检索strings。注意,set命令将取代现有的任何已经存在的key。SET命令还有一个提供附加参数的选项,我们能够让SET命令只有在没有相同key的情况下成功，反之亦然，可以让SET命令在有相同key值得情况下成功。</p>
<pre><code>&gt; set mykey newval nx

&gt; set mykey newval xx
</code></pre><p>操作截图;</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429496555867?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>即使string是Redis的基本类型，也可以对其进行一些有趣的操作，例如加法器：</p>
<pre><code>&gt; set counter 100

&gt; incr counter

&gt; incr counter

&gt; incrby counter 50
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429496794133?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>INCR命令让the value 成为一个整数，运行一次INCR便+1。INCRBY命令便是一个加法运算。类似的命令如减法运算为： DECR and DECRBY。</p>
<p>Redis可以运用MSET and MGET 命令完成一次性的完成多个key-value的对应关系，使用MGET命令，Redis返回一个value数组。</p>
<pre><code>&gt; mset a 10 b 20 c 30

&gt; mget a b c
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429497275273?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>##三、Redis Lists</p>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边） LPUSH 命令插入一个新的元素导头部, 而 RPUSH插入一个新元素导尾部.当一个这两个操作在一个空的Key上被执行的时候一个新的列表被创建。相似的，如果一个列表操作清空一个列表那么对应的key将被从key空间删除。这是非常方便的语义，因为他们被调用使用一个空列表完全就像他们被调用时使用一个不存在的键值（可以）做为参数。</p>
<p>PUSH一类的命令的返回值为list的长度。一些类表操作和结果的例子：</p>
<pre><code>&gt; rpush mylist A

&gt; rpush mylist B

&gt; lpush mylist first

&gt; lrange mylist 0 -1
</code></pre><p>操作截图:</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429500406303?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p><strong>注意</strong>：LRANGE 利用了两个检索值，0表示list的开头第一个，-1表示list的倒数第一个，即最后一个。-2则便是list的倒数第二个，以此类推。</p>
<p>这些命令都是可变的命令，也就是说你可以一次加入多个元素放入list。</p>
<pre><code>&gt; rpush mylist 1 2 3 4 5 &quot;foo bar&quot;

&gt; lrange mylist 0 -1
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429500850565?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt=""></p>
<p>在Redis的命令操作中，还有一类重要的操作：POP，取出list元素。和PUSH操作类似，POP命令可以选择不同的方向取出元素.POP命令返回值为取出的元素。</p>
<pre><code>&gt; del mylist

&gt; rpush mylist a b c

&gt; rpop mylist

&gt; lrange mylist 0 -1

&gt; lpop mylist

 &gt; lrange mylist 0 -1
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429501355431?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>在Redis list中还有很多有用的命令，此处限于篇幅便不在赘述。</p>
<p>##四、Redis Hashes<br>Redis Hashes是字符串字段和字符串值之间的映射,因此他们是展现对象的完美数据类型。 (例如:一个有名，姓，年龄等等属性的用户):一个带有一些字段的hash仅仅需要一块很小的空间存储,因此你可以存储数以百万计的对象在一个小的Redis实例中。 哈希主要用来表现对象，他们有能力存储很多对象，因此你可以将哈希用于许多其他的任务。 </p>
<pre><code>&gt; hmset user:1000 username antirez birthyear 1977 verified 1
&gt; hget user:1000 username

&gt; hget user:1000 birthyear

&gt; hgetall user:1000
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429506507229?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>HMSET命令设置一个多域的hash表，HGET命令获取指定的单域，HGETALL命令获取指定key的所有信息。HMGET类似于HGET，只是返回一个value数组。</p>
<pre><code>&gt; hmget user:1000 username birthyear no-such-field
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429506798109?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>同样可以根据需要对hash表的表项进行单独的操作，例如 HINCRBY，<br>（原本birthyear 为1977，见上一图）</p>
<pre><code>&gt; hincrby user:1000 birthyear 10

&gt; hincrby user:1000 birthyear 10
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429508011247?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>##五、Redis 无序集合</p>
<p>Redis 集合（Set）是一个无序的字符串集合. 你可以以O(1)的时间复杂度 (无论集合中有多少元素时间复杂度都是常量)完成添加，删除，以及测试元素是否存在。 Redis 集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素，最终在集合里只会有一个元素。 实际上说这些就是意味着在添加元素的时候无须检测元素是否存在。 一个Redis集合的非常有趣的事情是他支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（unions）, 求交集（intersections）,找出不同的元素（differences of sets）。</p>
<pre><code>&gt; sadd myset 1 2 3

&gt; smembers myset
</code></pre><p>SADD命令产生一个无序集合，返回集合的元素个数。SMEMBER用于查看集合。</p>
<p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429508736877?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>SISMEMBER用于查看集合是否存在，匹配项包括集合名和元素个数。匹配成功返回1，匹配失败返回0.</p>
<pre><code>&gt; sismember myset 3

&gt; sismember myset 30

&gt; sismember mys 3
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429508958629?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>##六、Redis有序集合</p>
<p>  Redis有序集合与普通集合非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的没有成员都关联了一个评分，这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。 使用有序集合你可以以非常快的速度（O(log(N))）添加，删除和更新元素。因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！ 简而言之使用有序集合你可以做完成许多对性能有极端要求的任务，而那些任务使用其他类型的数据库真的是很难完成的。 </p>
<p>ZADD与SADD类似，但是在元素之前多了一个参数，这个参数便是用于排序的。形成一个有序的集合。</p>
<pre><code>&gt; zadd hackers 1940 &quot;Alan Kay&quot;

&gt; zadd hackers 1957 &quot;Sophie Wilson&quot;

&gt; zadd hackers 1953 &quot;Richard Stallman&quot;

&gt; zadd hackers 1949 &quot;Anita Borg&quot;

&gt; zadd hackers 1965 &quot;Yukihiro Matsumoto&quot;

&gt; zadd hackers 1914 &quot;Hedy Lamarr&quot;

&gt; zadd hackers 1916 &quot;Claude Shannon&quot;

&gt; zadd hackers 1969 &quot;Linus Torvalds&quot;

&gt; zadd hackers 1912 &quot;Alan Turing&quot;
</code></pre><p>查看集合ZRANGE是查看正序的集合，ZREVRANGE是查看反序的集合。0表示集合第一个元素，-1表示集合的倒数第一个元素。</p>
<pre><code>&gt; zrange hackers 0 -1

&gt; zrevrange hackers 0 -1
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429509695955?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>使用WITHSCORES 参数返回记录值。</p>
<pre><code>&gt; zrange hackers 0 -1 withscores
</code></pre><p>操截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429509789313?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis简介与安装]]></title>
      <url>http://codeinterviews.com/Redis%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>本文主要对Redis进行介绍并讨论其安装过程。（来自实验楼）<br><a id="more"></a></p>
<p>##1. Redis 简介</p>
<p>###1.1 Redis是什么 </p>
<p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis提供了一些丰富的数据结构，包括 lists, sets, ordered sets 以及 hashes ，当然还有和Memcached一样的 strings结构.Redis当然还包括了对这些数据结构的丰富操作。 </p>
<p>Redis常被称作是一款数据结构服务器（data structure server）。Redis的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。 对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。</p>
<p>###1.2 Redis的优点 </p>
<p>性能极高 – Redis能支持超过 100K+ 每秒的读写频率。 </p>
<p>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 </p>
<p>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 </p>
<p>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p>
<p>##2  Redis安装</p>
<p>###2.0 前期准备</p>
<p>设置root密码</p>
<pre><code>$ sudo passwd (输入实验楼密码shiyanlou，并设置root密码)
$ su (输入root密码，进入root权限)
</code></pre><p>操作截图：</p>
<p> <img src="https://dn-anything-about-doc.qbox.me/userid42227labid778time1429171336201?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>###2.1  系统环境和版本说明</p>
<p> Redis的版本选取目前的稳定版本2.8.9。 客户端选用了Redis的Java版本jedis 2.4.2。</p>
<p>###2.2  Redis的安装步骤</p>
<p>####a. 进入root目录，并下载Redis的安装包</p>
<pre><code>$ cd

$ wget http://labfile.oss.aliyuncs.com/files0422/redis-2.8.9.tar.gz
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429255208912?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>####b. 在目录下，解压按照包，生成新的目录redis-2.8.9</p>
<pre><code>$ tar xvfz redis-2.8.9.tar.gz
</code></pre><p>####c.  进入解压之后的目录,进行编译</p>
<pre><code>$ cd redis-2.8.9
$ make
$ make install
</code></pre><p>说明： 如果没有明显的错误，则表示编译成功</p>
<p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429255384936?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>####e.  在安装成功之后，可以运行测试，确认Redis的功能是否正常</p>
<pre><code>$ make test
</code></pre><p>操作截图：</p>
<p> <img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429253422306?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>##3  Redis启动</p>
<p>###3.1 查看重要文件</p>
<p> 在 Redis 安装完成后，注意一些重要的文件，可用 <strong>ls</strong> 命令查看。服务端：src/redis-server，客户端：src/redis-cls，默认配置文件：redis.conf</p>
<pre><code>$ ls
$ cd src
$ ls
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429254140004?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429254149232?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>###3.2 然后将可执行文件放置在$PATH环境目录下，便于以后执行程序时可以不用输入完整的路径，</p>
<pre><code>$　cp redis-server /usr/local/bin/
$　cp redis-cli /usr/local/bin/
</code></pre><p>###3.3 启动Redis-server</p>
<pre><code>$ redis-server  
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429254648296?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>说明： 从以上的截图中，可以发现启动的端口为缺省的6379. 用户可以在启动的时候，指定具体的配置文件，并在其中指定启动的端口。</p>
<p>保持此终端的运行，Ctrl+shift+t 重开一个终端tab。</p>
<p>###3.4查看Redis</p>
<pre><code>$ ps -ef | grep redis
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429256222062?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<pre><code># 通过启动命令检查Redis服务器状态
$ netstat -nlt|grep 6379
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429256206246?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>###3.5 启动Redis-client</p>
<pre><code>$ su    ( 输入root密码，进入root目录)

$ cd

$ redis-cli
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid891time1429257106714?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>至此，redis安装完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis的高级应用与安全]]></title>
      <url>http://codeinterviews.com/Redis%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>本文主要讲解Redis的高级应用，包括：安全性设置，主从复制，事务处理， 持久化机制， 虚拟内存的使用。（来自实验楼）<br><a id="more"></a></p>
<h2 id="一、安全性"><a href="#一、安全性" class="headerlink" title="一、安全性"></a>一、安全性</h2><p>  设置在客户端连接是需要指定的密码（由于redis速度相当的快，一秒钟可以150K次的密码尝试，所以需要设置一个密码强度很大的密码）。</p>
<p>设置密码的方式有两种：</p>
<p>（1） 使用config set 命令的requirepass  参数，具体格式为config set requirepass  “password”。<br>（2） 配置redis.conf 中设置requirepass属性，后面为密码。</p>
<p>输入认证的方式也有两种：</p>
<p>（1） 登录时可以     redis-cli -a password</p>
<p>（2）登录后使用 auth  password</p>
<p>###（1）设置密码</p>
<p>第一种密码设置方式在上一个实验中已经提到，（在CONFIG SET命令讲解的实例），此处我们来看看第二种方式设置密码。</p>
<p>首先需要进入Redis的安装目录，然后修改配置文件redis.conf。根据grep命令的结果，使用vi编辑器修改“# requirepass foobared” 为“requirepass test123”，然后保存退出。</p>
<pre><code>$ grep -n requirepass /etc/redis/redis.conf
$ sudo vim /etc/redis/redis.conf
</code></pre><p>编辑redis.conf的结果：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid915time1429587167986?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt=""></p>
<p>###（2）重启redis-server 与redis-cli</p>
<p>重启redis server。</p>
<pre><code>$ sudo service redis-server restart
</code></pre><p>进入到redis-cli交互界面进行验证</p>
<pre><code>$ redis-cli

&gt; info

&gt; auth test123

&gt; info

&gt; exit
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid915time1429588373908?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>结果表明第一次info命令失败，在auth认证之后info命令正常返回。最后退出redis-cli。</p>
<p>另外一种密码认证方式：</p>
<pre><code>$ redis-cli -a test123

&gt; info
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid915time1429588772601?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>##二、主从复制</p>
<p>由于环境的原因，在此处笔者大致讲解主从复制的工作流程，不做实验。</p>
<p>   Redis的主从复制配置和使用都比较简单，通过主从复制可以允许多个slave server拥有和master server相同的数据库副本。</p>
<p>从服务器只能读，不能写。</p>
<p>   Redis主从复制特点：</p>
<p> 1、master可以拥有多个slave。</p>
<p>2、多个slave可以连接同一个master外，还可以连接到其他的slave。（当master宕机后，相连的slave转变为master）</p>
<p>3、主从复制不会阻塞master，再同步数据时，master可以继续处理client请求。</p>
<p>4、提高了系统的可伸缩性。</p>
<p>Redis主从复制的过程：</p>
<p>1、Slave与master建立连接，发送sync同步命令。</p>
<p>2、 Master会启动一个后台进程，将数据库快照保存到文件中，同时Master主进程会开始收集新的写命令并缓存。</p>
<p>3、 后台完成保存后，就将此文件发送给Slave。</p>
<p>4、 Slave将此文件保存到磁盘上。</p>
<p>##三、事务处理</p>
<p> Redis的事务处理比较简单。只能保证client发起的事务中的命令可以连续的执行，而且不会插入其他的client命令，当一个client在连接中发出multi命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行exec命令时，redis会顺序的执行队列中的所有命令。如果其中执行出现错误，执行正确的不会回滚，不同于关系型数据库的事务。</p>
<pre><code>&gt; multi

&gt; set name a

&gt; set name b

&gt; exec

&gt; get name
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid915time1429591782634?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>##四、持久化机制</p>
<p> Redis是一个支持持久化的内存数据库，Redis需要经常将内存中的数据同步到磁盘来保证持久化。</p>
<p>Redis支持两种持久化方式：</p>
<p>1、snapshotting（快照），将数据存放到文件里，默认方式。</p>
<p> 是将内存中的数据已快照的方式写入到二进制文件中，默认文件dump.rdb，可以通过配置设置自动做快照持久化的方式。可配置Redis在n秒内如果超过m个key被修改就自动保存快照。</p>
<p>save 900 1       #900秒内如果超过1个key被修改，则发起快照保存</p>
<p>save 300  10   #300秒内如果超过10个key被修改，则快照保存</p>
<p>2、 Append-only file（缩写为aof），将读写操作存放到文件中。</p>
<p>由于快照方式在一定间隔时间做一次，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</p>
<p>aof比快照方式有更好的持久化性，是由于使用aof时，redis会将每一个收到的写命令都通过write函数写入到文件中当redis启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。</p>
<p>由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上，这样aof方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉redis我们想要通过fsync函数强制os写入到磁盘的时机。</p>
<p>配置文件中的可配置参数：</p>
<pre><code>appendonly   yes     //启用aof持久化方式

#appendfsync  always //收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化

appendfsync   everysec  //每秒中写入磁盘一次，在性能和持久化方面做了很好的折中

#appendfsync  no     //完全依赖os，性能最好，持久化没有保证                      
</code></pre><p>在redis-cli的命令中，SAVE命令是将数据写入磁盘中。</p>
<pre><code>&gt; help save

&gt;save
</code></pre><p>操作截图：</p>
<blockquote>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid915time1429592610624?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
</blockquote>
<p>##五、虚拟内存的使用</p>
<p>虚拟内存管理在2.6及之上版本取消了，在安装实验中，选择的是2.8.9版本的redis<br>，所有实验中的配置文件中没有虚拟内存管理功能的配置选项。此处仅为讲解</p>
<p>Redis的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其他的访问数据，尤其对于redis这样的内存数据库，内存总是不够用的。除了分隔到多个redis server外，提高数据库的容量的方法就是使用虚拟内存，把那些不常访问的数据交换到磁盘上。</p>
<p>通过配置vm相关的redis.config配置：</p>
<pre><code>vm-enable  yes                   #开启vm功能

vm-swap-file    /tmp/redis.swap  #交换出来的value保存的文件路径

vm-max-memory    10000000        #redis使用的最大内存上线

 vm-page-size   32       #每个页面的大小32字节

vm-pages     123217729    #最多使用多小个页面

vm-max-threads     4        #用于执行value对象换入的工作线程数量
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redis系统管理]]></title>
      <url>http://codeinterviews.com/Redis%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文主要对Redis系统管理进行介绍。（来自实验楼）<br><a id="more"></a></p>
<p>上一节实验讲述了Redis的基本数据类型，本实验继续讲解Redis相关命令及管理操作。</p>
<p>在Redis中，命令大小写不敏感。</p>
<p>##一、适合全体类型的常用命令</p>
<p>启动redis服务和redis-cli命令界面继续后续实验：</p>
<pre><code>$ sudo service redis-server start
$ redis-cli
</code></pre><p>###（1）EXIT and DEL<br>EXISTS key 判断一个key是否存在;存在返回 1;否则返回0;<br>DEL key  删除某个key,或是一系列key;DEL key1 key2 key3 key4。成功返回1，失败返回0（key值不存在）。</p>
<pre><code>&gt; set mykey hello

&gt; exists mykey

&gt; del mykey

&gt; exists mykey
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429498813713?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>###（2）TYPE and KEYS </p>
<p>TYPE key：返回某个key元素的数据类型 ( none:不存在,string:字符,list,set,zset,hash)，key不存在返回空。<br>KEYS key—pattern ：返回匹配的key列表 (KEYS foo*:查找foo开头的keys)</p>
<pre><code>&gt; set mykey x

&gt; type mykey

&gt;keys my*

&gt; del mykey

&gt;keys my*

&gt; type mykey
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429516992936?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>###（3）RANDOMKEY and CLEAR<br>RANDOMKEY ： 随机获得一个已经存在的key，如果当前数据库为空，则返回空字符串</p>
<pre><code>&gt; randomkey
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429515047669?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>CLEAR ：清除界面。</p>
<pre><code>&gt; clear
</code></pre><p>###（4）RENAME  and  RENAMENX </p>
<p>RENAME oldname newname：改key的名字，新键如果存在将被覆盖<br>RENAMENX oldname newname：更改key的名字，如果名字存在则更改失败</p>
<p>笔者randomkey结果为mylist，将此key值更名为newlist。</p>
<pre><code>&gt; randomkey

&gt; rename mylist newlist

&gt; exists mylist

&gt; exists newlist
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429515503329?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>###（5） DBSIZE<br>DBSIZE ：返回当前数据库的key的总数</p>
<pre><code>&gt; dbsize
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429515622274?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>##二、Redis 时间相关命令</p>
<p>###（1）限定key生存时间<br>这同样是一个无视数据类型的命令，对于临时存储很有用处。避免进行大量的DEL操作。</p>
<p>EXPIRE：设置某个key的过期时间（秒）,(EXPIRE bruce 1000：设置bruce这个key1000秒后系统自动删除)注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除。</p>
<pre><code>&gt; set key some-value

&gt; expire key 10

&gt; get key       (马上执行此命令)

&gt; get key       (10s后执行此命令)
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429499147841?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>结果显示，执行EXPIRE命令后，马上GET，显示key存在。10秒后再GET时，key 已经被自动删除。</p>
<p>###（2）查询key剩余生存时间</p>
<p>限时操作可以再SET命令中实现，并且可用TTL命令查询key剩余生存时间。<br>TTL：查找某个key还有多长时间过期,返回时间秒</p>
<pre><code>&gt; set key 100 ex 30

&gt; ttl key

&gt; ttl key
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid911time1429499622388?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>###（3）清除key</p>
<p>FLUSHDB：清空当前数据库中的所有键</p>
<p>FLUSHALL：清空所有数据库中的所有键</p>
<pre><code>&gt;flushdb

&gt;flushall
</code></pre><p>##三、Redis设置相关命令</p>
<p>Redis有其配置文件，可以通过client-command窗口查看或者更改相关配置。相关命令介绍如下：</p>
<p>###（1）CONFIG GET and CONFIG SET</p>
<p>CONFIG GET：用来读取运行Redis服务器的配置参数。<br>CONFIG SET：用于更改运行Redis服务器的配置参数。<br>AUTH : 认证密码<br>下面针对Redis密码的示例：</p>
<pre><code>&gt; config get requirepass （查看密码）

&gt; config set requirepass test123 （设置密码为test123 ）

&gt; config get requirepass  （报错，没有认证）

&gt; auth test123

&gt; config get requirepass
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429520598484?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>由结果可知，刚开始时Reids并未设置密码，密码查询结果为空。然后设置密码为test123，再次查询报错。经过auth命令认证后，可正常查询。</p>
<p>可以经过修改Redis的配置文件redis.conf修改密码。</p>
<p>CONFIG GET命令是以list的key-value对显示的，如查询数据类型的最大条目：</p>
<pre><code>&gt; config get *max-*-entries* 
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429521073401?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>###（2）重置报告</p>
<p>CONFIG RESETSTAT：重置数据统计报告，通常返回值为&#39;OK&#34;。</p>
<pre><code>&gt; CONFIG RESETSTAT
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429521447546?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p>##四、查询信息</p>
<p> INFO [section] ：查询Redis相关信息。<br> INFO命令可以查询Redis几乎所有的信息，其命令选项有如下：</p>
<pre><code>1.  server: Redis server的常规信息
2.   clients: Client的连接选项
3.  memory: 存储占用相关信息
4. persistence: RDB and AOF 相关信息
5.   stats: 常规统计
6.  replication: Master/slave请求信息
7.  cpu: CPU 占用信息统计
8.  cluster: Redis 集群信息
9. keyspace: 数据库信息统计
10. all: 返回所有信息
11. default: 返回常规设置信息
</code></pre><p>若命令参数为空，info命令返回所有信息。</p>
<pre><code>&gt; info keyspace

&gt; info server
</code></pre><p>操作截图：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429581133525?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid42227labid913time1429581162348?watermark/1/image/aHR0cDovL3N5bC1zdGF0aWMucWluaXVkbi5jb20vaW1nL3dhdGVybWFyay5wbmc=/dissolve/60/gravity/SouthEast/dx/0/dy/10" alt="图片描述信息"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Remove Duplicates from Sorted Array II]]></title>
      <url>http://codeinterviews.com/Remove-Duplicates-from-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Remove Duplicates from Sorted Array II</p>
<blockquote>
<p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p>
<p>For example,<br>Given sorted array A = <code>[1,1,1,2,2,3]</code>,   </p>
<p>Your function should return length = <code>5</code>, and A is now <code>[1,1,2,2,3]</code>. </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是[Remove Duplicates from Sorted Array][1]的延伸，如果重复元素重复次数多于2次，则可以保留下两个该元素，做法同样是维护两个指针，一个保留当前有效元素的长度，一个从前往后扫，然后可以保留两个的就保留两个，然后跳过那些多余的重复元素。因为数组是有序的，所以重复元素一定相邻，不需要额外记录。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>; <span class="comment">//记录重复元素的个数</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;A.length)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(A[i]!=A[j])</span><br><span class="line">        	&#123;</span><br><span class="line">        		A[++i]=A[j++];</span><br><span class="line">        		num=<span class="number">0</span>;</span><br><span class="line">        	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">0</span>)&#123; <span class="comment">//表示已经有一个重复元素了，可以再加一个</span></span><br><span class="line">        		A[++i]=A[j++];</span><br><span class="line">        		num++;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123; <span class="comment">//超过两个，后面的重复元素则跳过</span></span><br><span class="line">        		j++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Remove Duplicates from Sorted Array]]></title>
      <url>http://codeinterviews.com/Remove-Duplicates-from-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Remove Duplicates from Sorted Array</p>
<blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array <code>A = [1,1,2]</code>,</p>
<p>Your function should return length = <code>2</code>, and <code>A</code> is now <code>[1,2]</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是去除数组中的多余的重复元素。与<a href="http://pisxw.com/algorithm/Remove-Element.html" target="_blank" rel="external">Remove Element</a>类似。做法是维护两个指针，一个保留当前有效元素的长度，一个从前往后扫，然后跳过那些重复的元素。因为数组是有序的，所以重复元素一定相邻，不需要额外记录。时间复杂度是O(n)，空间复杂度O(1)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=A.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(A[i]!=A[j])</span><br><span class="line">        	&#123;</span><br><span class="line">        		A[i+<span class="number">1</span>]=A[j];</span><br><span class="line">        		i++;</span><br><span class="line">        		j++;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		j++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Remove Duplicates from Sorted List II]]></title>
      <url>http://codeinterviews.com/Remove-Duplicates-from-Sorted-List-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Remove Duplicates from Sorted List II</p>
<blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.     </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Remove-Duplicates-from-Sorted-List.html" target="_blank" rel="external">Remove Duplicates from Sorted List</a>非常类似，同样是去除链表中的重复元素，但是这里不保留重复的元素，还是链表操作，这里定义三个指针<code>k</code>,<code>i</code>,<code>j</code>往后推进。指针<code>i</code>，<code>j</code>之间是重复的元素(包含<code>i</code>,但不包含<code>j</code>)，<code>k</code>是<code>i</code>的前一位指针，然后通过<code>k.next=j</code>来进行跳过所有的重复元素，同时<code>i=j</code>,<code>j=j.next</code>.依次下去，直到<code>j=null</code>为止。由于只要遍历链表一遍，所以时间复杂度为<code>O(n)</code>。</p>
<p>这里有个注意点，为了初始化<code>k</code>指针，这里重创了一个新的头结点<code>newhead</code>,然后将这个节点的<code>next</code>指向<code>head</code>节点.</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> head;</span><br><span class="line">        ListNode newhead=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        newhead.next=head;</span><br><span class="line">        ListNode i=head;</span><br><span class="line">        ListNode j=head.next;</span><br><span class="line">        ListNode k=newhead;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">while</span>(j!=<span class="keyword">null</span> &amp;&amp; i.val==j.val)</span><br><span class="line">        	&#123;</span><br><span class="line">        		j=j.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(j!=<span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        	    <span class="keyword">if</span>(i.next!=j)</span><br><span class="line">            	&#123;</span><br><span class="line">            		k.next=j;</span><br><span class="line">    	        	i=j;</span><br><span class="line">    	        	j=j.next;</span><br><span class="line">            	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            		j=j.next;</span><br><span class="line">            		i=i.next;</span><br><span class="line">            		k=k.next;</span><br><span class="line">            	&#125;	</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	    k.next=j;</span><br><span class="line">        	&#125;</span><br><span class="line">        	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Remove Duplicates from Sorted List]]></title>
      <url>http://codeinterviews.com/Remove-Duplicates-from-Sorted-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Remove Duplicates from Sorted List</p>
<blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.      </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是去除链表中的重复元素，且重复元素只保存一个，主要是链表操作，这里定义两个指针<code>i</code>,<code>j</code>往后推进。指针<code>i</code>，<code>j</code>之间是重复的元素(包含<code>i</code>,但不包含<code>j</code>)，然后通过<code>i.next=j</code>来进行跳过多余的重复元素，同时<code>i=j</code>,<code>j=j.next</code>.依次下去，直到<code>j==null</code>为止。由于只要遍历链表一遍，所以时间复杂度为<code>O(n)</code>。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> head;</span><br><span class="line">        ListNode i=head;</span><br><span class="line">        ListNode j=head.next;</span><br><span class="line">        <span class="keyword">while</span>(j!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">while</span>(j!=<span class="keyword">null</span> &amp;&amp; i.val==j.val)</span><br><span class="line">        	&#123;</span><br><span class="line">        		j=j.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(j!=<span class="keyword">null</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		i.next=j;</span><br><span class="line">        		i=j;</span><br><span class="line">        		j=j.next;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		i.next=j;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Remove Element]]></title>
      <url>http://codeinterviews.com/Remove-Element/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Remove Element</p>
<blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是移除数组中给定的元素。这里可以设定两个指针<code>i</code>和<code>j</code>,如果<code>A[j]</code>不是要删除的元素，则<code>A[i]=A[j]</code>,否则<code>j</code>往前移动。这样<code>j</code>指针相当于遍历整个数组，而<code>i</code>指针则负责保存剩余的元素。这样只需要遍历一遍数组即可。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//采用两个指针，一次遍历即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(A.length&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> 		<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"> 		<span class="keyword">while</span>(j&lt;A.length)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			<span class="keyword">if</span>(A[j]!=elem)</span><br><span class="line">	 		&#123;</span><br><span class="line">	 			A[i]=A[j];</span><br><span class="line">	 			i++;</span><br><span class="line">	 			j++;</span><br><span class="line">	 		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	 			j++;</span><br><span class="line">	 		&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">return</span> i; 		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Remove Linked List Elements]]></title>
      <url>http://codeinterviews.com/Remove-Linked-List-Elements/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Remove Linked List Elements</p>
<blockquote>
<p>Remove all elements from a linked list of integers that have value val.</p>
<p><strong>Example</strong><br><strong>Given</strong>: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6<br><strong>Return</strong>: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5</p>
<p><strong>Credits</strong>:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题是对链表中的节点进行删除，因此可以维护两个指针，删除的时候只需要指针的变动即可，此外，由于头结点的删除是一种特殊情况，因此我们可以通过重新设定一个新的头结点，将其next指向head,这样头结点与其他节点的删除操作就可以统一化处理。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode newhead=<span class="keyword">new</span> ListNode();</span><br><span class="line">        newhead.next=head;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        ListNode q=newhead;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(p.val==val)</span><br><span class="line">        	&#123;</span><br><span class="line">        		q.next=p.next;</span><br><span class="line">        		p=p.next;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		q=p;</span><br><span class="line">        		p=p.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Remove Nth Node From End of List]]></title>
      <url>http://codeinterviews.com/Remove-Nth-Node-From-End-of-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Remove Nth Node From End of List</p>
<blockquote>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p>
<pre><code>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.

After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5
</code></pre></blockquote>
<p>####Note:</p>
<blockquote>
<p>Given n will always be valid.<br>Try to do this in one pass.<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题是删除链表从尾部开始数第n个节点的问题，思路就是先用一个<code>runner</code>指针走n步，然后再来一个<code>walker</code>从头开始和<code>runner</code>同时向后走，当<code>runner</code>走到链表末尾的时候，<code>walker</code>指针即为倒数第n个结点。算法的时间复杂度是O(链表的长度)，空间复杂度是<code>O(1)</code></p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//思路就是先用一个runner指针走n步，然后再来一个walker从头开始和runner同时向后走，当runner走到链表末尾的时候，walker指针即为倒数第n个结点。算法的时间复杂度是O(链表的长度)，空间复杂度是O(1)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">        ListNode runner = head;  </span><br><span class="line">        <span class="keyword">while</span>(runner!=<span class="keyword">null</span> &amp;&amp; i&lt;n)  </span><br><span class="line">        &#123;  </span><br><span class="line">            runner = runner.next;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i&lt;n)  </span><br><span class="line">            <span class="keyword">return</span> head;  </span><br><span class="line">        <span class="keyword">if</span>(runner == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> head.next;  </span><br><span class="line">        ListNode walker = head;  </span><br><span class="line">        <span class="keyword">while</span>(runner.next!=<span class="keyword">null</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            walker = walker.next;  </span><br><span class="line">            runner = runner.next;  </span><br><span class="line">        &#125;  </span><br><span class="line">        walker.next = walker.next.next;  </span><br><span class="line">        <span class="keyword">return</span> head;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Reorder List]]></title>
      <url>http://codeinterviews.com/Reorder-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Reorder List</p>
<blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题是对链表进行重排序，即<code>L1</code>链接<code>Ln</code>,<code>L2</code>链接<code>Ln-1</code>.但是我们可以定义两个指针<code>p</code>和<code>q</code>，<code>p</code>从前往后，<code>q</code>从后往前，那我们怎么知道<code>q</code>的前向节点呢，因此我们首先遍历一遍链表，使用<code>hashmap</code>来存储每个节点的前向节点。这样再改变链表链接的时候，就可以很方便的从后往前进行遍历。否则每次向后一个节点，都需要遍历剩余的全部节点，从而才能找到尾节点。</p>
<p>这里有一个需要注意的地方，就是结束条件：如果节点总数为偶数个，则结束条件为<code>p.next==q</code>.如果节点个数为奇数，则结束条件为<code>p==q</code>.</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        ListNode p=head.next;</span><br><span class="line">        ListNode q=head;</span><br><span class="line">        HashMap&lt;ListNode,ListNode&gt; map=<span class="keyword">new</span> HashMap&lt;ListNode,ListNode&gt;();<span class="comment">//存放每个节点的前一个节点</span></span><br><span class="line">       	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">       	&#123;</span><br><span class="line">       		map.put(p,q);</span><br><span class="line">       		p=p.next;</span><br><span class="line">       		q=q.next;</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="comment">//这里q已经到了结尾处</span></span><br><span class="line">       	<span class="comment">//开始遍历调序</span></span><br><span class="line">       	p=head;</span><br><span class="line">       	<span class="keyword">while</span>(p!=q &amp;&amp; p.next!=q)</span><br><span class="line">       	&#123;</span><br><span class="line">       		ListNode tmp=p.next;</span><br><span class="line">       		p.next=q;</span><br><span class="line">       		q.next=tmp;</span><br><span class="line">       		p=tmp;</span><br><span class="line">       		q=map.get(q);</span><br><span class="line">       	&#125;</span><br><span class="line">       	q.next=<span class="keyword">null</span>;</span><br><span class="line">       	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Repeated DNA Sequences]]></title>
      <url>http://codeinterviews.com/Repeated-DNA-Sequences/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Repeated DNA Sequences</p>
<blockquote>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>For example,</p>
<pre><code>Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,
</code></pre></blockquote>
<pre><code>Return:
[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].
</code></pre><a id="more"></a>
<p>##解题思路<br>该题首先很容易想到是字符串的匹配问题，可以使用KMP算法，但是如果把所有的长度为10的字串都遍历一遍，然后对每个字串进行模式查找，时间复杂度为O（n^2）.因此需要进行优化，可以发现，其实题目只需要求得那些出现次数多余1次的字串，也就是说我们可以使用“哈希”map进行存储，键为字符串，值为出现的次数，这样对所有长度为10的字串进行便利后，就可以得到每个字串的出现次数，然后在map中找出出现次数大于1的那些字串即可。</p>
<p>结果发现超内存</p>
<p>超内存的原因是什么？肯定是map中的第一个字段，它是字符串，肯定需要很多空间。能不能换个思维，把字符串哈希一下，哈希成可以用比较小的空间就能表示的？因为可能出现的字符只有四种：AGCT，那么这么设计哈希函数：A-&gt;0,C-&gt;1,G-&gt;2,T-&gt;3。如此一来，把长度为10的字符串映射（哈希）成整数。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><strong>该代码超内存</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    	ArrayList&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//定义个hashmap,key为字符串，value为该字符串出现的次数</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">        <span class="comment">//对所有长度为10的字串进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s.length()-<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	String cur=s.substring(i,i+<span class="number">10</span>);</span><br><span class="line">        	<span class="keyword">if</span>(!map.containsKey(cur))</span><br><span class="line">        	&#123;</span><br><span class="line">        		map.put(cur,<span class="number">1</span>);</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		map.put(cur,map.get(cur)+<span class="number">1</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选出那些出现次数大于1次的那些字符串</span></span><br><span class="line">       Iterator iterator = map.keySet().iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			String key=(String)iterator.next();</span><br><span class="line">			<span class="keyword">int</span> val=map.get(key);</span><br><span class="line">			<span class="keyword">if</span>(val&gt;<span class="number">1</span>)</span><br><span class="line">				res.add(key);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>修改之后</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    	ArrayList&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//定义个hashmap,key为字符串转变成的整数，value为该字符串出现的次数</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="comment">//对所有长度为10的字串进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s.length()-<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	String cur=s.substring(i,i+<span class="number">10</span>);</span><br><span class="line">        	<span class="keyword">int</span> curint=change(cur);</span><br><span class="line">        	<span class="keyword">if</span>(!map.containsKey(curint))</span><br><span class="line">        	&#123;</span><br><span class="line">        		map.put(curint,<span class="number">1</span>);</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		<span class="keyword">if</span>(map.get(curint)==<span class="number">1</span>)</span><br><span class="line">        			res.add(cur);</span><br><span class="line">        		map.put(curint,map.get(curint)+<span class="number">1</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		res*=<span class="number">10</span>;</span><br><span class="line">    		<span class="keyword">switch</span>(s.charAt(i))&#123;</span><br><span class="line">    			<span class="keyword">case</span> <span class="string">'A'</span>:&#123;res+=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    			<span class="keyword">case</span> <span class="string">'C'</span>:&#123;res+=<span class="number">2</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    			<span class="keyword">case</span> <span class="string">'G'</span>:&#123;res+=<span class="number">3</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    			<span class="keyword">case</span> <span class="string">'T'</span>:&#123;res+=<span class="number">4</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Restore IP Addresses]]></title>
      <url>http://codeinterviews.com/Restore-IP-Addresses/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Restore IP Addresses</p>
<blockquote>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>For example:<br>Given <code>&quot;25525511135&quot;</code>,</p>
<p>return <code>[&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code>. (Order does not matter)</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题的解法非常接近于NP问题，也是采用递归的解法。基本思路就是取出一个合法的数字，作为IP地址的一项，然后递归处理剩下的项。可以想象出一颗树，每个结点有三个可能的分支（因为范围是0-255，所以可以由一位两位或者三位组成）。并且这里树的层数不会超过四层，因为IP地址由四段组成，到了之后我们就没必要再递归下去，可以结束了。这里除了上述的结束条件外，另一个就是字符串读完了。可以看出这棵树的规模是固定的，不会像平常的NP问题那样，时间复杂度取决于输入的规模，是指数量级的，所以这道题并不是NP问题，因为他的分支是四段，有限制.</p>
<p>实现中需要一个判断数字是否为合法ip地址的一项的函数，首先要在0-255之间，其次前面字符不能是0。剩下的就是NP问题的套路了，递归中套一个for循环，不熟悉的朋友可以看看<a href="http://pisxw.com/algorithm/N-Queens.html" target="_blank" rel="external">N-Queens</a>哈</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        helper(s,<span class="number">0</span>,<span class="number">1</span>,<span class="string">""</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//index：字符串中的位置</span></span><br><span class="line">    <span class="comment">//segment：表示ip地址中的第几段</span></span><br><span class="line">    <span class="comment">//item:表示前面已得到的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">int</span> index,<span class="keyword">int</span> segment,String item,ArrayList&lt;String&gt; res)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&gt;s.length())</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//每个ip有四个段，如果达到第4段</span></span><br><span class="line">		<span class="keyword">if</span>(segment==<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			String str = s.substring(index);</span><br><span class="line">			<span class="keyword">if</span>(isValid(str))&#123;</span><br><span class="line">				<span class="comment">//字串合法</span></span><br><span class="line">				res.add(item+<span class="string">"."</span>+str);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//每一段为0~255,字符长度为1~3位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span> &amp;&amp; (index+i)&lt;=s.length();i++)&#123;</span><br><span class="line">			String str=s.substring(index,index+i);</span><br><span class="line">			<span class="keyword">if</span>(isValid(str))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//第一段有个特例</span></span><br><span class="line">				<span class="keyword">if</span>(segment==<span class="number">1</span>)&#123;</span><br><span class="line">					helper(s,index+i,segment+<span class="number">1</span>,str,res);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					helper(s,index+i,segment+<span class="number">1</span>,item+<span class="string">"."</span>+str,res);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">	 	<span class="comment">//长度大于3，不满足	</span></span><br><span class="line">		<span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span> || s.length()&gt;<span class="number">3</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> num = Integer.parseInt(s);</span><br><span class="line">		<span class="comment">//首位为0且长度大于1，不满足</span></span><br><span class="line">		<span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">'0'</span> &amp;&amp; s.length()&gt;<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">//在0~255之间的，满足</span></span><br><span class="line">		<span class="keyword">if</span>(num&gt;=<span class="number">0</span> &amp;&amp; num&lt;=<span class="number">255</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-3Sum]]></title>
      <url>http://codeinterviews.com/3Sum/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####3Sum</p>
<blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
</blockquote>
<p>####Note:</p>
<ul>
<li>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)   </li>
<li>The solution set must not contain duplicate triplets.</li>
</ul>
<blockquote>
<pre><code>For example, given array S = {-1 0 1 2 -1 -4},

A solution set is:
(-1, 0, 1)
(-1, -1, 2)
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解在一个有重复数字的数组中是否存在三个数的和为0的问题。这道题是<a href="http://pisxw.com/algorithm/leetcode-two-sum.html" target="_blank" rel="external">Two Sum</a>的扩展。当然，如果我们采用“暴搜”，时间复杂度则为<code>O(n^3)</code>。但是由于这道题中存在重复的元素，因此采用哈希表的解法不是很方便，因此，这里通过首先<strong>将数组进行排序</strong>，然后采用<strong>左右夹逼</strong>的方法。总的时间复杂度为O(n^2+nlogn)=(n^2),空间复杂度是O(n)。</p>
<p>这里将<code>Two Sum</code>作为<code>3Sum</code>的一个<code>subroutine</code>来处理，不过具体实现需要注意更多的细节,尤其是需要考虑过滤重复元素的问题。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//利用2sum可以求解，由于可能存在重复元素，所以采用散列表会有冲突，这里采用左右夹逼来求解2sum,整个时间复杂度为O(n^2+nlogn)=O(n^2)</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">    	ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num.length&lt;=<span class="number">2</span>) <span class="keyword">return</span> lists;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length-<span class="number">2</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;num[i]==num[i-<span class="number">1</span>]) <span class="comment">//考虑重复问题，保证lists中没有重复</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		    <span class="keyword">if</span>(num[i]&lt;=<span class="number">0</span>)</span><br><span class="line">			    tweSum(lists,num,i,num[i],-num[i]);</span><br><span class="line">		&#125;   </span><br><span class="line">		<span class="keyword">return</span> lists;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweSum</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists,<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> term,<span class="keyword">int</span> target)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=start+<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> j=num.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>((num[i]+num[j])==target)</span><br><span class="line">    		&#123;</span><br><span class="line">    			ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    			list.add(term);</span><br><span class="line">    			list.add(num[i]);</span><br><span class="line">    			list.add(num[j]);</span><br><span class="line">    			lists.add(list);</span><br><span class="line">    			i++;</span><br><span class="line">    			j--;</span><br><span class="line">    			<span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]==num[i-<span class="number">1</span>])  <span class="comment">//考虑重复问题</span></span><br><span class="line">                    i++;  </span><br><span class="line">                <span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]==num[j+<span class="number">1</span>])  <span class="comment">//考虑重复问题</span></span><br><span class="line">                    j--;  </span><br><span class="line">    		&#125;<span class="keyword">else</span> <span class="keyword">if</span>((num[i]+num[j])&gt;target)</span><br><span class="line">    		&#123;</span><br><span class="line">    			j--;</span><br><span class="line">    		&#125;<span class="keyword">else</span></span><br><span class="line">    			i++;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Reverse Bits]]></title>
      <url>http://codeinterviews.com/Reverse-Bits/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Reverse Bits</p>
<blockquote>
<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p>
<p>####Follow up:<br>If this function is called many times, how would you optimize it?</p>
<p>Related problem: Reverse Integer</p>
<p>####Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题的思路与<a href="pisxw.com/algorithm/leetcode-Reverse-Integer.html">Reverse Integer</a>类似,这里是对二进制数进行转置，我们可以使用移位的方法进行，对原数不断取最后一位，然后不断右移，而对结果数不断左移或上原数的最后一位。由于位数是确定的，因此只需要移位31次即可。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res= n &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	n=n&gt;&gt;<span class="number">1</span>; <span class="comment">//不断向右移动</span></span><br><span class="line">        	res=res&lt;&lt;<span class="number">1</span>; <span class="comment">//不断向左移动</span></span><br><span class="line">        	res=res | (n &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Reverse Linked List II]]></title>
      <url>http://codeinterviews.com/Reverse-Linked-List-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Reverse Linked List II</p>
<blockquote>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, m = 2 and n = 4,</p>
<p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
<p>####Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是基本的链表操作，主要是对m节点到n节点之间的节点进行转置，首先需要找到m节点和其前节点preMnode，然后每次读到下一个节点后，将其插入到preMnode后面即可，然后继续读下一个节点，直到n节点完成。总共只需要一次扫描，所以时间是O(n)，只需要几个辅助指针，空间是O(1)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> head;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        newHead.next=head;</span><br><span class="line">        ListNode preMnode=newHead;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找到m节点的前一个节点preMnode</span></span><br><span class="line">        <span class="keyword">while</span>(preMnode!=<span class="keyword">null</span> &amp;&amp; i&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">        	preMnode = preMnode.next;</span><br><span class="line">        	i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m) </span><br><span class="line">        	<span class="keyword">return</span> head;</span><br><span class="line">        ListNode Mnode=preMnode.next;</span><br><span class="line">        <span class="comment">//对m节点到n节点之间的节点进行转置，每次读取一个节点就放在preMnode节点的后面</span></span><br><span class="line">        ListNode curNode=Mnode.next;</span><br><span class="line">        <span class="keyword">while</span>(curNode!=<span class="keyword">null</span> &amp;&amp; i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">        	ListNode next=curNode.next;</span><br><span class="line">        	curNode.next=preMnode.next;</span><br><span class="line">        	preMnode.next=curNode;</span><br><span class="line">        	Mnode.next=next;</span><br><span class="line">        	curNode=next;</span><br><span class="line">        	i++;    	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Reverse Linked List]]></title>
      <url>http://codeinterviews.com/Reverse-Linked-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Reverse Linked List</p>
<blockquote>
<p>Reverse a singly linked list.</p>
<p>click to show more hints.</p>
<p>####Hint:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题是对一个单链表进行转置，其实很简单，与遍历链表的操作类似，我们可以通过两个指针一前一后向后遍历，然后只需要改变指针的指向即可。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> head;</span><br><span class="line">    	ListNode p=head.next;</span><br><span class="line">    	ListNode q=head;</span><br><span class="line">    	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		ListNode tmp=p.next;</span><br><span class="line">    		p.next=q;</span><br><span class="line">    		q=p;</span><br><span class="line">    		p=tmp;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//这条语句非常重要，由于是转置，因此head的next应该最后为null,否则则会出现超时的情况</span></span><br><span class="line">    	head.next=<span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">return</span> q;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Reverse Nodes in k-Group]]></title>
      <url>http://codeinterviews.com/Reverse-Nodes-in-k-Group/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Reverse Nodes in k-Group</p>
<blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,<br>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是将链表中的元素按照K个一组进行翻转。这题是<a href="http://pisxw.com/algorithm/Swap-Nodes-in-Pairs.html" target="_blank" rel="external">Swap Nodes in Pairs</a>的变形。首先我们需要找到K个元素，然后对这K个元素进行翻转；接着再向后找下一组K个元素并对其进行翻转，依次下去，直到找到链表结束为止。</p>
<p>其中对K个元素进行翻转，需要仔细考虑链表的指向问题，尤其是最终头结点的指针。</p>
<p>在该题中，本文假设存在一个<strong>虚拟头结点</strong>链接原始的链表,这样对后面的链表翻转有一定的帮助简化作用。通过设定翻转链表的起始点<code>Start</code>和结束点<code>End</code>,来对<code>Start+1</code>到<code>End-1</code>这些元素进行翻转。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//每K个逆转一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    	ListNode newhead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    	newhead.next=head;</span><br><span class="line">    	ListNode p=head;</span><br><span class="line">    	ListNode pre=newhead;</span><br><span class="line">    	<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		count++;</span><br><span class="line">    		ListNode next=p.next;</span><br><span class="line">    		<span class="keyword">if</span>(count==k)</span><br><span class="line">    		&#123;</span><br><span class="line">    			pre=reverseList(pre,next);</span><br><span class="line">    			count=<span class="number">0</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		p=next;</span><br><span class="line">    			</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> newhead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆转pre和end之间的链表元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode pre,ListNode end)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pre==<span class="keyword">null</span>||pre.next==<span class="keyword">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    	ListNode head=pre.next;</span><br><span class="line">    	ListNode cur=pre.next.next;</span><br><span class="line">    	<span class="keyword">while</span>(cur!=end)&#123;</span><br><span class="line">    		ListNode curnext=cur.next;</span><br><span class="line">    		cur.next=pre.next;</span><br><span class="line">    		pre.next=cur;</span><br><span class="line">    		cur=curnext;</span><br><span class="line">    	&#125;</span><br><span class="line">    	head.next=end;</span><br><span class="line">    	<span class="keyword">return</span> head;  <span class="comment">//返回的是逆转后的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Reverse Words in a String]]></title>
      <url>http://codeinterviews.com/Reverse-Words-in-a-String/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Reverse Words in a String</p>
<blockquote>
<p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = <code>&quot;the sky is blue&quot;</code>,<br>return <code>&quot;blue is sky the&quot;</code>.   </p>
<p>####Update (2015-02-12):<br>For C programmers: Try to solve it in-place in O(1) space.</p>
<p>click to show clarification.</p>
<p>####Clarification:</p>
<ul>
<li>What constitutes a word?<br>A sequence of non-space characters constitutes a word.</li>
<li>Could the input string contain leading or trailing spaces?<br>Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>How about multiple spaces between two words?<br>Reduce them to a single space in the reversed string.</li>
</ul>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>我们先介绍一种很直接的做法，就是类似于java中String::split函数做的操作，把字符串按空格分开，不过我们把重复的空格直接忽略过去。接下来就是把得到的结果单词反转过来得到结果。因为过程中就是一次扫描得到字符串，然后再一次扫描得出结果，所以时间复杂度是O(n)。空间上要用一个数组来存，所以是O(n)。实现思路比较清晰，这里就不列举迭代实现的代码了。</p>
<p>接下来我们再介绍另一种方法，思路是先把整个串反转并且同时去掉多余的空格，然后再对反转后的字符串对其中的每个单词进行反转，比如”the sky is blue”，先反转成”eulb si yks eht”，然后在对每一个单词反转，得到”blue is sky the”。这种方法先反转的时间复杂度是O(n)，然后再对每个单词反转需要扫描两次（一次是得到单词长度，一次反转单词）,所以总复杂度也是O(n)，比起上一种方法并没有提高，甚至还多扫描了一次，不过空间上这个不需要额外的存储一份字符串，不过从量级来说也还是O(n)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    s = s.trim(); <span class="comment">//去掉前导空白符和后导空白符</span></span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=s.length()-<span class="number">1</span> &amp;&amp; s.charAt(i)==<span class="string">' '</span> &amp;&amp; s.charAt(i)==s.charAt(i+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        res.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;res.length())&#123;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;res.length() &amp;&amp; res.charAt(right)!=<span class="string">' '</span>)&#123;</span><br><span class="line">     		right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> next = right+<span class="number">1</span>;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = res.charAt(left);</span><br><span class="line">            res.setCharAt(left++, res.charAt(right));</span><br><span class="line">            res.setCharAt(right--, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        left = next;</span><br><span class="line">        right = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Rotate Array]]></title>
      <url>http://codeinterviews.com/Rotate-Array/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Rotate Array</p>
<blockquote>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<p>####Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
<p>####Hint:</p>
<ul>
<li>Could you do it in-place with O(1) extra space?</li>
<li>Related problem: Reverse Words in a String II</li>
</ul>
<p>####Credits:<br>Special thanks to @Freezen for adding this problem and creating all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题如果用extra space O(n)的话很简单，就是把第i个元素移动到 (i+k)%size 位置就行。<br>但是如果只能用O(1) extra space的话，就是把一个元素移动到它对应的新位置，再把新位置的元素移动到下一个新位置，直到又回到初始位置为止。但这样的话，进行了一个圈，回到初始位置后，不一定是把数组中所有位置都移动了，而是看（size, k）的最大公约数，一共有gcd个圈，每个圈的起始位置是 0，1，2，… (gcd-1)，但是这里没必要算出来gcd，只需要有一个counter变量，记录移了几个数了，一圈后，如果counter==size，说明移完了，如果counter&lt;size，说明没移完，则把起始位置加1，继续移动新圈。这样的话，空间复杂度O(1)，时间复杂度O(n)   </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;  </span><br><span class="line">	    <span class="keyword">int</span> counter = <span class="number">0</span>;  </span><br><span class="line">	    <span class="keyword">int</span> start = <span class="number">0</span>;  </span><br><span class="line">	    <span class="keyword">while</span>(counter&lt;size)&#123;  </span><br><span class="line">	        <span class="keyword">int</span> last = start;  </span><br><span class="line">	        <span class="keyword">int</span> next = (start+k)%size;  </span><br><span class="line">	        <span class="keyword">int</span> val = nums[last];  </span><br><span class="line">	        do&#123;  </span><br><span class="line">	            <span class="keyword">int</span> tmp = nums[next];  </span><br><span class="line">	            nums[next] = val;  </span><br><span class="line">	            val = tmp;  </span><br><span class="line">	            last = next;  </span><br><span class="line">	            next = (next+k)%size;  </span><br><span class="line">	            counter++;  </span><br><span class="line">	        &#125;<span class="keyword">while</span>(last!=start);  </span><br><span class="line">	          </span><br><span class="line">	        start++;  </span><br><span class="line">	    &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Rotate Image]]></title>
      <url>http://codeinterviews.com/Rotate-Image/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Rotate Image</p>
<blockquote>
<p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Follow up:</p>
<p>Could you do this in-place?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>基本思路是把图片分为行数/2层，然后一层层进行旋转，每一层有上下左右四个列，然后目标就是把上列放到右列，右列放到下列，下列放到左列，左列放回上列，中间保存一个临时变量即可。</p>
<p>例如这张图：<br><img src="/img/Rotate-Image/1.jpg" alt=""></p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n/<span class="number">2</span>; ++i)    </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n-i; ++j)    </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];    </span><br><span class="line">                matrix[i][j] = matrix[n-j][i];    </span><br><span class="line">                matrix[n-j][i] = matrix[n-i][n-j];    </span><br><span class="line">                matrix[n-i][n-j] = matrix[j][n-i];    </span><br><span class="line">                matrix[j][n-i] = tmp;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-3Sum Closest]]></title>
      <url>http://codeinterviews.com/3Sum-Closest/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####3Sum Closest</p>
<blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<pre><code>For example, given array S = {-1 2 1 -4}, and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解是找到三个数的和，使得该和最接近给定的目标值。因为<code>a+b+c</code>的和最接近<code>target</code>,可以看成是<code>b+c</code>的最接近于<code>target-a</code>,这样三个数的问题就可以变为两个数的问题。而两个数的问题可以采用<strong>左右夹逼</strong>法进行求解，当然这个前提是数组必须是排好序的。时间复杂度为<code>O(n^2+nlogn)</code>,即<code>O(n^2)</code>。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//a+b+c的和接近target,可以认为b+c的和接近target-a,这样使得三个数变成两个数的问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="keyword">if</span>(num.length&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">int</span> closestsum=num[<span class="number">0</span>]+num[<span class="number">1</span>]+num[<span class="number">2</span>]; <span class="comment">//维持一个最接近target的和</span></span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length-<span class="number">2</span>;i++)</span><br><span class="line">       	&#123;</span><br><span class="line">       		<span class="keyword">int</span> twosum=twoSumClosest(num,i+<span class="number">1</span>,target-num[i]);</span><br><span class="line">       		<span class="keyword">if</span>(Math.abs(num[i]+twosum-target)&lt;Math.abs(closestsum-target))</span><br><span class="line">       			closestsum=num[i]+twosum;</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">return</span> closestsum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoSumClosest</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> target)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> i=start;</span><br><span class="line">    	<span class="keyword">int</span> j=num.length-<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> closestsum=num[i]+num[i+<span class="number">1</span>]; <span class="comment">//维持一个最接近target的和</span></span><br><span class="line">    	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(Math.abs(num[i]+num[j]-target)&lt;Math.abs(closestsum-target))</span><br><span class="line">    			closestsum=num[i]+num[j];</span><br><span class="line">    		<span class="keyword">if</span>((num[i]+num[j])&gt;target)</span><br><span class="line">    			j--;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    			i++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> closestsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Same Tree]]></title>
      <url>http://codeinterviews.com/Same-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Same Tree</p>
<blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判定两个二叉树是否相等，相等的条件是结构上相同且对应节点的值也相同。因此可以对两个数进行深度遍历，通过遍历判定节点是否相同。而且，判断整个树是否相同，即分别判定根节点和左右两个子树是否分别相同。因此可以使用递归求解。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//进行深度搜索判定</span></span><br><span class="line">        <span class="keyword">return</span> depth_Search(p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">depth_Search</span><span class="params">(TreeNode p,TreeNode q)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="comment">//如果一个根结点为空，则为false</span></span><br><span class="line">    	<span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q!=<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">if</span>(p!=<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="comment">//如果两个根结点都为空，两个空树为true</span></span><br><span class="line">    	<span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="comment">//两个根结点都不为空，两个树是否相同，需要首先判定其值，然后递归判定左右子树是否相同。</span></span><br><span class="line">    	<span class="keyword">return</span> p.val==q.val &amp;&amp; depth_Search(p.left,q.left) &amp;&amp; depth_Search(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Scramble String]]></title>
      <url>http://codeinterviews.com/Scramble-String/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Scramble String </p>
<blockquote>
<p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of s1 = <code>&quot;great&quot;</code>:</p>
<pre><code>    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
</code></pre><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p>
<pre><code>    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
</code></pre><p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>
<p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p>
<pre><code>    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
</code></pre><p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>
<p>Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题如果采用递归进行求解，会造成超时。<br>这其实是一道三维动态规划的题目，我们提出维护量res[i][j][n]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，res[i][j][len]表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为scramble。<br>有了维护量我们接下来看看递推式，也就是怎么根据历史信息来得到res[i][j][len]。判断这个是不是满足，其实我们首先是把当前s1[i…i+len-1]字符串劈一刀分成两部分，然后分两种情况：第一种是左边和s2[j…j+len-1]左边部分是不是scramble，以及右边和s2[j…j+len-1]右边部分是不是scramble；第二种情况是左边和s2[j…j+len-1]右边部分是不是scramble，以及右边和s2[j…j+len-1]左边部分是不是scramble。如果以上两种情况有一种成立，说明s1[i…i+len-1]和s2[j…j+len-1]是scramble的。而对于判断这些左右部分是不是scramble我们是有历史信息的，因为长度小于n的所有情况我们都在前面求解过了（也就是长度是最外层循环）。<br>上面说的是劈一刀的情况，对于s1[i…i+len-1]我们有len-1种劈法，在这些劈法中只要有一种成立，那么两个串就是scramble的。<br>总结起来递推式是res[i][j][len] = || (res[i][j][k]&amp;&amp;res[i+k][j+k][len-k] || res[i][j+len-k][k]&amp;&amp;res[i+k][j][len-k]) 对于所有1&lt;=k&lt;len，也就是对于所有len-1种劈法的结果求或运算。因为信息都是计算过的，对于每种劈法只需要常量操作即可完成，因此求解递推式是需要O(len)（因为len-1种劈法）。      </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;  </span><br><span class="line">	    <span class="keyword">if</span>(s1==<span class="keyword">null</span> || s2==<span class="keyword">null</span> || s1.length()!=s2.length())  </span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">	    <span class="keyword">if</span>(s1.length()==<span class="number">0</span>)  </span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">	    <span class="keyword">boolean</span>[][][] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[s1.length()][s2.length()][s1.length()+<span class="number">1</span>];  </span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++)  </span><br><span class="line">	    &#123;  </span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s2.length();j++)  </span><br><span class="line">	        &#123;  </span><br><span class="line">	            res[i][j][<span class="number">1</span>] = s1.charAt(i)==s2.charAt(j);  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=s1.length();len++)  </span><br><span class="line">	    &#123;  </span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length()-len+<span class="number">1</span>;i++)  </span><br><span class="line">	        &#123;  </span><br><span class="line">	            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s2.length()-len+<span class="number">1</span>;j++)  </span><br><span class="line">	            &#123;  </span><br><span class="line">	                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;len;k++)  </span><br><span class="line">	                &#123;  </span><br><span class="line">	                    res[i][j][len] |= res[i][j][k]&amp;&amp;res[i+k][j+k][len-k] || res[i][j+len-k][k]&amp;&amp;res[i+k][j][len-k];  </span><br><span class="line">	                &#125;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>][s1.length()];  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Search Insert Position]]></title>
      <url>http://codeinterviews.com/Search-Insert-Position/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Search Insert Position</p>
<blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.<br><code>[1,3,5,6]</code>, 5 → 2<br><code>[1,3,5,6]</code>, 2 → 1<br><code>[1,3,5,6]</code>, 7 → 4<br><code>[1,3,5,6]</code>, 0 → 0   </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是一个对已排序的数组进行元素的插入，但是我们需要知道插入元素的位置信息，因此我们这边可以采用<strong>二分查找</strong>来得到插入的位置信息。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//利用二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>&amp;&amp;A.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=A.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&lt;target)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Search a 2D Matrix]]></title>
      <url>http://codeinterviews.com/Search-a-2D-Matrix/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Search a 2D Matrix</p>
<blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<pre><code>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</code></pre><p>Given <strong>target</strong> = <code>3</code>, return <code>true</code>. </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题每一行的第一个元素要大于前一行的最后一个元素，且在行内是增序排列，这样在行上基本上是有序的。所以这里可以采用二分查找，首先对行进行二分查找，判断目标元素<code>target</code>在哪一行中，然后由于行内也是有序的，这样就可以对这一行使用二分查找，从而最终判断元素在不在矩阵中。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rownum=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> colnum=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//按行进行二分查找，确定在哪一行</span></span><br><span class="line">        <span class="keyword">int</span> rowi=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowj=rownum-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rowi&lt;=rowj)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> rowm=(rowi+rowj)/<span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span>(matrix[rowm][<span class="number">0</span>]&lt;=target &amp;&amp; target&lt;=matrix[rowm][colnum-<span class="number">1</span>])</span><br><span class="line">        	&#123;   <span class="comment">//对这一行进行二分查找</span></span><br><span class="line">        		<span class="keyword">int</span> coli=<span class="number">0</span>;</span><br><span class="line">        		<span class="keyword">int</span> colj=colnum-<span class="number">1</span>;</span><br><span class="line">        		<span class="keyword">while</span>(coli&lt;=colj)</span><br><span class="line">        		&#123;</span><br><span class="line">        			<span class="keyword">int</span> colm=(coli+colj)/<span class="number">2</span>;</span><br><span class="line">        			<span class="keyword">if</span>(matrix[rowm][colm]==target)</span><br><span class="line">        				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        			<span class="keyword">else</span> <span class="keyword">if</span>(matrix[rowm][colm]&lt;target)&#123;</span><br><span class="line">        				coli=colm+<span class="number">1</span>;</span><br><span class="line">        			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        				colj=colm-<span class="number">1</span>;</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[rowm][<span class="number">0</span>]&gt;target)&#123;</span><br><span class="line">        		rowj=rowm-<span class="number">1</span>;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		rowi=rowm+<span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Search for a Range]]></title>
      <url>http://codeinterviews.com/Search-for-a-Range/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Search for a Range </p>
<blockquote>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题可以采用两次二分查找，第一次找到<code>target</code>的左边界，第二次找到<code>`target</code>的右边界。通过相等的时候也向一个方向继续夹逼，如果向右夹逼，最后就会停在右边界，而向左夹逼则会停在左边界，如此用停下来的两个边界就可以知道结果了，只需要两次二分查找。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两次二分查找即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result=&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> fl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fr=A.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fl&lt;=fr)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(fl+fr)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&lt;target)</span><br><span class="line">                fl=mid+<span class="number">1</span>;  <span class="comment">//fl表示最左边界</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fr=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sr=A.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(sl&lt;=sr)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(sl+sr)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;target)</span><br><span class="line">                sr=mid-<span class="number">1</span>;  <span class="comment">//sr表示最右边界</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sl=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fl&lt;=sr)</span><br><span class="line">        &#123;</span><br><span class="line">            result[<span class="number">0</span>]=fl;</span><br><span class="line">            result[<span class="number">1</span>]=sr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Search in Rotated Sorted Array II]]></title>
      <url>http://codeinterviews.com/Search-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Search in Rotated Sorted Array II</p>
<blockquote>
<p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?   </p>
<p>Would this affect the run-time complexity? How and why?</p>
<p>Write a function to determine if a given target is in the array.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>和<a href="http://pisxw.com/algorithm/Search-in-Rotated-Sorted-Array.html" target="_blank" rel="external">Search in Rotated Sorted Array</a>唯一的区别是这道题目中元素会有重复的情况出现。不过正是因为这个条件的出现，出现了比较复杂的case，甚至影响到了算法的时间复杂度。原来我们是依靠中间和边缘元素的大小关系，来判断哪一半是不受rotate影响，仍然有序的。而现在因为重复的出现，如果我们遇到中间和边缘相等的情况，我们就丢失了哪边有序的信息，因为哪边都有可能是有序的结果。假设原数组是{1,2,3,3,3,3,3}，那么旋转之后有可能是{3,3,3,3,3,1,2}，或者{3,1,2,3,3,3,3}，这样的我们判断左边缘和中心的时候都是3，如果我们要寻找1或者2，我们并不知道应该跳向哪一半。解决的办法只能是对边缘移动一步，直到边缘和中间不在相等或者相遇，这就导致了会有不能切去一半的可能。所以最坏情况（比如全部都是一个元素，或者只有一个元素不同于其他元素，而他就在最后一个）就会出现每次移动一步，总共是n步，算法的时间复杂度变成O(n).</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=A.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==A[mid]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&lt;A[r])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;A[mid]&amp;&amp;target&lt;=A[r])</span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&gt;A[r])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=A[l]&amp;&amp;target&lt;A[mid])</span><br><span class="line">                    r=mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            	r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上方法和Search in Rotated Sorted Array是一样的，只是添加了中间和边缘相等时，边缘移动一步，但正是这一步导致算法的复杂度由O(logn)变成了O(n).</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Second Highest Salary]]></title>
      <url>http://codeinterviews.com/Second%20Highest%20Salary/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Second Highest Salary</p>
<blockquote>
<p>Write a SQL query to get the second highest salary from the Employee table.</p>
<pre><code>+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
</code></pre><p>For example, given the above Employee table, the second highest salary is <code>200</code>. If there is no second highest salary, then the query should return <code>null</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是找到表中第二大的值，首先我们可以找到最大的值，然后再在比最大值小的值中找到最大的那个即可。</p>
<p>##算法代码<br>代码采用mysql实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select max(Salary) from Employee</span><br><span class="line">where Salary &lt; (select max(Salary) from Employee)</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Search in Rotated Sorted Array]]></title>
      <url>http://codeinterviews.com/Search-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Search in Rotated Sorted Array</p>
<blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题依旧是二分查找的变形，具体来说，假设数组是A，每次左边缘为l，右边缘为r，还有中间位置是m。在每次迭代中，分三种情况：<br>（1）如果target==A[m]，那么m就是我们要的结果，直接返回；<br>（2）如果A[m]<a[r]，那么说明从m到r一定是有序的（没有受到rotate的影响），那么我们只需要判断target是不是在m到r之间，如果是则把左边缘移到m+1，否则就target在另一半，即把右边缘移到m-1。 （3）如果a[m]="">=A[r]，那么说明从l到m一定是有序的，同样只需要判断target是否在这个范围内，相应的移动边缘即可。   </a[r]，那么说明从m到r一定是有序的（没有受到rotate的影响），那么我们只需要判断target是不是在m到r之间，如果是则把左边缘移到m+1，否则就target在另一半，即把右边缘移到m-1。></p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=A.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==A[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(A[mid]&lt;A[r])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;A[mid]&amp;&amp;target&lt;=A[r])</span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=A[l]&amp;&amp;target&lt;A[mid])</span><br><span class="line">                    r=mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Set Matrix Zeroes]]></title>
      <url>http://codeinterviews.com/Set-Matrix-Zeroes/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Set Matrix Zeroes</p>
<blockquote>
<p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p><strong>Follow up</strong>:<br>Did you use extra space?<br>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?    </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这是一个矩阵操作的题目，目标很明确，就是如果矩阵如果有元素为0，就把对应的行和列上面的元素都置为0。这里最大的问题就是我们遇到0的时候不能直接把矩阵的行列在当前矩阵直接置0，否则后面还没访问到的会被当成原来是0，最后会把很多不该置0的行列都置0了。<br>一个直接的想法是备份一个矩阵，然后在备份矩阵上判断，在原矩阵上置0，这样当然是可以的，不过空间复杂度是O(mxn)，不是很理想。<br>上面的方法如何优化呢？我们看到其实判断某一项是不是0只要看它对应的行或者列应不应该置0就可以，所以我们可以维护一个行和列的布尔数组，然后扫描一遍矩阵记录那一行或者列是不是应该置0即可，后面赋值是一个常量时间的判断。这种方法的空间复杂度是O(m+n)。<br>其实还可以再优化，我们考虑使用第一行和第一列来记录上面所说的行和列的置0情况，这里问题是那么第一行和第一列自己怎么办？想要记录它们自己是否要置0，只需要两个变量（一个是第一行，一个是第一列）就可以了。然后就是第一行和第一列，如果要置0，就把它的值赋成0（反正它最终也该是0，无论第一行或者第一列有没有0），否则保留原值。然后根据第一行和第一列的记录对其他元素进行置0。最后再根据前面的两个标记来确定是不是要把第一行和第一列置0就可以了。这样的做法只需要两个额外变量，所以空间复杂度是O(1)。<br>时间上来说上面三种方法都是一样的，需要进行两次扫描，一次确定行列置0情况，一次对矩阵进行实际的置0操作，所以总的时间复杂度是O(mxn)。  </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">boolean</span> rowflag=<span class="keyword">false</span>;<span class="comment">//记录第一行是否会变成0</span></span><br><span class="line">        <span class="keyword">boolean</span> colflag=<span class="keyword">false</span>;<span class="comment">//记录第一列是否会变成0</span></span><br><span class="line">        <span class="comment">//判断第一行是否会变成0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix[<span class="number">0</span>].length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(matrix[<span class="number">0</span>][i]==<span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		rowflag=<span class="keyword">true</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断第一列是否会变成0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix.length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(matrix[j][<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">        	&#123;</span><br><span class="line">        		colflag=<span class="keyword">true</span>;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用第一行和第一列的位置来存放该行，该列是否应该变成0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)</span><br><span class="line">        		&#123;</span><br><span class="line">        			matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        			matrix[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将应该变为0的行和列变为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="number">0</span> || matrix[<span class="number">0</span>][j]==<span class="number">0</span>)</span><br><span class="line">        			matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断第一行是否要变为0</span></span><br><span class="line">        <span class="keyword">if</span>(rowflag==<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix[<span class="number">0</span>].length;i++)</span><br><span class="line">        		matrix[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//判断第一列是否要变为0</span></span><br><span class="line">        <span class="keyword">if</span>(colflag==<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line">        		matrix[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Simplify Path]]></title>
      <url>http://codeinterviews.com/Simplify-Path/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Simplify Path</p>
<blockquote>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><br>path = <code>&quot;/a/./b/../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code>  </p>
<p><strong>Corner Cases</strong>:</p>
<ol>
<li>Did you consider the case where path = <code>&quot;/../&quot;</code>?<br>In this case, you should return <code>&quot;/&quot;</code>.</li>
<li>Another corner case is the path might contain multiple slashes <code>&#39;/&#39;</code> together, such as “<code>/home//foo/</code>“.<br>In this case, you should ignore redundant slashes and return “/home/foo”. </li>
</ol>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>思路比较明确，就是维护一个栈，对于每一个块（以<code>/</code>作为分界）进行分析，如果遇到<code>..</code>则表示要上一层，那么就是进行出栈操作，如果遇到<code>.</code>则是停留当前，直接跳过，其他文件路径则直接进栈即可。最后根据栈中的内容转换成路径即可（这里是把栈转成数组，然后依次添加）。</p>
<p>java中栈的实现可以使用    <code>LinkedList</code>，元素的插入和删除是在链表头部进行。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(path == <span class="keyword">null</span> || path.length()==<span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;String&gt;();  </span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">while</span>(i&lt;path.length())  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> index = i;  </span><br><span class="line">            StringBuilder temp = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line">            <span class="keyword">while</span>(i&lt;path.length() &amp;&amp; path.charAt(i)!=<span class="string">'/'</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                temp.append(path.charAt(i));  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(index!=i)  </span><br><span class="line">            &#123;  </span><br><span class="line">                String str = temp.toString();  </span><br><span class="line">                <span class="keyword">if</span>(str.equals(<span class="string">".."</span>))  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">if</span>(!stack.isEmpty())  </span><br><span class="line">                        stack.pop();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!str.equals(<span class="string">"."</span>))  </span><br><span class="line">                &#123;  </span><br><span class="line">                    stack.push(str);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())  </span><br><span class="line">        &#123;  </span><br><span class="line">            String[] strs = stack.toArray(<span class="keyword">new</span> String[stack.size()]);  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=strs.length-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)  <span class="comment">//LinkedList是在头部进行插入和删除的</span></span><br><span class="line">            &#123;  </span><br><span class="line">              res.append(<span class="string">"/"</span>+strs[j]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(res.length()==<span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;  </span><br><span class="line">        <span class="keyword">return</span> res.toString();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Shortest Palindrome]]></title>
      <url>http://codeinterviews.com/Shortest-Palindrome/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Shortest Palindrome</p>
<blockquote>
<p>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p>
<p>For example:</p>
<p>Given <code>&quot;aacecaaa&quot;</code>, return <code>&quot;aaacecaaa&quot;</code>.</p>
<p>Given <code>&quot;abcd&quot;</code>, return <code>&quot;dcbabcd&quot;</code>.</p>
<p>####Credits:<br>Special thanks to @ifanchu for adding this problem and creating all test cases. Thanks to @Freezen for additional test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题其实难度不大，主要是存在特别长的测试用例，到时时间或者内存超时。</p>
<p>首先，我们从<a href="http://pisxw.com/algorithm/leetcode-Longest-Palindromic-Substring.html" target="_blank" rel="external">Longest Palindromic Substring</a>的思路出发，首先找到从开头开始的最长的回文串的长度，然后再将后面的字符进行翻转添加到前面，但是这个方法虽然时间上比较快，却造成了内存超出。</p>
<p>那么我们看有没有比较简化的方法，首先我们对整个字符串进行翻转，然后不断判断其后缀字符串是否为原字符串的模式字串，如果是，说明这个模式字串就是从开头开始的最长回文。则将原来字符串的不是模式字串的部分加入到翻转字符串的后面即可。这里求解模式字串的方法采用的是经典的<a href="http://pisxw.com/algorithm/Implement-strStr%28%29.html" target="_blank" rel="external">KMP</a>算法</p>
<p>##算法代码<br>代码采用JAVA实现：<br>方法一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//内存超出的方法</span></span><br><span class="line"><span class="comment">//从求解最长的回文串的思想出发，求得从开头开始的最长回文串，然后将剩余的字符添加到开头。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="comment">//首先需要找到从开头开始的最长回文串</span></span><br><span class="line">        <span class="comment">//定义p[i][j]表示从i到j为回文串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] p=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        	Array.fill(p[i],<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设定从开头出发的最大回文长度</span></span><br><span class="line">        <span class="keyword">int</span> maxstartlen=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行初始化设定</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        	p[i][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(s.charAt(i)==s.charAt(i+<span class="number">1</span>))&#123;</span><br><span class="line">        		p[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        		<span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        			maxstartlen=<span class="number">2</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        		</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        	</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length()-i+<span class="number">1</span>;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(s.charAt(j)==s.charAt(j+i-<span class="number">1</span>) &amp;&amp; p[j+<span class="number">1</span>][j+i-<span class="number">1</span>-<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line">        		&#123;</span><br><span class="line">        			p[j][j+i-<span class="number">1</span>]=<span class="number">1</span>; </span><br><span class="line">        			<span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">        				maxstartlen=i;</span><br><span class="line">        		&#125;</span><br><span class="line">        			</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要添加的后缀字符串为</span></span><br><span class="line">        String str=s.subString(maxstartlen-<span class="number">1</span>);</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=str.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        	sb.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将整个字符串进行逆转，然后对逆转后的字符串的每个后缀字串判断是否是原来字符串的模式串，然后进行拼接即可</span></span><br><span class="line"><span class="comment">//判断模式串的方法采用KMP算法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> s;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        StringBuilder sbnext=sb.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sbnext.length();i++)</span><br><span class="line">        	<span class="keyword">if</span>(isSubString(s,sbnext.substring(i).toString()))</span><br><span class="line">        	&#123;</span><br><span class="line">        		index=i;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        res.append(sbnext);</span><br><span class="line">        res.append(s.substring(sbnext.length()-index));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//采用KMP算法进行字串的判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubString</span><span class="params">(String s,String snext)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">char</span>[] hay=s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] need=snext.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(hay.length==<span class="number">0</span>&amp;&amp;need.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(hay.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(need.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(need.length&gt;hay.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//求解next数组</span></span><br><span class="line">        <span class="keyword">int</span>[] next=<span class="keyword">new</span> <span class="keyword">int</span>[need.length];</span><br><span class="line">        next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;need.length-<span class="number">1</span>)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(k==-<span class="number">1</span> || need[i]==need[k])&#123;</span><br><span class="line">        		i++;</span><br><span class="line">        		k++;</span><br><span class="line">        		next[i]=k;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		k=next[k];</span><br><span class="line">        	&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行字串查找</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;hay.length)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(hay[i]==need[j])&#123;</span><br><span class="line">        		i++;</span><br><span class="line">        		j++;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		j=next[j];</span><br><span class="line">        		<span class="keyword">if</span>(j==-<span class="number">1</span>)&#123;</span><br><span class="line">        			i++;</span><br><span class="line">        			j=<span class="number">0</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(j==need.length)</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==need.length)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;  </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s).reverse();  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(s.startsWith(sb.substring(i))) &#123;  </span><br><span class="line">                <span class="keyword">return</span> sb.substring(<span class="number">0</span>, i)+s;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> s;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Single Number II]]></title>
      <url>http://codeinterviews.com/Single-Number-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Single Number II</p>
<blockquote>
<p>Given an array of integers, every element appears three except for one. Find that single one.</p>
<p>####Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与[Single Number][1]相同，只是该题中是元素出现3次。这里同样采用上一题的方法，统计1的个数，只不过模3而已。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Single Number]]></title>
      <url>http://codeinterviews.com/Single-Number/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Single Number </p>
<blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>####Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这个题比较直接的想法是用一个HashMap对于出现的元素进行统计，key是元素，value是出现个数，如果元素出现三次，则从HashMap中移除，最后在HashMap剩下来的元素就是我们要求的元素（因为其他元素都出现两次，有且仅有一个元素不是如此）。这样需要对数组进行一次扫描，所以时间复杂度是O(n)，而需要一个哈希表来统计元素数量，所以空间复杂度是O(n)。这个方法非常容易实现，就不列举代码了。<br>在LeetCode的题目中要求我们不要用额外空间来实现，也就是O(1)空间复杂度。实现的思路是基于数组的元素是整数，我们通过统计整数的每一位来得到出现次数。我们知道如果每个元素重复出现两次，那么每一位出现1的次数也会是2的倍数，如果我们统计完对每一位进行取余2，那么结果中就只剩下那个出现一次的元素。总体只需要对数组进行一次线性扫描，统计完之后每一位进行取余3并且将位数字赋给结果整数，这是一个常量操作（因为整数的位数是固定32位），所以时间复杂度是O(n)。而空间复杂度需要一个32个元素的数组，也是固定的，因而空间复杂度是O(1)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Sort Colors]]></title>
      <url>http://codeinterviews.com/Sort-Colors/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Sort Colors</p>
<blockquote>
<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p><strong>Note</strong>:<br>You are not suppose to use the library’s sort function for this problem.</p>
<p><strong>Follow up</strong>:<br>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</p>
<p>Could you come up with an one-pass algorithm using only constant space?</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是按颜色进行排序，由于有三种颜色，按红，白，蓝进行排序。如果我们知道每种颜色出现的次数，则最终的排序结果我们就知道了。因此这里可以采用<strong>计数排序</strong>。首先统计每个颜色的出现次数，然后按照颜色和出现次数对原数组<code>A</code>中的元素直接进行修改，最终的结果就是排好序的结果。这个方法遍历了两遍数组。见代码1</p>
<p>如果想使用常量的空间，则需要就地排序。这个题目其实我们很容易就能联想到快排的划分上来，但是仔细一想，如果按照划分来做达不到题目要求，比如你按照1来划分，一次划分的结果只能保证1后的元素都为2，但不能保证前面1和0之间的关系。<br>在此基础上可以继续拓展下，标准的划分是按照一个pivot来划分，这里我能不能指定2个pivot。假如指定2个pivot，一个是0，一个是2，那么分割后就有3段，一段是小于等于0，中间段大于0小于2，最后一段大于等于2。这个正好符合题意，也只需要遍历一次数组。见代码2</p>
<p>##算法代码<br>代码采用JAVA实现：<br>代码1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为有三种颜色，可以采用计数排序</span></span><br><span class="line">        <span class="keyword">int</span>[] colors=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//每个颜色的出现次数        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	colors[A[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按颜色进行排序</span></span><br><span class="line">       	<span class="keyword">int</span> weizhi=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;colors.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;colors[i];j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		A[weizhi]=i;</span><br><span class="line">        		weizhi++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> p0=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> p2=A.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(p&lt;A.length &amp;&amp; p&lt;=p2 &amp;&amp; p0&lt;=p2)</span><br><span class="line">       &#123;</span><br><span class="line">       		<span class="keyword">if</span>(A[p]==<span class="number">0</span>)</span><br><span class="line">       		&#123;</span><br><span class="line">       			<span class="keyword">int</span> tmp=A[p0];</span><br><span class="line">       			A[p0]=A[p];</span><br><span class="line">       			A[p]=tmp;</span><br><span class="line">       			p0++;</span><br><span class="line">       			p++;</span><br><span class="line">       		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[p]==<span class="number">2</span>)</span><br><span class="line">       		&#123;</span><br><span class="line">       			<span class="keyword">int</span> tmp=A[p2];</span><br><span class="line">       			A[p2]=A[p];</span><br><span class="line">       			A[p]=tmp;</span><br><span class="line">       			p2--;</span><br><span class="line">       		&#125;<span class="keyword">else</span></span><br><span class="line">       		&#123;</span><br><span class="line">       			p++;</span><br><span class="line">       		&#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Sort List]]></title>
      <url>http://codeinterviews.com/Sort-List/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Sort List</p>
<blockquote>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<a id="more"></a>
</blockquote>
<p>##解题思路<br>该题是对链表进行排序，但是在时间复杂度上要求是<code>O(nlogn)</code>,也就是说排序的方法只可能是归并排序和快速排序，由于前面我们已经做过两个有序链表的合并操作<a href="http://pisxw.com/algorithm/Merge-Two-Sorted-Lists.html" target="_blank" rel="external">Merge Two Sorted Lists</a>.因此这里我们可以使用归并排序进行处理。</p>
<p>需要注意的是，其中链表之间的链接操作和跳转需要比较小心的处理。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		<span class="comment">//找到中间节点，可以定义两个指针，一个每次1步向后前进，一个每次2步向后前进，快的到达末尾后，慢的正好在中间。</span></span><br><span class="line">		ListNode worker=head;</span><br><span class="line">		ListNode runner=head;</span><br><span class="line">		<span class="keyword">while</span>(runner.next!=<span class="keyword">null</span> &amp;&amp; runner.next.next!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			worker=worker.next;</span><br><span class="line">			runner=runner.next.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ListNode newhead=worker.next;</span><br><span class="line">		worker.next=<span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//递归排序两个链表</span></span><br><span class="line">		ListNode head1=mergeSort(head);</span><br><span class="line">		ListNode head2=mergeSort(newhead);</span><br><span class="line">		<span class="keyword">return</span> merge(head1,head2); <span class="comment">//合并两个有序链表</span></span><br><span class="line">	&#125;    </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode head1,ListNode head2)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head1==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> head2;</span><br><span class="line">		<span class="keyword">if</span>(head2==<span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> head1;</span><br><span class="line">		ListNode p=head1;</span><br><span class="line">		ListNode q=head2;</span><br><span class="line">		ListNode newhead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">		ListNode r=newhead;</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="keyword">null</span> &amp;&amp; q!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p.val&lt;q.val)</span><br><span class="line">			&#123;</span><br><span class="line">				r.next=p;</span><br><span class="line">				p=p.next;</span><br><span class="line">				r=r.next;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				r.next=q;</span><br><span class="line">				q=q.next;</span><br><span class="line">				r=r.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			r.next=p;</span><br><span class="line">			p=p.next;</span><br><span class="line">			r=r.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(q!=<span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			r.next=q;</span><br><span class="line">			q=q.next;</span><br><span class="line">			r=r.next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> newhead.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Sqrt(x)]]></title>
      <url>http://codeinterviews.com/Sqrt(x)/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Sqrt(x)</p>
<blockquote>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题采用数值中经常用的另一种方法：二分法。基本思路是跟二分查找类似，要求是知道结果的范围，取定左界和右界，然后每次砍掉不满足条件的一半，直到左界和右界相遇。</p>
<p>比较典型的数值处理的题目还有<a href="http://pisxw.com/algorithm/Divide-Two-Integers.html" target="_blank" rel="external">Divide Two Integers</a>，<a href="http://pisxw.com/algorithm/Pow(x,%20n).html" target="_blank" rel="external">Pow(x,n)</a>等，其实方法差不多，一般就是用二分法或者以2为基进行位处理的方法。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//知道结果的范围，可以采用二分法</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=x/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> m=(left+right)/<span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span>(m&lt;=x/m &amp;&amp; (m+<span class="number">1</span>)&gt;x/(m+<span class="number">1</span>))</span><br><span class="line">        		<span class="keyword">return</span> m;</span><br><span class="line">        	<span class="keyword">if</span>(m&gt;x/m)</span><br><span class="line">        		right=m-<span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        		left=m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Spiral Matrix II]]></title>
      <url>http://codeinterviews.com/Spiral-Matrix-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Spiral Matrix II</p>
<blockquote>
<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>For example,<br>Given n = 3,</p>
<p>You should return the following matrix:</p>
<pre><code>[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Spiral-Matrix.html" target="_blank" rel="external">Spiral Matrix</a>类似，<code>Spiral Matrix</code>是按螺旋序输出矩阵中的元素，但是其中矩阵不一定是方阵，该题是对方阵中进行螺旋序的填充数字，具体解法基本类似，但是这里需要注意一点，如果<code>n</code>为奇数，不要忘记最后一层是一个独立元素。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    	<span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">    	<span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cen=n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cen;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n-i-<span class="number">1</span>;j++) <span class="comment">//上</span></span><br><span class="line">        		res[i][j]=(num++);</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n-i-<span class="number">1</span>;j++)  <span class="comment">//右</span></span><br><span class="line">        		res[j][n-i-<span class="number">1</span>]=(num++);</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=n-i-<span class="number">1</span>;j&gt;i;j--)  <span class="comment">//下</span></span><br><span class="line">                res[n-i-<span class="number">1</span>][j]=(num++);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-i-<span class="number">1</span>;j&gt;i;j--)  <span class="comment">//左</span></span><br><span class="line">                res[j][i]=(num++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)  </span><br><span class="line">       		res[cen][cen]=(num++);</span><br><span class="line">       	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Spiral Matrix]]></title>
      <url>http://codeinterviews.com/Spiral-Matrix/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Spiral Matrix</p>
<blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<pre><code>[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
</code></pre><p>You should return <code>[1,2,3,6,9,8,7,4,5]</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>基本思路跟<a href="http://pisxw.com/algorithm/Rotate-Image.html" target="_blank" rel="external">Rotate Image</a>有点类似，就是一层一层的处理，每一层都是按照右下左上的顺序进行读取就可以。实现中要注意两个细节，一个是因为题目中没有说明矩阵是不是方阵，因此要先判断一下行数和列数来确定螺旋的层数。另一个是因为一层会占用两行两列，如果是单数的，最后要将剩余的走完。所以最后还要做一次判断。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       	<span class="comment">//按每一层进行输出</span></span><br><span class="line">       	ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       	<span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> ||matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">       		<span class="keyword">return</span> res;</span><br><span class="line">       	<span class="keyword">int</span> row=matrix.length;</span><br><span class="line">       	<span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">       	<span class="keyword">int</span> min=Math.min(row,col);</span><br><span class="line">        <span class="keyword">int</span> cen=min/<span class="number">2</span>;</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cen;i++)</span><br><span class="line">       	&#123;</span><br><span class="line"></span><br><span class="line">       		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;col-i-<span class="number">1</span>;j++)</span><br><span class="line">       			res.add(matrix[i][j]);</span><br><span class="line">       		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;row-i-<span class="number">1</span>;j++)</span><br><span class="line">       			res.add(matrix[j][col-i-<span class="number">1</span>]);</span><br><span class="line">       		<span class="keyword">for</span>(<span class="keyword">int</span> j=col-i-<span class="number">1</span>;j&gt;i;j--)</span><br><span class="line">       			res.add(matrix[row-i-<span class="number">1</span>][j]);</span><br><span class="line">       		<span class="keyword">for</span>(<span class="keyword">int</span> j=row-i-<span class="number">1</span>;j&gt;i;j--)</span><br><span class="line">       			res.add(matrix[j][i]);</span><br><span class="line">       	&#125;</span><br><span class="line">       	</span><br><span class="line">       	<span class="keyword">if</span>(min%<span class="number">2</span>==<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(row &lt; col)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=cen; j&lt;col-cen;j++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    res.add(matrix[cen][j]);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=cen; j&lt;row-cen;j++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    res.add(matrix[j][cen]);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Subsets II]]></title>
      <url>http://codeinterviews.com/Subsets-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Subsets II</p>
<blockquote>
<p>Given a collection of integers that might contain duplicates, S, return all possible subsets.</p>
<p><strong>Note</strong>:</p>
<ul>
<li>Elements in a subset must be in non-descending order.    </li>
<li>The solution set must not contain duplicate subsets.  </li>
</ul>
<p>For example,<br>If <strong>S</strong> = <code>[1,2,2]</code>, a solution is:</p>
<pre><code>[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题跟<a href="http://pisxw.com/algorithm/Subsets.html" target="_blank" rel="external">Subsets</a>一样是经典的<code>NP</code>问题–求子集。比<a href="http://pisxw.com/algorithm/Subsets.html" target="_blank" rel="external">Subsets</a>稍微复杂一些的是这里的集合中可能出现重复元素，因此我们在求子集的时候要避免出现重复的子集。在<a href="http://pisxw.com/algorithm/Subsets.html" target="_blank" rel="external">Subsets</a>中我们每次加进一个元素就会把原来的子集都加上这个元素，然后再加入到结果集中，但是这样重复的元素就会产生重复的子集。为了避免这样的重复，需要用个小技巧。</p>
<p>其实比较简单，就是每当遇到重复元素的时候我们就只把当前结果集的后半部分加上当前元素加入到结果集中，因为后半部分就是上一步中加入这个元素的所有子集，上一步这个元素已经加入过了，前半部分如果再加就会出现重复。所以算法上复杂度上没有提高，反而少了一些操作，就是遇到重复时少做一半，不过这里要对元素集合先排序，否则不好判断重复元素。同样的还是可以用递归和非递归来解，不过对于重复元素的处理是一样的。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] num) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        Arrays.sort(num);  </span><br><span class="line">        ArrayList&lt;Integer&gt; lastSize = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">        lastSize.add(<span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">return</span> helper(num, num.length-<span class="number">1</span>, lastSize);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; helper(<span class="keyword">int</span>[] num, <span class="keyword">int</span> index, ArrayList&lt;Integer&gt; lastSize)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();  </span><br><span class="line">            ArrayList&lt;Integer&gt; elem = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">            res.add(elem);  </span><br><span class="line">            <span class="keyword">return</span> res;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = helper(num,index-<span class="number">1</span>,lastSize);  </span><br><span class="line">        <span class="keyword">int</span> size = res.size();  </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">if</span>(index&gt;<span class="number">0</span> &amp;&amp; num[index]==num[index-<span class="number">1</span>])  </span><br><span class="line">            start = lastSize.get(<span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;size;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ArrayList&lt;Integer&gt; elem = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(res.get(i));  </span><br><span class="line">            elem.add(num[index]);  </span><br><span class="line">            res.add(elem);  </span><br><span class="line">        &#125;  </span><br><span class="line">        lastSize.set(<span class="number">0</span>,size);  </span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring概述]]></title>
      <url>http://codeinterviews.com/Spring%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>主要对Spring框架的概念进行阐释，知道为什么要使用Spring。<br><a id="more"></a></p>
<p>##一、Spring概述</p>
<h3 id="1-Spring是什么"><a href="#1-Spring是什么" class="headerlink" title="1.Spring是什么"></a>1.Spring是什么</h3><p>Spring是一个开源的轻量级Java SE（Java 标准版本）/Java EE（Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的，那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要另外管理这些类，增加了我们的负担，如果能通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。</p>
<p>Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我们管理最头疼的数据库事务，它本身提供了一套简单的JDBC访问实现，还能与第三方数据库访问框架集成（如Hibernate、JPA），与各种Java EE技术整合（如Java Mail、任务调度等等），提供一套自己的web层框架Spring MVC、而且还能非常简单的与第三方web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVA SE（C/S架构）应用程序还是JAVA EE（B/S架构）应用程序都可以使用这个平台进行开发。让我们来深入看一下Spring到底能帮我们做些什么？</p>
<h3 id="2-Spring能帮我们做什么"><a href="#2-Spring能帮我们做什么" class="headerlink" title="2.Spring能帮我们做什么"></a>2.Spring能帮我们做什么</h3><p>Spring除了不能帮我们写业务逻辑，其余的几乎什么都能帮助我们简化开发：</p>
<ul>
<li><p>传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会加大各个对象间的耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；而如果采用Spring，则由Spring根据配置文件来进行创建及组装对象间依赖关系，只需要改配置文件即可，无需重新编译。所以，<strong>Spring能帮我们根据配置文件创建及组装对象之间的依赖关系</strong>。</p>
</li>
<li><p>当我们要进行一些日志记录、权限控制、性能统计等时，在传统应用程序当中我们可能在需要的对象或方法中进行，而且比如权限控制、性能统计大部分是重复的，这样代码中就存在大量重复代码，即使有人说我把通用部分提取出来，那必然存在调用还是存在重复，像性能统计我们可能只是在必要时才进行，在诊断完毕后要删除这些代码；还有日志记录，比如记录一些方法访问日志、数据访问日志等等，这些都会渗透到各个访问方法中；还有权限控制，必须在方法执行开始进行审核，想想这些是多么可怕而且是多么无聊的工作。如果采用Spring，这些日志记录、权限控制、性能统计从业务逻辑中分离出来，通过Spring支持的面向切面编程，在需要这些功能的地方动态添加这些功能，无需渗透到各个需要的方法或对象中；有人可能说了，我们可以使用“代理设计模式”或“包装器设计模式”，你可以使用这些，但还是需要通过编程方式来创建代理对象，还是要耦合这些代理对象，而采用Spring 面向切面编程能提供一种更好的方式来完成上述功能，一般通过配置方式，而且不需要在现有代码中添加任何额外代码，现有代码专注业务逻辑。所以，<strong>Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制</strong>。</p>
</li>
<li><p>在传统应用程序当中，我们如何来完成数据库事务管理？需要一系列“获取连接，执行SQL，提交或回滚事务，关闭连接”，而且还要保证在最后一定要关闭连接，多么可怕的事情，而且也很无聊；如果采用Spring，我们只需获取连接，执行SQL，其他的都交给Spring来管理了，简单吧。所以，<strong>Spring能非常简单的帮我们管理数据库事务</strong>。</p>
</li>
<li><p>Spring还能与第三方数据库访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板，来方便数据库访问。</p>
</li>
<li><p>Spring还能与第三方Web（如Struts、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。</p>
</li>
<li><p>Spring能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</p>
</li>
</ul>
<p>Spring能帮我们做这么多事情，提供这么多功能和与那么多主流技术整合，而且是帮我们做了开发中比较头疼和困难的事情，那可能有人会问，难道只有Spring这一个框架，没有其他选择？当然有，比如EJB需要依赖应用服务器、开发效率低、在开发中小型项目是宰鸡拿牛刀，虽然发展到现在，EJB已经比较好用了，但还是比较笨重还需要依赖应用服务器等。那为何需要使用Spring，而不是其他框架呢？让我们接着往下看。</p>
<h3 id="3-为何需要Spring"><a href="#3-为何需要Spring" class="headerlink" title="3.为何需要Spring"></a>3.为何需要Spring</h3><h4 id="1-首先阐述几个概念"><a href="#1-首先阐述几个概念" class="headerlink" title="1).首先阐述几个概念"></a>1).首先阐述几个概念</h4><ul>
<li><p>应用程序：是能完成我们所需要功能的成品，比如购物网站、OA系统。</p>
</li>
<li><p>框架：是能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，这样应用程序就创建出来了。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们开发，让我们专注于业务逻辑开发。</p>
</li>
<li><p>非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。</p>
</li>
<li><p>轻量级及重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。</p>
</li>
<li><p>POJO：POJO（Plain Old Java Objects）简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。</p>
</li>
<li><p>容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。</p>
</li>
<li><p>控制反转：即Inversion of Control，缩写为IoC，控制反转还有一个名字叫做依赖注入（Dependency Injection），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。</p>
</li>
<li><p>Bean：一般指容器管理对象，在Spring中指Spring IoC容器管理对象。</p>
</li>
</ul>
<h4 id="2-为什么需要Spring及Spring的优点"><a href="#2-为什么需要Spring及Spring的优点" class="headerlink" title="2).为什么需要Spring及Spring的优点"></a>2).为什么需要Spring及Spring的优点</h4><ul>
<li><p>非常轻量级的容器：以集中的、自动化的方式进行应用程序对象创建和装配，负责对象创建和装配，管理对象生命周期，能组合成复杂的应用程序。Spring容器是非侵入式的（不需要依赖任何Spring特定类），而且完全采用POJOs进行开发，使应用程序更容易测试、更容易管理。而且核心JAR包非常小，Spring3.0.5不到1M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE或Java EE）。</p>
</li>
<li><p>AOP：AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日志记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</p>
</li>
<li><p>简单的数据库事务管理：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring支持可插入的事务管理支持，而且无需JavaEE环境支持，通过Spring管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</p>
</li>
<li><p>JDBC抽象及ORM框架支持：Spring使JDBC更加容易使用；提供DAO（数据访问对象）支持，非常方便集成第三方ORM框架，比如Hibernate等；并且完全支持Spring事务和使用Spring提供的一致的异常体系。</p>
</li>
<li><p>灵活的Web层支持：Spring本身提供一套非常强大的MVC框架，而且可以非常容易的与第三方MVC框架集成，比如Struts等。</p>
</li>
<li><p>简化各种技术集成：提供对Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service等的集成。</p>
</li>
</ul>
<p>Spring能帮助我们简化应用程序开发，帮助我们创建和组装对象，为我们管理事务，简单的MVC框架，可以把Spring看作是一个超级粘合平台，能把很多技术整合在一起，形成一个整体，使系统结构更优良、性能更出众，从而加速我们程序开发，有如上优点，我们没有理由不考虑使用它。</p>
<h3 id="4-如何学好Spring"><a href="#4-如何学好Spring" class="headerlink" title="4.如何学好Spring"></a>4.如何学好Spring</h3><p>要学好Spring，首先要明确Spring是个什么东西，能帮我们做些什么事情，知道了这些然后做个简单的例子，这样就基本知道怎么使用Spring了。Spring核心是IoC容器，所以一定要透彻理解什么是IoC容器，以及如何配置及使用容器，其他所有技术都是基于容器实现的；理解好IoC后，接下来是面向切面编程，首先还是明确概念，基本配置，最后是实现原理，接下来就是数据库事务管理，其实Spring管理事务是通过面向切面编程实现的，所以基础很重要，IoC容器和面向切面编程搞定后，其余都是基于这俩东西的实现，学起来就更加轻松了。要学好Spring不能急，一定要把基础打牢，基础牢固了，学起来就会很快，这就是磨刀不误砍柴工。</p>
<h2 id="二、Spring基础"><a href="#二、Spring基础" class="headerlink" title="二、Spring基础"></a>二、Spring基础</h2><h3 id="1-Spring架构图"><a href="#1-Spring架构图" class="headerlink" title="1.Spring架构图"></a>1.Spring架构图</h3><p><img src="http://docs.spring.io/spring-framework/docs/3.2.0.M1/reference/htmlsingle/images/spring-overview.png" alt="Spring架构图"></p>
<p>图 1-1 Spring架构图   </p>
<h4 id="1-核心容器：包括Core、Beans、Context、EL模块。"><a href="#1-核心容器：包括Core、Beans、Context、EL模块。" class="headerlink" title="1).核心容器：包括Core、Beans、Context、EL模块。"></a>1).核心容器：包括Core、Beans、Context、EL模块。</h4><ul>
<li><p>Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</p>
</li>
<li><p>Beans模块：提供了框架的基础部分，包括反转控制和依赖注入。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。</p>
</li>
<li><p>Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；核心接口是ApplicationContext。</p>
</li>
<li><p>EL模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</p>
</li>
</ul>
<h4 id="2-AOP、Aspects模块："><a href="#2-AOP、Aspects模块：" class="headerlink" title="2).AOP、Aspects模块："></a>2).AOP、Aspects模块：</h4><ul>
<li><p>AOP模块：Spring AOP模块提供了符合 AOP Alliance规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。</p>
</li>
<li><p>Aspects模块：提供了对AspectJ的集成，AspectJ提供了比Spring ASP更强大的功能。</p>
</li>
</ul>
<p>数据访问/集成模块：该模块包括了JDBC、ORM、OXM、JMS和事务管理。</p>
<ul>
<li><p>事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。</p>
</li>
<li><p>JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</p>
</li>
<li><p>ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、MyBatis等。而且可以使用Spring事务管理，无需额外控制事务。</p>
</li>
<li><p>OXM模块：提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。</p>
</li>
<li><p>JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
</li>
<li><p>Web/Remoting模块：Web/Remoting模块包含了Web、Web-Servlet、Web-Struts、Web-Porlet模块。</p>
</li>
<li><p>Web模块：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。</p>
</li>
<li><p>Web-Servlet模块：提供了一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的JSP标签，完全无缝与Spring其他技术协作。</p>
</li>
<li><p>Web-Struts模块：提供了与Struts无缝集成，Struts1.x 和Struts2.x都支持</p>
</li>
<li><p>Test模块： Spring支持Junit和TestNG测试框架，而且还额外提供了一些基于Spring的测试功能，比如在测试Web框架时，模拟Http请求的功能。</p>
</li>
</ul>
<h3 id="2-典型应用场景"><a href="#2-典型应用场景" class="headerlink" title="2.典型应用场景"></a>2.典型应用场景</h3><p>Spring可以应用到许多场景，从最简单的标准Java SE程序到企业级应用程序都能使用Spring来构建。以下介绍几个比较流行的应用场景：</p>
<ul>
<li><p>典型Web应用程序应用场景：</p>
<p><img src="http://docs.spring.io/spring-framework/docs/3.2.0.M1/reference/htmlsingle/images/overview-full.png" alt="web应用程序应用场景"></p>
</li>
</ul>
<p>图1-2 web应用程序应用场景</p>
<ul>
<li>远程访问应用场景：</li>
</ul>
<p><img src="http://docs.spring.io/spring-framework/docs/3.2.0.M1/reference/htmlsingle/images/overview-remoting.png" alt="远程访问应用场景"></p>
<ul>
<li>EJB应用场景：</li>
</ul>
<p><img src="http://docs.spring.io/spring-framework/docs/3.2.0.M1/reference/htmlsingle/images/overview-ejb.png" alt="EJB应用场景"></p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>本节介绍了什么是Spring，Spring是一个容器，通过控制反转和依赖注入来实现高内聚、低耦合的应用，除此之外它可以整合很多第三方框架，它还提供AOP的能力，对数据库事务的管理尤其方便。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Subsets]]></title>
      <url>http://codeinterviews.com/Subsets/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Subsets</p>
<blockquote>
<p>Given a set of distinct integers, S, return all possible subsets.</p>
<p><strong>Note</strong>:    </p>
<ul>
<li>Elements in a subset must be in non-descending order.   </li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p>For example,<br>If S = <code>[1,2,3]</code>, a solution is:</p>
<pre><code>[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题用到的还是<a href="http://pisxw.com/algorithm/N-Queens.html" target="_blank" rel="external">N-Queens</a>中的方法：用一个循环递归处理子问题。<a href="http://pisxw.com/algorithm/Combinations.html" target="_blank" rel="external">Combinations</a>这题是考虑集合长度<code>K</code>固定的情况，而该题中集合长度<code>K</code>是不固定的，是从<code>0</code>到<code>S.length()</code>，所以可以将<code>Combinations</code>这题作为该题的子程序，由于题目中要求结果集合中元素应该是有序的，所以开始的时候先将<code>S</code>进行排序。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] S) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); </span><br><span class="line">        <span class="keyword">if</span>(S==<span class="keyword">null</span> || S.length==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(S);</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	helper(S,i,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(), res); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] S, <span class="keyword">int</span> k, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; item, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span>  </span><br><span class="line">    </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(item.size()==k)  </span><br><span class="line">        &#123;  </span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(item));  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;S.length;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            item.add(S[i]);  </span><br><span class="line">            helper(S,k,i+<span class="number">1</span>,item,res);  </span><br><span class="line">            item.remove(item.size()-<span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Substring with Concatenation of All Words]]></title>
      <url>http://codeinterviews.com/Substring-with-Concatenation-of-All-Words/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Substring with Concatenation of All Words </p>
<blockquote>
<p>You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.</p>
<p>For example, given:<br>S: “barfoothefoobarman”<br>L: [“foo”, “bar”]</p>
<p>You should return the indices: [0,9].<br>(order does not matter).</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>思路仍然是维护一个窗口，如果当前单词在字典中，则继续移动窗口右端，否则窗口左端可以跳到字符串下一个单词了。假设源字符串的长度为n，字典中单词的长度为l。因为不是一个字符，所以我们需要对源字符串所有长度为l的子串进行判断。做法是i从0到l-1个字符开始，得到开始index分别为i, i+l, i+2<em>l,的长度为l的单词。这样就可以保证判断到所有的满足条件的串。因为每次扫描的时间复杂度是O(2</em>n/l)(每个单词不会被访问多于两次，一次是窗口右端，一次是窗口左端)，总共扫描l次（i=0, …, l-1)，所以总复杂度是O(2<em>n/l</em>l)=O(n)，是一个线性算法。空间复杂度是字典的大小，即O(m*l)，其中m是字典的单词数量。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String S, String[] L)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(L.length==<span class="number">0</span>||S.length()==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> wordlen=L[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">//map中存放L</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">            Integer value=map.get(L[i]);</span><br><span class="line">            <span class="keyword">if</span>(value==<span class="keyword">null</span>)</span><br><span class="line">                value=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                value+=<span class="number">1</span>;</span><br><span class="line">            map.put(L[i],value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+wordlen&lt;=S.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + wordlen * L.length &gt; S.length())&#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="keyword">if</span>(map.containsKey(S.substring(i,i+wordlen)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">boolean</span> b=checkString(S.substring(i,i+wordlen*L.length),<span class="keyword">new</span> HashMap&lt;String,Integer&gt;(map),wordlen);</span><br><span class="line">                <span class="keyword">if</span>(b==<span class="keyword">true</span>)</span><br><span class="line">                    result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查字符串S是不是map中字符串的组合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s,HashMap&lt;String,Integer&gt; map,<span class="keyword">int</span> wordlen)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(s.length()&gt;<span class="number">0</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		String temp=s.substring(<span class="number">0</span>,wordlen);</span><br><span class="line">    		Integer value=map.get(temp);</span><br><span class="line">    		<span class="keyword">if</span>(value==<span class="keyword">null</span>||value==<span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			flag=<span class="keyword">false</span>;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			value-=<span class="number">1</span>;</span><br><span class="line">    			map.put(temp,value);</span><br><span class="line">    			s=s.substring(wordlen);</span><br><span class="line">    		&#125;</span><br><span class="line">    			</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Sudoku Solver]]></title>
      <url>http://codeinterviews.com/Sudoku-Solver/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Sudoku Solver</p>
<blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character <code>&#39;.&#39;</code>.</p>
<p>You may assume that there will be only one unique solution.</p>
<p><img src="/img/SuDoKu/2.png" alt=""></p>
<p>A sudoku puzzle…</p>
<p><img src="/img/SuDoKu/3.png" alt=""></p>
<p>…and its solution numbers marked in red.<br><a id="more"></a></p>
</blockquote>
<p>##解题思路<br>该题是求解数独问题，思路就是循环处理子问题，对于每个格子，带入不同的9个数，然后判合法，如果成立就递归继续，结束后把数字设为空。其中每个格子中不同的元素相当于一个状态，这样可以看成是一个状态转换问题，可以采用<strong>深度优先搜索</strong>进行求解。<br>判合法可以用Valid Sudoku做为subroutine，但是其实在这里因为每次进入时已经保证之前的board不会冲突，所以不需要判断整个盘，只需要看当前加入的数字的行，列和方格中是否合法即可。这样可以大大提高运行效率，毕竟判合法在程序中被多次调用。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length != <span class="number">9</span> || board[<span class="number">0</span>].length !=<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    helper(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">9</span>)</span><br><span class="line">            <span class="keyword">return</span> helper(board,i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j]==<span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">9</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(k+<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(isValid(board,i,j))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(helper(board,i,j+<span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(board,i,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k!=j &amp;&amp; board[i][k]==board[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k!=i &amp;&amp; board[k][j]==board[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = i/<span class="number">3</span>*<span class="number">3</span>; row&lt;i/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>; row++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=j/<span class="number">3</span>*<span class="number">3</span>; col&lt;j/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>; col++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((row!=i || col!=j) &amp;&amp; board[row][col]==board[i][j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Sum Root to Leaf Numbers]]></title>
      <url>http://codeinterviews.com/Sum-Root-To-Leaf-Numbers/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Sum Root to Leaf Numbers</p>
<blockquote>
<p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>For example,</p>
<pre><code>  1
 / \
2   3
</code></pre><p>The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br>The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.     </p>
<p>Return the <code>sum = 12 + 13 = 25</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这是一道树的题目，一般使用递归来做，主要就是考虑递归条件和结束条件。这道题思路还是比较明确的，目标是把从根到叶子节点的所有路径得到的整数都累加起来，递归条件即是把当前的sum乘以10并且加上当前节点传入下一函数，进行递归，最终把左右子树的总和相加。结束条件的话就是如果一个节点是叶子，那么我们应该累加到结果总和中，如果节点到了空节点，则不是叶子节点，不需要加入到结果中，直接返回0即可</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> helper(root,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)</span><br><span class="line">	        <span class="keyword">return</span> sum*<span class="number">10</span>+root.val;</span><br><span class="line">	    <span class="keyword">return</span> helper(root.left,sum*<span class="number">10</span>+root.val)+helper(root.right,sum*<span class="number">10</span>+root.val); <span class="comment">//加上左右子树中所有路径的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Add Binary]]></title>
      <url>http://codeinterviews.com/Add-Binary/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Add Binary</p>
<blockquote>
<p>Given two binary strings, return their sum (also a binary string).</p>
<p>For example,<br>a = <code>&quot;11&quot;</code><br>b = <code>&quot;1&quot;</code><br>Return <code>&quot;100&quot;</code>.   </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对两个二进制进行求和，这里维护一个进位，分别对<code>a</code>和<code>b</code>从后往前，每一位进行求和，然后<code>/2</code>得到进位，<code>%2</code>得到该位的值。如果<code>a</code>和<code>b</code>长度不一样，则最终还要遍历完长度长的那个字符串。如果最终位也存在进位的情况，则需要将进位放入结果中。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="keyword">null</span> ||a.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="keyword">null</span> ||b.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">char</span>[] a_char=a.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] b_char=b.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> jinwei=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=a_char.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=b_char.length-<span class="number">1</span>;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();  <span class="comment">//结果先存在其中，最后通过转置得到结果</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> numa=a_char[i]-<span class="string">'0'</span>;</span><br><span class="line">        	<span class="keyword">int</span> numb=b_char[j]-<span class="string">'0'</span>;</span><br><span class="line">        	<span class="keyword">int</span> num=(numa+numb+jinwei)%<span class="number">2</span>;</span><br><span class="line">        	jinwei=(numa+numb+jinwei)/<span class="number">2</span>;</span><br><span class="line">        	res.append(num);</span><br><span class="line">        	i--;</span><br><span class="line">        	j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)  <span class="comment">//b字符串已经结束</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> numa=a_char[i]-<span class="string">'0'</span>;</span><br><span class="line">        	<span class="keyword">int</span> num=(numa+jinwei)%<span class="number">2</span>;</span><br><span class="line">        	jinwei=(numa+jinwei)/<span class="number">2</span>;</span><br><span class="line">        	res.append(num);</span><br><span class="line">        	i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)  <span class="comment">//a字符串已经结束</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> numb=b_char[j]-<span class="string">'0'</span>;</span><br><span class="line">        	<span class="keyword">int</span> num=(numb+jinwei)%<span class="number">2</span>;</span><br><span class="line">        	jinwei=(numb+jinwei)/<span class="number">2</span>;</span><br><span class="line">        	res.append(num);</span><br><span class="line">        	j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jinwei!=<span class="number">0</span>)   <span class="comment">//最高位存在进位</span></span><br><span class="line">        	res.append(jinwei);</span><br><span class="line">        res.reverse();</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Swap Nodes in Pairs]]></title>
      <url>http://codeinterviews.com/Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Swap Nodes in Pairs</p>
<blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对链表中的两个相邻的节点进行交换。这里可以使用<strong>递归</strong>的思想来求解该问题。因为对整个链表进行交换，也包含对子链表的交换。由于题目中不允许开辟新的空间，只能通过对节点间的链接关系进行调整，因此需要仔细考虑链接的问题。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//采用递归求解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newhead=head.next; <span class="comment">//新的头结点</span></span><br><span class="line">        ListNode node=head.next.next; <span class="comment">//下次递归的头结点</span></span><br><span class="line">        newhead.next=head;</span><br><span class="line">        head.next=swapPairs(node); <span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tachyon如何解决spark中的数据共享和缓存问题]]></title>
      <url>http://codeinterviews.com/Tachyon%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3spark%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E5%92%8C%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>Tachyon是一款基于内存的分布式文件系统，主要致力于解决不同计算框架之间的数据共享问题。</p>
<p>基于内存的特性减少了不同计算框架依赖底层存储系统，如HDFS，带来的磁盘和网络IO问题。而且起初的目标主要是在spark生态系统中，解决不同application之间的RDD共享问题，后来演化成一个独立的项目，解决不同类型应用间数据共享问题。</p>
<a id="more"></a>
<p>##spark中存在的问题<br>spark是基于内存的计算框架，在计算方面大大领先mapreduce。但是由于spark是基于jvm，jvm的限制使得spark在数据的共享和缓存方面存在瓶颈。</p>
<p>####数据共享<br>同一集群中，可能会运行着多个不同的计算框架，比如MapReduce和Spark，在现有条件下，两个框架如果需要共享数据必须通过共享存储实现（HDFS）。而HDFS的访问则会引起磁盘和网络的IO，因此这是一个很低效的过程。</p>
<p>####缓存数据丢失<br>Spark运行在JVM上，现有的缓存机制使用block manager把数据缓存在JVM堆内存中。一旦执行引擎崩溃，缓存数据丢失。</p>
<p>####GC开销<br>数据缓存在JVM堆内存空间中，GC开销随应用程序运行时间和堆内存空间中缓存数据量的增长而迅速增长。</p>
<p>而之所以产生这些问题，其根本原因在于缺乏独立的脱离JVM管理的内存管理模块。首先，缺乏独立的内存管理模块，从而造成了数据共享上的问题，这主要是因为现有Spark的内存管理处于执行引擎中，所有的数据管理都在一个application（或者框架）内部，因此脱离了这个application，在内存中缓存的数据就无法被访问。其次，JVM管理，当下所有数据都储存于JVM的堆内存空间中，因此无法避免GC的开销；那么，想避免GC开销，数据必须要脱离JVM。而这些正是Tachyon的设计初衷，一个脱离JVM管理的内存管理模块。</p>
<p>##tachyon的解决方案<br>针对上述问题，使用tachyon可以很好的进行解决。</p>
<p>####数据共享<br>通过Tachyon来储存中间结果，避免了数据落到磁盘上，以实现内存数据共享。同时，绕过了HDFS可以减少因此造成的磁盘和网络IO。</p>
<p>####缓存数据丢失<br>因为所有缓存数据都储存在Tachyon的OffHeap空间中，由Spark任务异常造成的JVM崩溃将不会引发数据丢失。</p>
<p>####GC开销<br>因为所有缓存数据储存于Tachyon，从而就会解决GC的问题。需要注意的是，Tachyon解决的是缓存数据带来的GC，而非Spark任务执行过程中的GC。</p>
<p>##总结<br>Tachyon的兴起，带来了基于内存的分布式文件系统，这为不同计算框架的数据共享提供了很好的解决方案，而且基于内存的特性，使得其避免了磁盘和网络IO带来的开销，对计算速度有了一定的保证。除此之外，其脱离jvm的数据缓存功能，减少了jvm中的GC消耗，并根据数据的lineage提供了数据的容错。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Text Justification]]></title>
      <url>http://codeinterviews.com/Text-Justification/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Text Justification</p>
<blockquote>
<p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>For example,<br><strong>words</strong>: <code>[&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</code><br><strong>L</strong>: <code>16</code>.</p>
<p>Return the formatted lines as:  </p>
<pre><code>[
   &quot;This    is    an&quot;,
   &quot;example  of text&quot;,
   &quot;justification.  &quot;
]
</code></pre><p><strong>Note</strong>: Each word is guaranteed not to exceed L in length.</p>
<p><strong>Corner Cases</strong>:<br>A line other than the last line might contain only one word. What should you do in this case?<br>In this case, that line should be left-justified.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题属于纯粹的字符串操作，要把一串单词安排成多行限定长度的字符串。<br>主要难点在于空格的安排，首先每个单词之间必须有空格隔开，而当当前行放不下更多的单词并且字符又不能填满长度<code>L</code>时，我们要把空格均匀的填充在单词之间。如果剩余的空格量刚好是间隔倍数那么就均匀分配即可，否则还必须把多的空格依次从左往右放到前面的间隔里面。最后一个细节就是最后一行不需要均匀分配空格，句尾留空就可以，所以要单独处理一下。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">	    <span class="keyword">if</span>(words==<span class="keyword">null</span> || words.length==<span class="number">0</span>)  </span><br><span class="line">	        <span class="keyword">return</span> res;  </span><br><span class="line">	    <span class="keyword">int</span> first=<span class="number">0</span>; <span class="comment">//一行中第一个单词的位置</span></span><br><span class="line">	    <span class="keyword">int</span> last=<span class="number">0</span>;  <span class="comment">//一行中最后一个单词的位置</span></span><br><span class="line">	    <span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">//一行中的字符数(不包括空格)</span></span><br><span class="line">	    <span class="keyword">for</span>(;last&lt;words.length;last++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="keyword">if</span>((count+words[last].length()+last-first)&gt;L)  <span class="comment">//last-first表示单词间隔数,因为单词之间至少一个空格</span></span><br><span class="line">	    	&#123;</span><br><span class="line">	    		last--; <span class="comment">//最后一个单词不满足</span></span><br><span class="line">	    		<span class="keyword">int</span> konggenum=L-count;</span><br><span class="line">	    		<span class="comment">//判断空格是否可以被间隔均分</span></span><br><span class="line">	    		<span class="keyword">int</span> isjunfen=<span class="number">0</span>;</span><br><span class="line">	    		<span class="keyword">int</span> countkongge=<span class="number">0</span>;</span><br><span class="line">	    		<span class="keyword">if</span>((last-first)&gt;<span class="number">0</span>)</span><br><span class="line">	    		&#123;</span><br><span class="line">	    			isjunfen=konggenum%(last-first);</span><br><span class="line">	    			countkongge=konggenum/(last-first);</span><br><span class="line">	    		&#125;</span><br><span class="line">	    		StringBuilder row=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">	    		<span class="keyword">for</span>(<span class="keyword">int</span> j=first;j&lt;=last;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					row.append(words[j]);</span><br><span class="line">					<span class="keyword">if</span>(j&lt;last)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;countkongge;i++)</span><br><span class="line">							row.append(<span class="string">" "</span>);</span><br><span class="line">						<span class="keyword">if</span>(isjunfen&gt;<span class="number">0</span>) <span class="comment">//不可以均分 ，多出的空格依次放在左边</span></span><br><span class="line">							row.append(<span class="string">" "</span>);</span><br><span class="line">						isjunfen--;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=row.length();j&lt;L;j++)  </span><br><span class="line">	            &#123;  </span><br><span class="line">	                row.append(<span class="string">" "</span>);  </span><br><span class="line">	            &#125;    </span><br><span class="line">    			res.add(row.toString());</span><br><span class="line">    			first=last+<span class="number">1</span>;</span><br><span class="line">    			count=<span class="number">0</span>;	</span><br><span class="line"></span><br><span class="line">	    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    		count+=words[last].length();</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">//单独处理最后一行.因为最后一行的空格分布与前面不一样</span></span><br><span class="line">	    StringBuilder row=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;words.length;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	row.append(words[i]); </span><br><span class="line">	    	<span class="keyword">if</span>(row.length()&lt;L)</span><br><span class="line">	    		row.append(<span class="string">" "</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=row.length();i&lt;L;i++)  </span><br><span class="line">	    &#123;  </span><br><span class="line">	        row.append(<span class="string">" "</span>);  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    res.add(row.toString());</span><br><span class="line">	    <span class="keyword">return</span> res;    	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-The Skyline Problem]]></title>
      <url>http://codeinterviews.com/The-Skyline-Problem/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####The Skyline Problem</p>
<blockquote>
<p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <strong>given the locations and height of all the buildings</strong> as shown on a cityscape photo (Figure A), write a program to <strong>output the skyline</strong> formed by these buildings collectively (Figure B).<br>![][1]<br>![][2]<br>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ]</code>.</p>
<p>The output is a list of <strong>“key points”</strong> (red dots in Figure B) in the format of<code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code>that uniquely defines a skyline. <strong>A key point is the left endpoint of a horizontal line segment</strong>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
</blockquote>
<p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>
<blockquote>
<p>####Notes:</p>
<ul>
<li>The number of buildings in any input list is guaranteed to be in the range <code>[0, 10000]</code>.</li>
<li>The input list is already sorted in ascending order by the left x position <code>Li</code>.</li>
<li>The output list must be sorted by the x position.</li>
<li>There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...[2 3], [4 5], [12 7], ...]</code></li>
</ul>
<p>####Credits:<br>Special thanks to @stellari for adding this problem, creating these two awesome images and all test cases.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是一个求解SkyLine的问题，其实就是找到那些前后<strong>高度变化</strong>的关键点，在这里我也没有想到非常好的解，可以直接采用顺序遍历的方法求解。</p>
<p>首先定义个数组记录每个位置的skyline高度，然后顺序进入每栋楼，更新每个位置的skyline高度，最后再一次遍历这个数组，如果发现前后两个点的skyline高度发生了改变，则说明这个点就是关键点。 </p>
<p>但是这个有个问题，是开出的数组太大，里面最大的楼的右坐标位置为Integer.MAX_VALUE.因此会造成整个数组的越界。</p>
<p><strong>问题并未解决</strong></p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">    	List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">if</span>(buildings==<span class="keyword">null</span> || buildings.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义数组来记录每个x坐标位置的Skyline高度</span></span><br><span class="line">        <span class="comment">//这个高度应该是这个x位置的最大高度</span></span><br><span class="line">        <span class="keyword">int</span> R=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buildings.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	R=Math.max(R,buildings[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] skylineHeigh=<span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line">        <span class="comment">//记录全部楼中的最大的右左边</span></span><br><span class="line">      	</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buildings.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> l=buildings[i][<span class="number">0</span>];</span><br><span class="line">        	<span class="keyword">int</span> r=buildings[i][<span class="number">1</span>];</span><br><span class="line">        	<span class="keyword">int</span> h=buildings[i][<span class="number">2</span>];</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)&#123;</span><br><span class="line">        		skylineHeigh[j]=Math.max(skylineHeigh[j],h);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选取所有的关键点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(skylineHeigh[i]!=skylineHeigh[i-<span class="number">1</span>])&#123;</span><br><span class="line">        		<span class="keyword">int</span>[] tmp=&#123;i,skylineHeigh[i]&#125;;</span><br><span class="line">        		res.add(tmp);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[1]:img/The Skyline Problem/1.png<br>[2]:img/The Skyline Problem/2.png</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Trapping Rain Water]]></title>
      <url>http://codeinterviews.com/Trapping-Rain-Water/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Trapping Rain Water </p>
<blockquote>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p>
<p><img src="/img/Trapping-Rain-Water/1.png" alt=""></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与<a href="http://pisxw.com/algorithm/Candy.html" target="_blank" rel="external">Candy</a>类似，挨个分析每个A[i]能trapped water的容量，然后将所有的A[i]的trapped water容量相加即可。</p>
<p>其次，对于每个A[i]能trapped water的容量，取决于A[i]左右两边的高度（可延展）较小值与A[i]的差值，即volume[i] = [min(left[i], right[i]) - A[i]] * 1，这里的1是宽度，如果the width of each bar is 2,那就要乘以2了”</p>
<p>那么如何求A[i]的左右高度呢？ 要知道，能盛多少水主要看短板。那么对每个A[i]来说，要求一个最高的左短板，再求一个最高的右短板，这两个直接最短的板子减去A[i]原有的值就是能成多少水了。</p>
<p>所以需要两遍遍历，一个从左到右，找最高的左短板；一个从右到左，找最高的右短板。最后记录下盛水量的总值就是最终结果了。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">       		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       	<span class="keyword">int</span>[] leftmax=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">       	<span class="keyword">int</span>[] rightmax=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">       	<span class="keyword">int</span>[] container=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//计算每个bar左边的最大值</span></span><br><span class="line">       	leftmax[<span class="number">0</span>]=A[<span class="number">0</span>];</span><br><span class="line">       	<span class="keyword">int</span> max=A[<span class="number">0</span>];</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)</span><br><span class="line">       	&#123;</span><br><span class="line">       		max=Math.max(max,A[i]);</span><br><span class="line">       		leftmax[i]=max;</span><br><span class="line">       	&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//计算每个bar右边的最大值</span></span><br><span class="line">       	rightmax[A.length-<span class="number">1</span>]=A[A.length-<span class="number">1</span>];</span><br><span class="line">       	max=A[A.length-<span class="number">1</span>];</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">       	&#123;</span><br><span class="line">       		max=Math.max(max,A[i]);</span><br><span class="line">       		rightmax[i]=max;</span><br><span class="line">       	&#125;</span><br><span class="line"></span><br><span class="line">       	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)</span><br><span class="line">       	&#123;</span><br><span class="line">       		container[i]=Math.min(leftmax[i],rightmax[i])-A[i];</span><br><span class="line">       		res+=container[i];</span><br><span class="line">       	&#125;</span><br><span class="line">       	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Add and Search Word - Data structure design]]></title>
      <url>http://codeinterviews.com/Add-and-Search-Word%20-%20Data-structure-design/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Add and Search Word - Data structure design</p>
<blockquote>
<p>Design a data structure that supports the following two operations:</p>
<pre><code>void addWord(word)
bool search(word)
</code></pre><p>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p>For example:</p>
<pre><code>addWord(&quot;bad&quot;)
addWord(&quot;dad&quot;)
addWord(&quot;mad&quot;)
search(&quot;pad&quot;) -&gt; false
search(&quot;bad&quot;) -&gt; true
search(&quot;.ad&quot;) -&gt; true
search(&quot;b..&quot;) -&gt; true
</code></pre><p>######Note:<br>You may assume that all words are consist of lowercase letters a-z.</p>
<p>click to show hint.<br>You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题的思路与<a href="http://pisxw.com/algorithm/Implement-Trie-%28Prefix%20Tree%29.html" target="_blank" rel="external">Implement Trie (Prefix Tree)</a>类似,都是trie树的应用。使用trie树进行单词的查找，是一个比较通用的方法。但是这里在搜索单词的时候需要满足正则表达式的要求，即单词中包含了‘.’。因此需要采用递归的方法进行深度优先搜寻，并进行回溯。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//定义节点的数据结构</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">		 <span class="keyword">char</span> content; <span class="comment">//节点内容</span></span><br><span class="line">		 <span class="keyword">boolean</span> isEnd; <span class="comment">//是否是一个单词的结尾</span></span><br><span class="line">		 LinkedList&lt;TrieNode&gt; children;<span class="comment">//所有的孩子节点</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;  <span class="comment">//根结点无内容的构造方法</span></span><br><span class="line">			<span class="keyword">this</span>.content=<span class="string">' '</span>;</span><br><span class="line">			<span class="keyword">this</span>.isEnd=<span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">this</span>.children=<span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> content)</span></span>&#123;  <span class="comment">//有内容信息的节点</span></span><br><span class="line">			<span class="keyword">this</span>.content=content;</span><br><span class="line">			<span class="keyword">this</span>.isEnd=<span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">this</span>.children=<span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//在当前节点的孩子节点中查找是否存在内容为content的节点</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> TrieNode <span class="title">subNode</span><span class="params">(<span class="keyword">char</span> content)</span></span>&#123; </span><br><span class="line">			<span class="keyword">if</span>(children!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span>(TrieNode child:children)&#123;</span><br><span class="line">					<span class="keyword">if</span>(child.content==content)</span><br><span class="line">						<span class="keyword">return</span> child;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义个单词查找树，就是Trie树</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> TrieNode root;  <span class="comment">//根结点</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span></span>&#123;</span><br><span class="line">		root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a word into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(search(word)==<span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">    	TrieNode current=root;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)&#123;</span><br><span class="line">    		TrieNode node=current.subNode(word.charAt(i));</span><br><span class="line">    		<span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123; <span class="comment">//孩子节点中不存在这个字符，则添加</span></span><br><span class="line">    			TrieNode newNode=<span class="keyword">new</span> TrieNode(word.charAt(i));</span><br><span class="line">    			current.children.add(newNode);</span><br><span class="line">    			current=current.subNode(word.charAt(i));</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			current=node;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	current.isEnd=<span class="keyword">true</span>;<span class="comment">//设定单词结束的标记</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the data structure. A word could</span></span><br><span class="line">    <span class="comment">// contain the dot character '.' to represent any one letter.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> helper(root,word,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TrieNode rootnode,String word,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    	TrieNode current=rootnode;</span><br><span class="line">    	<span class="comment">//这是一个递归方法，需要设定递归的出口</span></span><br><span class="line">    	<span class="keyword">if</span>(current==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">if</span>(start==word.length() &amp;&amp; current.isEnd==<span class="keyword">true</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(start&gt;=word.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span>(word.charAt(start)!=<span class="string">'.'</span>)</span><br><span class="line">    	&#123;	</span><br><span class="line">    		<span class="comment">//查找下一个字母，根据当前字母的情况进行递归</span></span><br><span class="line">    		<span class="keyword">return</span> helper(current.subNode(word.charAt(start)),word,start+<span class="number">1</span>);</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="comment">//对当前节点中的所有孩子节点进行判断</span></span><br><span class="line">    		LinkedList&lt;TrieNode&gt; cls=current.children;</span><br><span class="line">			<span class="keyword">if</span>(cls==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(TrieNode c:cls)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">boolean</span> re=helper(c,word,start+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(re==<span class="keyword">true</span>)</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// WordDictionary wordDictionary = new WordDictionary();</span></span><br><span class="line"><span class="comment">// wordDictionary.addWord("word");</span></span><br><span class="line"><span class="comment">// wordDictionary.search("pattern");</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Triangle]]></title>
      <url>http://codeinterviews.com/Triangle/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Triangle</p>
<blockquote>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle  </p>
<pre><code>[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
</code></pre><p>The minimum path sum from top to bottom is <code>11 (i.e., 2 + 3 + 5 + 1 = 11)</code>.</p>
<p>####Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解从顶到底中和最短的路径长度。我们可以发现，第i层中第j个元素，它所在的路径只能为第i-1层中第j个元素和第j-1个元素。因此后层的最小路径值必然和上一层的最小路径值有关。所以这里可以使用<strong>动态规划</strong>进行求解。</p>
<pre><code>首先定义维护量dp[i]:表示从顶到当前层第i个节点的最小路径长度
则下一层可以表示为：
dp[i]=num[i]+Math.min(dp[i],dp[i-1]);   i=1...row-1 这里不包括第一个和最后一个节点
</code></pre><p>然而如果对每一行从前往后计算，会造成dp[i]被覆盖的问题，因此只能从后往前计算.<br>当求到最后一行的时候，会得到每个节点的dp值，然后取一个最小的就是从顶到底的所有路径中的最小和。</p>
<p>这里采用常量的DP空间来保存中间求解的路径值，符合只是用线性的扩展空间。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle==<span class="keyword">null</span> || triangle.size()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numRows=triangle.size();</span><br><span class="line">        <span class="comment">//定义维护量</span></span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[numRows];</span><br><span class="line">        dp[<span class="number">0</span>]=triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);<span class="comment">//放入第一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//特殊处理第一个节点</span></span><br><span class="line">        	dp[i]=triangle.get(i).get(i)+dp[i-<span class="number">1</span>];</span><br><span class="line">        	<span class="comment">//从后往前依次遍历</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        	&#123;</span><br><span class="line">        		dp[j]=triangle.get(i).get(j)+Math.min(dp[j],dp[j-<span class="number">1</span>]);</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="comment">//特殊处理最后一个节点</span></span><br><span class="line">        	dp[<span class="number">0</span>]=triangle.get(i).get(<span class="number">0</span>)+dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最后一行每个节点的DP,求取最小值</span></span><br><span class="line">        <span class="keyword">int</span> min=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(dp[i]&lt;min)</span><br><span class="line">        		min=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Unique Binary Search Trees II]]></title>
      <url>http://codeinterviews.com/Unique-Binary-Search-Trees-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Unique Binary Search Trees II</p>
<blockquote>
<p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3
</code></pre><p>confused what <code>&quot;{1,#,2,3}&quot;</code> means? &gt; read more on how binary tree is serialized on OJ.</p>
</blockquote>
<p>####OJ’s Binary Tree Serialization:</p>
<blockquote>
<p>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example:</p>
<pre><code>  1
 / \
2   3
   /
  4
   \
    5
</code></pre><p>The above binary tree is serialized as <code>&quot;{1,2,3,#,#,4,#,#,5}&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是求解所有可行的二叉查找树,算法上还是用求解NP问题的方法来求解，也就是<a href="http://pisxw.com/algorithm/N-Queens.html" target="_blank" rel="external">N-Queens</a>中介绍的在循环中调用递归函数求解子问题。思路是每次一次选取一个结点为根，然后递归求解左右子树的所有结果，最后根据左右子树的返回的所有子树，依次选取然后接上（每个左边的子树跟所有右边的子树匹配，而每个右边的子树也要跟所有的左边子树匹配，总共有左右子树数量的乘积种情况），构造好之后作为当前树的结果返回。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; left = null; right = null; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>,n);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示从left节点到right节点构造可行的二叉查找树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;TreeNode&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	ArrayList&lt;TreeNode&gt; res=<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    	<span class="comment">//不存在这样的树</span></span><br><span class="line">    	<span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">    		res.add(<span class="keyword">null</span>); <span class="comment">//表示空树</span></span><br><span class="line">    		<span class="keyword">return</span> res;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//取left到right间每个节点作为根</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">//递归获取每个左子树和右子树的可行二叉查找树情况</span></span><br><span class="line">    		<span class="comment">// helper函数得到的是范围从left到right的所有满足条件的树~ 从left到right，我们选取i作为根，那么剩下的左子树就是left到i-1,右子树就是i+1到right~</span></span><br><span class="line">    		ArrayList&lt;TreeNode&gt; leftres=helper(left,i-<span class="number">1</span>);</span><br><span class="line">    		ArrayList&lt;TreeNode&gt; rightres=helper(i+<span class="number">1</span>,right);</span><br><span class="line">    		<span class="comment">//每个左边的子树跟所有右边的子树匹配，而每个右边的子树也要跟所有的左边子树匹配，总共有左右子树数量的乘积种情况</span></span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;leftres.size();j++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;rightres.size();k++)</span><br><span class="line">    			&#123;</span><br><span class="line">    				TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">    				root.left=leftres.get(j);</span><br><span class="line">    				root.right=rightres.get(k);</span><br><span class="line">    				res.add(root);</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Unique Binary Search Trees]]></title>
      <url>http://codeinterviews.com/Unique-Binary-Search-Trees/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Unique Binary Search Trees</p>
<blockquote>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
</blockquote>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3
</code></pre><a id="more"></a>
<p>##解题思路<br>这道题要求可行的二叉查找树的数量，其实二叉查找树可以任意取根，只要满足中序遍历有序的要求就可以。从处理子问题的角度来看，选取一个结点为根，就把结点切成左右子树，以这个结点为根的可行二叉树数量就是左右子树可行二叉树数量的乘积，所以总的数量是将以所有结点为根的可行结果累加起来.</p>
<p>这是一个典型的动态规划的定义方式（根据其实条件和递推式求解结果）。所以思路也很明确了，维护量res[i]表示含有i个结点的二叉查找树的数量。根据上述递推式依次求出1到n的的结果即可。</p>
<p>动态规划定义如下：</p>
<pre><code>res[i]:表示含有i个节点的可行二叉树的数量
其中res[0]=1,res[1]=1
res[i]+=res[j]*res[i-j+1] j=0,2....i-1
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//动态规划的初始条件</span></span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//i个节点的可行查找树个数为多个左右子树情况的乘积之和</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		res[i]+=res[j]*res[i-j-<span class="number">1</span>];</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Unique Paths II]]></title>
      <url>http://codeinterviews.com/Unique-Paths-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Unique Paths II</p>
<blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.   </p>
<pre><code>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
</code></pre><p>The total number of unique paths is <code>2</code>.</p>
</blockquote>
<p>Note: m and n will be at most 100.</p>
<a id="more"></a>
<p>##解题思路<br>该题是<a href="http://pisxw.com/algorithm/Unique-Paths.html" target="_blank" rel="external">Unique Paths</a>的扩展，思路类似，只是这边要处理障碍。动态规划的思路可以见那题。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(obstacleGrid==<span class="keyword">null</span> || obstacleGrid.length==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> m=obstacleGrid.length;</span><br><span class="line">    	<span class="keyword">int</span> n=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">//dp[i][j]表示从start到[i,j]位置不同路径条数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        		dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)   <span class="comment">//第一行障碍处理</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]!=<span class="number">1</span>)</span><br><span class="line">        		dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        	</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)   <span class="comment">//第一列障碍处理</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(obstacleGrid[j][<span class="number">0</span>]!=<span class="number">1</span>)</span><br><span class="line">        		dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)   <span class="comment">//如果该位置是障碍，则到达该点的路径条数为0</span></span><br><span class="line">        			dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        			dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        	&#125;		</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Unique Paths]]></title>
      <url>http://codeinterviews.com/Unique-Paths/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Unique Paths</p>
<blockquote>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?<br><img src="/img/Unique-Paths/1.png" alt=""></p>
<p>Above is a <code>3 x 7</code> grid. How many possible unique paths are there?</p>
<p><strong>Note</strong>: <code>m</code> and <code>n</code> will be at most 100.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题只能向前和向下走，这样右边和下边位置的路径条数依赖于前面，所以可以采用<strong>动态规划</strong>求解。</p>
<pre><code>定义dp[i][j]:表示从start到[i,j]位置的不同路径条数
递推公式为：
dp[i][j]=dp[i-1][j]+dp[i][j-1] //只有两个方向可以到达dp[i][j]
由于第一行和第一列的位置只有唯一条路径，所以初始化为：
dp[0][0]=1,dp[0][1]=1,.....dp[0][n-1]=1
dp[0][0]=1,dp[1][0]=1,.....dp[m-1][0]=1
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">//dp[i][j]表示从start到[i,j]位置不同路径条数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        	dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        	dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        		dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用Docker搭载本地的spark环境]]></title>
      <url>http://codeinterviews.com/Use-Docker-To-Build-Spark-Env/</url>
      <content type="html"><![CDATA[<p>最近换了新电脑，需要配置一下本地的spark环境，为了方便一次配置，到处运行，本文采用docker的容器机制来搭建本地的spark环境。</p>
<p>本人涉及docker不深，如有错误，希望大家多多包涵指教！么么哒，大家！</p>
<a id="more"></a>
<h2 id="一-下载docker并安装"><a href="#一-下载docker并安装" class="headerlink" title="一.下载docker并安装"></a>一.下载docker并安装</h2><p>首先根据自己电脑的信息下载对应的docker，我的电脑是mac,os的版本为10.10，所以我选择下载<a href="https://www.docker.com/docker-toolbox" target="_blank" rel="external">docker toolbox</a>进行docker的安装。（<strong>window的用户记得需要是64位的哦</strong>）.</p>
<p>补充：上面的docker-toolbox下载链接为国外链接，速度很慢，所以本人采用DaoCloud提供的国内镜像进行下载，下载链接为：<a href="https://get.daocloud.io/toolbox/" target="_blank" rel="external">https://get.daocloud.io/toolbox/</a></p>
<p>下载之后，安装非常简单，直接傻瓜式操作就可以了。然后运行，如果出现下面这个界面说明已经安装成功。<br><img src="/img/use-docker-to-build-spark-env/1.png" alt=""></p>
<p>##二.下载spark镜像<br>本文选取的镜像是dockerhub上的<a href="https://hub.docker.com/r/sequenceiq/spark/" target="_blank" rel="external">sequenceiq/spark</a>镜像，由于国内的原因，直接从dockerhub上下载速度很慢，因此我选择daocloud进行加速。</p>
<p>具体加速配置请参考：<a href="https://dashboard.daocloud.io/mirror" target="_blank" rel="external">https://dashboard.daocloud.io/mirror</a></p>
<p>配置完成后，就可以使用<code>dao pull</code>进行镜像的拉去，速度还是不错滴，推荐大家试试。</p>
<p>###1.拉取spark镜像<br>首先如果是安装的docker toolbox,则首先输入 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh default</span><br></pre></td></tr></table></figure>
<p>进入终端。而boot2docker可以使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot2docker ssh</span><br></pre></td></tr></table></figure>
<p>进入之后直接输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao pull sequenceiq/spark:1.3.1</span><br></pre></td></tr></table></figure>
<p>进行spark镜像的拉取。（<strong>这次已经采用了daocloud进行了加速，所以才哟过dao命令进行拉取</strong>）</p>
<hr>
<p>#####注意点：<br><strong>在此处存在一个问题，楼主由于学校网络差的缘故，导致从daocloud上也拉取不了该镜像。因此楼主购买了一台阿里云服务器来拉取该镜像，在云主机中将该镜像通过<code>docker save</code>打包成一个tar文件，然后再SSH上去，将该tar文件拉取到本地，然后通过<code>docker load</code>进行加载。</strong></p>
<p>###2.运行spark容器<br>具体可以参考以下网址：<a href="https://github.com/sequenceiq/docker-spark" target="_blank" rel="external">https://github.com/sequenceiq/docker-spark</a><br>上面写的非常清楚，按照步骤就可以得到spark的容器。</p>
<p>输入<code>docker images</code>可以查看本地的及docker镜像。<br><img src="/img/use-docker-to-build-spark-env/2.png" alt="docker images"></p>
<p>输入<code>docker ps</code>可以查看本地运行的docker容器。<br><img src="/img/use-docker-to-build-spark-env/3.png" alt="docker images"></p>
<p>###3.测试pi程序<br>由于spark容器已经运行起来了，我们可以测试下pi是否可以计算。<br>该镜像中spark的运行模式为两种，分别为<code>yarn-client</code>和<code>yarn-cluster</code>,具体的运行命令依旧参考上述网址<a href="https://github.com/sequenceiq/docker-spark." target="_blank" rel="external">^1</a>。</p>
<hr>
<p>####注意点：<br><strong>如果你采用的是boot2docker,请确保分配给虚拟机的内存大于2G。同时，为了方便通过本地的UI查看任务的运行情况，请在运行容器时，暴露8088和8042两个端口。</strong></p>
<p>###4.总结<br>采用docker进行本地spark环境的搭建，可以做到只需构建一次spark镜像，就可以到处运行的效果，这样不需要每次系统更换，都需要重新配置spark环境，直接利用docker启动即可，非常方便。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Valid Number]]></title>
      <url>http://codeinterviews.com/Valid-Number/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Valid Number</p>
<blockquote>
<p>Validate if a given string is numeric.</p>
<p>Some examples:<br><code>&quot;0&quot;</code> =&gt; <code>true</code><br><code>&quot; 0.1 &quot;</code> =&gt; <code>true</code><br><code>&quot;abc&quot;</code> =&gt; <code>false</code><br><code>&quot;1 a&quot;</code> =&gt; <code>false</code><br><code>&quot;2e10&quot;</code> =&gt; <code>true</code>   </p>
<p><strong>Note</strong>: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p>
<p>Update (2014-12-06):<br>New test cases had been added. Thanks unfounder’s contribution.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>基本规则是按照科学计数法，所以会出现的特殊字符有以下几个：符号位‘+’，‘-’，小数点‘.’，还有‘e’和‘E’，剩下的就只有数字0-9了，其他字符如果出现就是非法字符，返回false。数字字符在哪里出现都是ok的，我们主要考虑几个特殊字符的情况。</p>
<p>对于小数点出现的时候，我们要满足一下这些条件：   </p>
<ol>
<li>前面不能有小数点或者‘e’和‘E’；    </li>
<li>前一位是数字（不能是第一位）或者后一位要是数字（不能是最后一位）。    </li>
</ol>
<p>对于正负号出现的情况，要满足条件：    </p>
<ol>
<li>必须是第一位或者在‘e’和‘E’后一位；    </li>
<li>后一位要是数字。    </li>
</ol>
<p>对于‘e’和‘E’的情况，要满足：    </p>
<ol>
<li>前面不能有‘e’和‘E’出现过；    </li>
<li>不能是第一位（前面没数字科学计数没有意义）或者最后一位（后面没数字就不用写指数了）。</li>
</ol>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    s = s.trim();</span><br><span class="line">	    <span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    <span class="keyword">boolean</span> dotFlag = <span class="keyword">false</span>;</span><br><span class="line">	    <span class="keyword">boolean</span> eFlag = <span class="keyword">false</span>;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	        <span class="keyword">switch</span>(s.charAt(i))</span><br><span class="line">	        &#123;</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'.'</span>:</span><br><span class="line">	                <span class="keyword">if</span>(dotFlag || eFlag </span><br><span class="line">	                || ((i==<span class="number">0</span>||!(s.charAt(i-<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;s.charAt(i-<span class="number">1</span>)&lt;=<span class="string">'9'</span>)) </span><br><span class="line">	                    &amp;&amp; (i==s.length()-<span class="number">1</span>||!(s.charAt(i+<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;s.charAt(i+<span class="number">1</span>)&lt;=<span class="string">'9'</span>))))</span><br><span class="line">	                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	                dotFlag = <span class="keyword">true</span>;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">	                <span class="keyword">if</span>((i&gt;<span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>)!=<span class="string">'e'</span> &amp;&amp; s.charAt(i-<span class="number">1</span>)!=<span class="string">'E'</span>))</span><br><span class="line">	                  || (i==s.length()-<span class="number">1</span> || !(s.charAt(i+<span class="number">1</span>)&gt;=<span class="string">'0'</span>&amp;&amp;s.charAt(i+<span class="number">1</span>)&lt;=<span class="string">'9'</span>||s.charAt(i+<span class="number">1</span>)==<span class="string">'.'</span>)))</span><br><span class="line">	                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">	                <span class="keyword">if</span>(eFlag || i==s.length()-<span class="number">1</span> || i==<span class="number">0</span>)</span><br><span class="line">	                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	                eFlag = <span class="keyword">true</span>;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'7'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">	            <span class="keyword">case</span> <span class="string">'9'</span>:</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">default</span>:</span><br><span class="line">	                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Valid Palindrome]]></title>
      <url>http://codeinterviews.com/Valid-Palindrome/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Valid Palindrome</p>
<blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><code>&quot;race a car&quot;</code> is not a palindrome.</p>
<p>####Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判断字符串是否是回文，其实只要定义前后两个指针进行遍历，判断其是否相同。但是可以需要跳过不是字母和数字的字符。因此我们要写一个函数判断他是不是合法字符，而且因为忽略大小写，我们在判断两个字符是不是相同的时候如果是大写，要转成相应的小写字母。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span>[] res=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=res.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">char</span> c1=res[i];</span><br><span class="line">        	<span class="keyword">char</span> c2=res[j];</span><br><span class="line">        	<span class="keyword">if</span>(!isvalid(c1))</span><br><span class="line">        	&#123;</span><br><span class="line">        		i++;</span><br><span class="line">        		<span class="keyword">continue</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(!isvalid(c2))</span><br><span class="line">        	&#123;</span><br><span class="line">        		j--;</span><br><span class="line">        		<span class="keyword">continue</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(!isSame(c1,c2))</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	i++;</span><br><span class="line">        	j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isvalid</span><span class="params">(<span class="keyword">char</span> c)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(c&gt;=<span class="string">'a'</span> &amp;&amp; c&lt;=<span class="string">'z'</span> || c&gt;=<span class="string">'A'</span> &amp;&amp; c&lt;=<span class="string">'Z'</span> || c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="comment">//都转化成小写进行比较</span></span><br><span class="line">    	<span class="keyword">if</span>(a&gt;=<span class="string">'A'</span> &amp;&amp; a&lt;=<span class="string">'Z'</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		a=(<span class="keyword">char</span>)(a-<span class="string">'A'</span>+<span class="string">'a'</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(b&gt;=<span class="string">'A'</span> &amp;&amp; b&lt;=<span class="string">'Z'</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		b=(<span class="keyword">char</span>)(b-<span class="string">'A'</span>+<span class="string">'a'</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> a==b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Valid Parentheses]]></title>
      <url>http://codeinterviews.com/Valid-Parentheses/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####RValid Parentheses</p>
<blockquote>
<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, <code>&quot;()&quot;</code> and <code>&quot;()[]{}&quot;</code> are all valid but <code>&quot;(]&quot;</code> and <code>&quot;([)]&quot;</code> are not.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是匹配括号是否匹配合法问题，可以采用栈来实现，而栈一般采用数组来进行标示。如果遇到字符<code>(</code>,<code>{</code>和<code>[</code>，则将其压入栈中，如果遇到<code>)</code>,<code>}</code>和<code>]</code>，则需要对栈顶元素进行判定，看是否与括号相匹配，如果匹配则弹出栈顶元素，否则则认为匹配不合法，直接结束匹配过程。</p>
<p>算法流程如下：</p>
<pre><code>定义数组栈stack;
foreach c in String:
    if c 为（，{，[  then stack.push(c);
    if c 为 ), }, ]    then 判定stack是否为空和stack.top是否与c相匹配。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//利用数组栈来求解问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len=c.length;</span><br><span class="line">        <span class="keyword">char</span>[] temp=<span class="keyword">new</span> <span class="keyword">char</span>[len];  <span class="comment">//数组栈</span></span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i=-<span class="number">1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len)&#123;</span><br><span class="line">        	<span class="keyword">switch</span>(c[j])&#123;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'&#123;'</span>:</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'('</span>:&#123;i++;temp[i]=c[j];j++;<span class="keyword">break</span>;&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">']'</span>:&#123;</span><br><span class="line">        			<span class="keyword">if</span>(i!=-<span class="number">1</span>&amp;&amp;temp[i]==<span class="string">'['</span>)&#123;</span><br><span class="line">        				i--;</span><br><span class="line">        				j++;</span><br><span class="line">        				<span class="keyword">break</span>;</span><br><span class="line">        			&#125;<span class="keyword">else</span></span><br><span class="line">        				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'&#125;'</span>:&#123;</span><br><span class="line">        			<span class="keyword">if</span>(i!=-<span class="number">1</span>&amp;&amp;temp[i]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">        				i--;</span><br><span class="line">        				j++;</span><br><span class="line">        				<span class="keyword">break</span>;</span><br><span class="line">        			&#125;<span class="keyword">else</span></span><br><span class="line">        				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">')'</span>:&#123;</span><br><span class="line">					<span class="keyword">if</span>(i!=-<span class="number">1</span>&amp;&amp;temp[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">						i--;</span><br><span class="line">						j++;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==-<span class="number">1</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Valid Sudoku]]></title>
      <url>http://codeinterviews.com/Valid-Sudoku/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Valid Sudoku</p>
<blockquote>
<p>Determine if a Sudoku is valid, according to:<br><a href="http://sudoku.com.au/TheRules.aspx" target="_blank" rel="external">Sudoku Puzzles - The Rules</a>.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p><img src="/img/SuDoKu/1.png" alt=""></p>
<p>A partially filled sudoku which is valid.</p>
<p>####Note:</p>
<p>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判断一个数独是不是合法的问题，数独合法的问题只需要考察以下三个条件：</p>
<pre><code>1. 每一行不会出现重复的数字，1-9数字每个只出现一次
2. 每一列不会出现重复的数字，1-9数字每个只出现一次
3. 每一个3*3小方格中应该包含1-9所有的数字，但不会出现重复的数字
</code></pre><p>因此只需要对上面三个条件进行判定就可以决定数独是不是合法。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: The Solution object is instantiated only once and is reused by each test case.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mx = board.length;</span><br><span class="line">        <span class="keyword">int</span> my = board[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; mx; x++)&#123;</span><br><span class="line">            HashSet&lt;Character&gt; col = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; my; y++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[x][y];</span><br><span class="line">                <span class="keyword">if</span>(c != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(col.contains(c)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    col.add(c);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; my; y++)&#123;</span><br><span class="line">            HashSet&lt;Character&gt; row = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; mx; x++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[x][y];</span><br><span class="line">                <span class="keyword">if</span>(c != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row.contains(c)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    row.add(c);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; mx; x += <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; my; y += <span class="number">3</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                HashSet&lt;Character&gt; block = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; <span class="number">9</span>; offset++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> ox = offset % <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">int</span> oy = offset / <span class="number">3</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">char</span> c = board[x + ox][y + oy];</span><br><span class="line">                    <span class="keyword">if</span>(c != <span class="string">'.'</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(block.contains(c)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    </span><br><span class="line">                        block.add(c);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Validate Binary Search Tree]]></title>
      <url>http://codeinterviews.com/Validate-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Validate Binary Search Tree</p>
<blockquote>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.   </li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.   </li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>confused what <code>&quot;{1,#,2,3}&quot;</code> means? &gt; read more on how binary tree is serialized on OJ.</p>
<p>####OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example:</p>
<pre><code>  1
 / \
2   3
   /
  4
   \
    5
</code></pre><p>The above binary tree is serialized as <code>&quot;{1,2,3,#,#,4,#,#,5}&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是检查一颗二分查找树是否合法，二分查找树是非常常见的一种数据结构，因为它可以在O(logn)时间内实现搜索.<br>利用二分查找树的性质，就是它的中序遍历结果是按顺序递增的。根据这一点我们只需要中序遍历这棵树，然后保存前驱结点，每次检测是否满足递增关系即可。注意以下代码我么用一个一个变量的数组去保存前驱结点，原因是java没有传引用的概念，如果传入一个变量，它是按值传递的，所以是一个备份的变量，改变它的值并不能影响它在函数外部的值，算是java中的一个小细节</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; pre = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        pre.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(root, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; pre)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> left = helper(root.left,pre);</span><br><span class="line">        <span class="keyword">if</span>(pre.get(<span class="number">0</span>)!=<span class="keyword">null</span> &amp;&amp; root.val&lt;=pre.get(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre.set(<span class="number">0</span>,root.val);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; helper(root.right,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Surrounded Regions]]></title>
      <url>http://codeinterviews.com/Surrounded-Regions/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Surrounded Regions</p>
<blockquote>
<p>Given a 2D board containing ‘X’ and ‘O’, capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>For example,</p>
<pre><code>X X X X
X O O X
X X O X
X O X X
</code></pre><p>After running your function, the board should be:</p>
<pre><code>X X X X
X X X X
X X X X
X O X X
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>这个题目用到的方法是图形学中的一个常用方法：<a href="http://zh.wikipedia.org/wiki/Flood_fill" target="_blank" rel="external">Flood fill</a>算法，其实就是从一个点出发对周围区域进行目标颜色的填充。背后的思想就是把一个矩阵看成一个图的结构，每个点看成结点，而边则是他上下左右的相邻点，然后进行一次广度或者深度优先搜索。   </p>
<p>接下来我们看看这个题如何用<a href="http://zh.wikipedia.org/wiki/Flood_fill" target="_blank" rel="external">Flood fill</a>算法来解决。首先我们知道，如果从一个’O’出发，到达一个边缘的‘O’时，此时这条路是没有被包围的，这些‘O’都不会变为‘X’，而没有到达边缘的那些‘O’是需要变为‘X’的，因此边缘需要特殊处理。在这里，我们采用首先从边缘开始来fill,把所有边缘上‘O’能到的’O’都变为‘#’，这样再全局遍历一次整个矩阵，把‘#’变为‘O’，把‘O’变为‘X’即可。</p>
<p>这里采用广度优先所搜去找到从一个‘O’出发，能到达的所有‘O’的路径。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length&lt;=<span class="number">1</span> || board[<span class="number">0</span>].length&lt;=<span class="number">1</span>)  </span><br><span class="line">       		<span class="keyword">return</span>;  </span><br><span class="line">        <span class="comment">//对边缘进行搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board[<span class="number">0</span>].length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	fill(board,<span class="number">0</span>,i);</span><br><span class="line">        	fill(board,board.length-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	fill(board,i,<span class="number">0</span>);</span><br><span class="line">        	fill(board,i,board[<span class="number">0</span>].length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后遍历，把'#'变为‘O’，把‘O’变为‘X’</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(board[i][j]==<span class="string">'#'</span>)</span><br><span class="line">        			board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        			board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行广度搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(board[i][j]!=<span class="string">'O'</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	board[i][j]=<span class="string">'#'</span>;</span><br><span class="line">    	<span class="comment">//定义队列，进行广度优先遍历</span></span><br><span class="line">    	LinkedList&lt;Integer&gt; queen=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    	queen.offer(i*board[<span class="number">0</span>].length+j);</span><br><span class="line">    	<span class="keyword">while</span>(!queen.isEmpty())</span><br><span class="line">    	&#123;</span><br><span class="line">    		Integer cur=queen.poll();</span><br><span class="line">    		<span class="keyword">int</span> row=cur/board[<span class="number">0</span>].length;</span><br><span class="line">    		<span class="keyword">int</span> col=cur%board[<span class="number">0</span>].length;</span><br><span class="line">    		<span class="comment">//向上</span></span><br><span class="line">    		<span class="keyword">if</span>(row&gt;<span class="number">0</span> &amp;&amp; board[row-<span class="number">1</span>][col]==<span class="string">'O'</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			queen.offer((row-<span class="number">1</span>)*board[<span class="number">0</span>].length+col);</span><br><span class="line">    			board[row-<span class="number">1</span>][col]=<span class="string">'#'</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="comment">//向下</span></span><br><span class="line">    		<span class="keyword">if</span>(row&lt;board.length-<span class="number">1</span> &amp;&amp; board[row+<span class="number">1</span>][col]==<span class="string">'O'</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			queen.offer((row+<span class="number">1</span>)*board[<span class="number">0</span>].length+col);</span><br><span class="line">    			board[row+<span class="number">1</span>][col]=<span class="string">'#'</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="comment">//向左</span></span><br><span class="line">    		<span class="keyword">if</span>(col&gt;<span class="number">0</span> &amp;&amp; board[row][col-<span class="number">1</span>]==<span class="string">'O'</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			queen.offer((row)*board[<span class="number">0</span>].length+col-<span class="number">1</span>);</span><br><span class="line">    			board[row][col-<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="comment">//向右</span></span><br><span class="line">    		<span class="keyword">if</span>(col&lt;board[<span class="number">0</span>].length-<span class="number">1</span> &amp;&amp; board[row][col+<span class="number">1</span>]==<span class="string">'O'</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			queen.offer((row)*board[<span class="number">0</span>].length+col+<span class="number">1</span>);</span><br><span class="line">    			board[row][col+<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Wildcard Matching]]></title>
      <url>http://codeinterviews.com/Wildcard-Matching/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Wildcard Matching</p>
<blockquote>
<p>Implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.</p>
<pre><code>&apos;?&apos; Matches any single character.
&apos;*&apos; Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch(&quot;aa&quot;,&quot;a&quot;) → false
isMatch(&quot;aa&quot;,&quot;aa&quot;) → true
isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false
isMatch(&quot;aa&quot;, &quot;*&quot;) → true
isMatch(&quot;aa&quot;, &quot;a*&quot;) → true
isMatch(&quot;ab&quot;, &quot;?*&quot;) → true
isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>维护一个假设我们维护一个布尔数组res[i],代表s的前i-1个字符和p的前j-1个字符是否匹配(这里因为每次i的结果只依赖于j-1的结果，所以不需要二维数组，只需要一个一维数组来保存上一行结果即可），递推公式分两种情况：</p>
<pre><code>(1)p[j]不是&apos;*&apos;。情况比较简单，只要判断如果当前s的i和p的j上的字符一样（如果有p在j上的字符是&apos;?&apos;，也是相同），并且res[i]==true，则更新res[i+1]为true，否则res[i+1]=false;  
(2)p[j]是&apos;*&apos;。因为&apos;*&apos;可以匹配任意字符串，所以在前面的res[i]只要有true，那么剩下的res[i+1], res[i+2],...,res[s.length()]就都是true了。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s.length()==<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&gt;<span class="number">300</span> &amp;&amp; p.charAt(<span class="number">0</span>)==<span class="string">'*'</span> &amp;&amp; p.charAt(p.length()-<span class="number">1</span>)==<span class="string">'*'</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p.length();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j)!=<span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    res[i+<span class="number">1</span>] = res[i]&amp;&amp;(p.charAt(j)==<span class="string">'?'</span>||s.charAt(i)==p.charAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;=s.length() &amp;&amp; !res[i])</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">for</span>(;i&lt;=s.length();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    res[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[<span class="number">0</span>] = res[<span class="number">0</span>]&amp;&amp;p.charAt(j)==<span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Word Break II]]></title>
      <url>http://codeinterviews.com/Word-Break-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Word Break II</p>
<blockquote>
<p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.</p>
<p>Return all such possible sentences.</p>
<p>For example, given<br>s = <code>&quot;catsanddog&quot;</code>,<br>dict = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code>.          </p>
<p>A solution is <code>[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]</code>.    </p>
<a id="more"></a>
</blockquote>
<p>##解题思路<br>该题与前面<a href="http://pisxw.com/algorithm/Palindrome-Partitioning.html" target="_blank" rel="external">Palindrome Partitioning</a>的解法非常类似,想要获取递归的每种情况，可以采用循环处理递归子问题的方法。分别对单词进行切割，如果满足在字典中，则递归判断下面所有的单词切分，如果不满足，则增加长度，继续判断。</p>
<p>还有一点需要指出的是，下面的代码放到LeetCode中会超时，原因是LeetCode中有一个非常tricky的测试case，其实是不能break的，但是又很长，出现大量的记录和回溯，因此这里可以首先使用上一题<code>word break</code>方法进行判断是否有解，然后在进行该代码，这一点我觉得LeetCode没必要把超时设得这么严格，实际意义不大，只是把AC率给拉了下来哈。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span> || dict==<span class="keyword">null</span> || dict.size()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> res;</span><br><span class="line">        helper(s,<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;String&gt;(),res,dict);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s,<span class="keyword">int</span> start,ArrayList&lt;String&gt; list,ArrayList&lt;String&gt; res,Set&lt;String&gt; dict)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(start==s.length())</span><br><span class="line">    	&#123;</span><br><span class="line">    		ArrayList&lt;String&gt; newlist=<span class="keyword">new</span> ArrayList&lt;String&gt;(list);</span><br><span class="line">    		StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;newlist.size()-<span class="number">1</span>;i++)</span><br><span class="line">    			sb.append(newlist.get(i)+<span class="string">" "</span>);</span><br><span class="line">    		sb.append(newlist.get(newlist.size()-<span class="number">1</span>));</span><br><span class="line">    		res.add(sb.toString());</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;s.length();i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(dict.contains(s.substring(start,i+<span class="number">1</span>)))</span><br><span class="line">    		&#123;</span><br><span class="line">    			list.add(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">    			helper(s,i+<span class="number">1</span>,list,res,dict);</span><br><span class="line">    			list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Word Ladder]]></title>
      <url>http://codeinterviews.com/Word-Ladder/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Word Ladder</p>
<blockquote>
<p>Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:</p>
<p>1.Only one letter can be changed at a time<br>2.Each intermediate word must exist in the dictionary<br>For example,</p>
<p>Given:<br>start = <code>&quot;hit&quot;</code><br>end = <code>&quot;cog&quot;</code><br>dict = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code><br>As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length <code>5</code>.    </p>
<p>####Note:</p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是一个寻找字符串中最短路径的问题，我们可以把它转变成图来求解。我们先给题目进行图的映射，顶点则是每个字符串，然后两个字符串如果相差一个字符则我们进行连边。接下来看看这个方法的优势，注意到我们的字符集只有小写字母，而且字符串长度固定，假设是L。那么可以注意到每一个字符可以对应的边则有25个（26个小写字母减去自己），那么一个字符串可能存在的边是25*L条。接下来就是检测这些边对应的字符串是否在字典里，就可以得到一个完整的图的结构了。根据题目的要求，等价于求这个图一个顶点到另一个顶点的最短路径，一般我们用广度优先搜索即可。</p>
<p>下面的代码框架整体上是一个图的广度优先搜索问题，只不过在判断边的时候需要改变字符，并判断是否在字典中。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String start, String end, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==<span class="keyword">null</span> || end==<span class="keyword">null</span> || dict==<span class="keyword">null</span> || start.length()==<span class="number">0</span> || end.length()==<span class="number">0</span> || start.length()!=end.length())</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把这道题抽象为图中寻找最短路径长度的问题，可以采用图的广度优先遍历</span></span><br><span class="line">        LinkedList&lt;String&gt; queen=<span class="keyword">new</span> LinkedList&lt;String&gt;();<span class="comment">//定义队列</span></span><br><span class="line">        HashSet&lt;String&gt; isVisited=<span class="keyword">new</span> HashSet&lt;String&gt;();<span class="comment">//定义已经访问过的节点</span></span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">1</span>;<span class="comment">//定义当前的层级</span></span><br><span class="line">        <span class="keyword">int</span> curNum=<span class="number">1</span>;<span class="comment">//定义当前一层的节点数</span></span><br><span class="line">        <span class="keyword">int</span> nextNum=<span class="number">0</span>;<span class="comment">//定义下一层的节点数</span></span><br><span class="line">        queen.offer(start);</span><br><span class="line">        isVisited.add(start);</span><br><span class="line">        <span class="keyword">while</span>(!queen.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">        	String str=queen.poll();</span><br><span class="line">        	curNum--;</span><br><span class="line">        	<span class="comment">//去寻找和该节点可能差一个字母的所有单词</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">char</span>[] charStr=str.toCharArray();</span><br><span class="line">        		<span class="comment">//对每一个字符进行设定，判断是否存在这个单词</span></span><br><span class="line">        		<span class="keyword">for</span>(<span class="keyword">char</span> a =<span class="string">'a'</span>;a&lt;=<span class="string">'z'</span>;a++) <span class="comment">//这里其实包含了其自身</span></span><br><span class="line">        		&#123;</span><br><span class="line">        			charStr[i]=a;</span><br><span class="line">        			String gstr=<span class="keyword">new</span> String(charStr);</span><br><span class="line">        			<span class="keyword">if</span>(gstr.equals(end)) <span class="comment">//找到了end 单词，返回最短路径，即最短层级</span></span><br><span class="line">        				<span class="keyword">return</span> level+<span class="number">1</span>;</span><br><span class="line">        			<span class="keyword">if</span>(dict.contains(gstr) &amp;&amp; !isVisited.contains(gstr))</span><br><span class="line">        			&#123;</span><br><span class="line">        				nextNum++;</span><br><span class="line">        				queen.offer(gstr);</span><br><span class="line">        				isVisited.add(gstr);</span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(curNum==<span class="number">0</span>) <span class="comment">//说明该层访问结束，需要进入下一层</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		curNum=nextNum;</span><br><span class="line">        		nextNum=<span class="number">0</span>;</span><br><span class="line">        		level++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Word Ladder II]]></title>
      <url>http://codeinterviews.com/Word-Ladder-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Word Ladder II</p>
<blockquote>
<p>Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the dictionary<br>For example, </li>
</ol>
<p>Given:<br>start = <code>&quot;hit&quot;</code><br>end = <code>&quot;cog&quot;</code><br>dict = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code><br>Return</p>
<pre><code>[
  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],
  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
]
</code></pre><p>####Note:</p>
<ul>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
</ul>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>这道题是LeetCode中AC率最低的题目，确实是比较难。一方面是因为对时间有比较严格的要求（容易超时），另一方面是它有很多细节需要实现。思路上和Word Ladder是比较类似的，但是因为是要求出所有路径，仅仅保存路径长度是不够的，而且这里还有更多的问题，那就是为了得到所有路径，不是每个结点访问一次就可以标记为visited了，因为有些访问过的结点也会是别的路径上的结点，所以访问的集合要进行回溯（也就是标记回未访问）。所以时间上不再是一次广度优先搜索的复杂度了，取决于结果路径的数量。同样空间上也是相当高的复杂度，因为我们要保存过程中满足的中间路径到某个数据结构中，以便最后可以获取路径，这里我们维护一个HashMap，把一个结点前驱结点都进行保存。<br>在LeetCode中用Java实现上述算法非常容易超时。为了提高算法效率，需要注意一下两点：<br>1）在替换String的某一位的字符时，先转换成char数组再操作；<br>2）如果按照正常的方法从start找end，然后根据这个来构造路径，代价会比较高，因为保存前驱结点容易，而保存后驱结点则比较困难。所以我们在广度优先搜索时反过来先从end找start，最后再根据生成的前驱结点映射从start往end构造路径，这样算法效率会有明显提高。    </p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StringWithLevel</span> </span>&#123;</span><br><span class="line">   String str;</span><br><span class="line">   <span class="keyword">int</span> level;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">StringWithLevel</span><span class="params">(String str, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.str = str;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; findLadders(String start, String end, HashSet&lt;String&gt; dict) &#123;</span><br><span class="line">   ArrayList&lt;ArrayList&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;String&gt;&gt;();</span><br><span class="line">   HashSet&lt;String&gt; unvisitedSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">   unvisitedSet.addAll(dict);</span><br><span class="line">   unvisitedSet.add(start);</span><br><span class="line">   unvisitedSet.remove(end);</span><br><span class="line">   Map&lt;String, List&lt;String&gt;&gt; nextMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String e : unvisitedSet) &#123;</span><br><span class="line">      nextMap.put(e, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   LinkedList&lt;StringWithLevel&gt; queue = <span class="keyword">new</span> LinkedList&lt;StringWithLevel&gt;();</span><br><span class="line">   queue.add(<span class="keyword">new</span> StringWithLevel(end, <span class="number">0</span>));</span><br><span class="line">   <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">int</span> finalLevel = Integer.MAX_VALUE;</span><br><span class="line">   <span class="keyword">int</span> curLevel = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> preLevel = <span class="number">0</span>;</span><br><span class="line">   HashSet&lt;String&gt; visitedCurLevel = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">   <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      StringWithLevel cur = queue.poll();</span><br><span class="line">      String curStr = cur.str;</span><br><span class="line">      curLevel = cur.level;</span><br><span class="line">      <span class="keyword">if</span>(found &amp;&amp; curLevel &gt; finalLevel) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (curLevel &gt; preLevel) &#123;</span><br><span class="line">         unvisitedSet.removeAll(visitedCurLevel);</span><br><span class="line">      &#125;</span><br><span class="line">      preLevel = curLevel;</span><br><span class="line">      <span class="keyword">char</span>[] curStrCharArray = curStr.toCharArray();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curStr.length(); ++i) &#123;</span><br><span class="line">         <span class="keyword">char</span> originalChar = curStrCharArray[i];</span><br><span class="line">         <span class="keyword">boolean</span> foundCurCycle = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; ++c) &#123;</span><br><span class="line">            curStrCharArray[i] = c;</span><br><span class="line">            String newStr = <span class="keyword">new</span> String(curStrCharArray);</span><br><span class="line">            <span class="keyword">if</span>(c != originalChar &amp;&amp; unvisitedSet.contains(newStr)) &#123;</span><br><span class="line">               nextMap.get(newStr).add(curStr);</span><br><span class="line">               <span class="keyword">if</span>(newStr.equals(start)) &#123;</span><br><span class="line">                  found = <span class="keyword">true</span>;</span><br><span class="line">                  finalLevel = curLevel;</span><br><span class="line">                  foundCurCycle = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(visitedCurLevel.add(newStr)) &#123;</span><br><span class="line">                  queue.add(<span class="keyword">new</span> StringWithLevel(newStr, curLevel + <span class="number">1</span>));</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(foundCurCycle) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         curStrCharArray[i] = originalChar;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(found) &#123;</span><br><span class="line">       ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       list.add(start);</span><br><span class="line">       getPaths(start, end, list, finalLevel + <span class="number">1</span>, nextMap, res);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPaths</span><span class="params">(String cur, String end, ArrayList&lt;String&gt; list, <span class="keyword">int</span> level, Map&lt;String, List&lt;String&gt;&gt; nextMap, ArrayList&lt;ArrayList&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(cur.equals(end))&#123;</span><br><span class="line">      res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(list));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(level &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      List&lt;String&gt; parentsSet = nextMap.get(cur);</span><br><span class="line">      <span class="keyword">for</span> (String parent : parentsSet) &#123;</span><br><span class="line">         list.add(parent);</span><br><span class="line">         getPaths(parent, end, list, level - <span class="number">1</span>, nextMap, res);</span><br><span class="line">         list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Word Break]]></title>
      <url>http://codeinterviews.com/Word-Break/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Word Break</p>
<blockquote>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>s = <code>&quot;leetcode&quot;</code>,<br>dict = <code>[&quot;leet&quot;, &quot;code&quot;]</code>.        </p>
<p>Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题与前面<a href="http://pisxw.com/algorithm/Palindrome-Partitioning-II.html" target="_blank" rel="external">Palindrome Partitioning II</a>的解法非常类似，一个试求是否为回文，一个试求是否在字典中。因此这里可以采用动态规划的方法求解</p>
<pre><code>定义维护量：dp[i]:表示从第一个元素到第i个元素是否能够被切分成字典中的单词组合
递归式：
     dp[i]=dp[i] || (dp[k-1] &amp;&amp; dict.contains(s.substring(k-1,i)));
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span> || dict==<span class="keyword">null</span> || dict.size()==<span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//定义维护量</span></span><br><span class="line">        <span class="keyword">boolean</span> dp[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//进行初始化</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;k++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="comment">//定义递归式</span></span><br><span class="line">        		dp[i]=dp[i] || (dp[k-<span class="number">1</span>] &amp;&amp; dict.contains(s.substring(k-<span class="number">1</span>,i)));</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Word Search II]]></title>
      <url>http://codeinterviews.com/Word-Search-II/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Word Search II</p>
<blockquote>
<p> Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>For example,<br>Given words = <code>[&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</code> and board =</p>
<pre><code>[
  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],
  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],
  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],
  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]
]
</code></pre><p>Return [“eat”,”oath”].</p>
<p>######Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>
<p>######click to show hint.</p>
<p>You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?</p>
<p>If the current candidate does not exist in all words’ prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该方法首先想到的思路是与<a href="http://pisxw.com/algorithm/Word-Search.html" target="_blank" rel="external">Word Search</a>相同，但是在测试数据集中存在一个特别大的用例，会造成结果的超时。因此需要进行优化。</p>
<p>首先我们想是不是每个单词都需要从头开始来进行查找呢，显然不是，我们会发现有些单词会存在公共的前缀，因此我们可以通过构建一个<code>trie</code>树，然后将需要查找的单词都加入其中，然后对网格进行深度优先搜索，并对当前已经访问过的字母序列进行判断是否在trie树中有这个前缀的单词存在，如果存在，则将该单词加入结果集中，否则没有这个前缀，说明当前位置不需要继续深度搜索下去。</p>
<p>##算法代码<br>代码采用JAVA实现：<br>超时的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以对Array中的每一个单词进行查找，如果能够找到，则加入结果List中</span></span><br><span class="line">        ArrayList&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words==<span class="keyword">null</span> || words.length==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length==<span class="number">0</span> || board[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">        	<span class="keyword">boolean</span> re=findWord(board,word);</span><br><span class="line">        	<span class="keyword">if</span>(re==<span class="keyword">true</span>)</span><br><span class="line">        		result.add(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找一个单词</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWord</span><span class="params">(<span class="keyword">char</span>[][] board,String word)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(word==<span class="keyword">null</span> || word.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">boolean</span>[][] used=<span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">if</span>(search(board,word,<span class="number">0</span>,i,j,used))</span><br><span class="line">    				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用深度优先搜索的方法进行查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] board,String word,<span class="keyword">int</span> index,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] used)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(index==word.length())</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=board.length || j&gt;=board[<span class="number">0</span>].length || used[i][j]==<span class="keyword">true</span> || board[i][j]!=word.charAt(index))</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    	used[i][j]=<span class="keyword">true</span>;</span><br><span class="line">    	<span class="comment">//对四个方位进行搜索，只要满足一个方位找到即可</span></span><br><span class="line">    	<span class="keyword">boolean</span> res=search(board,word,index+<span class="number">1</span>,i-<span class="number">1</span>,j,used) || search(board,word,index+<span class="number">1</span>,i+<span class="number">1</span>,j,used) || search(board,word,index+<span class="number">1</span>,i,j-<span class="number">1</span>,used) || search(board,word,index+<span class="number">1</span>,i,j+<span class="number">1</span>,used);</span><br><span class="line">    	<span class="comment">//需要重置使用标记</span></span><br><span class="line">    	used[i][j]=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过构建trie树进行优化的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//这边设定一个hashset，防止一个单词被重复的加入</span></span><br><span class="line">        ArrayList&lt;String&gt; re=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	HashSet&lt;String&gt; result=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words==<span class="keyword">null</span> || words.length==<span class="number">0</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length==<span class="number">0</span> || board[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">        Trie tr=<span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">        	tr.insertWord(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] used=<span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;board.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].length; j++) &#123;  </span><br><span class="line">                search(board, used, tr, i, j, <span class="keyword">new</span> StringBuilder(), result);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(String hs:result)</span><br><span class="line">          re.add(hs);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//sb中记录深度过程中访问过的节点，然后便于前缀搜索</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">boolean</span>[][] used,Trie tr,<span class="keyword">int</span> i,<span class="keyword">int</span> j,StringBuilder sb,HashSet&lt;String&gt; re)</span></span>&#123;</span><br><span class="line">   		<span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=board.length || j&gt;=board[<span class="number">0</span>].length || used[i][j]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   		used[i][j]=<span class="keyword">true</span>;</span><br><span class="line">   		sb.append(board[i][j]);</span><br><span class="line">   		String s=sb.toString();</span><br><span class="line">   		<span class="comment">//只有存在这个单词前缀的时候，才需要进行深度下去，否则不需要深度下去了，因为没有意义，这里进行了剪枝</span></span><br><span class="line">   		<span class="keyword">if</span>(tr.searchPrefix(s))&#123;</span><br><span class="line">   			<span class="keyword">if</span>(tr.searchWord(s)) re.add(s);</span><br><span class="line">   			<span class="comment">//从四个方面进行搜索</span></span><br><span class="line">   			search(board,used,tr,i-<span class="number">1</span>,j,sb,re);</span><br><span class="line">   			search(board,used,tr,i+<span class="number">1</span>,j,sb,re);</span><br><span class="line">   			search(board,used,tr,i,j-<span class="number">1</span>,sb,re);</span><br><span class="line">   			search(board,used,tr,i,j+<span class="number">1</span>,sb,re);</span><br><span class="line">   		&#125;</span><br><span class="line">   		<span class="comment">//回溯上去进行还原工作</span></span><br><span class="line">   		sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">   		used[i][j]=<span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trie树中节点的结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> content;</span><br><span class="line">	<span class="keyword">boolean</span> isEnd;</span><br><span class="line">	LinkedList&lt;TrieNode&gt; children;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.content=<span class="string">' '</span>;</span><br><span class="line">		<span class="keyword">this</span>.isEnd=<span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">this</span>.children=<span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> content)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.content=content;</span><br><span class="line">		<span class="keyword">this</span>.isEnd=<span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">this</span>.children=<span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查当前节点的孩子节点是否存在需要查找的字母</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TrieNode <span class="title">subNode</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(children!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(TrieNode child:children)</span><br><span class="line">				<span class="keyword">if</span>(child.content==c)</span><br><span class="line">					<span class="keyword">return</span> child;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">	TrieNode root;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">		root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入单词</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(searchWord(word)==<span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">		TrieNode current=root;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)&#123;</span><br><span class="line">			TrieNode node=current.subNode(word.charAt(i));</span><br><span class="line">			<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				current.children.add(<span class="keyword">new</span> TrieNode(word.charAt(i)));</span><br><span class="line">				current=current.subNode(word.charAt(i));</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				current=node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		current.isEnd=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找单词</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">		TrieNode current=root;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)&#123;</span><br><span class="line">			TrieNode node=current.subNode(word.charAt(i));</span><br><span class="line">			<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				current=node;</span><br><span class="line">		&#125;	</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(current.isEnd)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找前缀</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchPrefix</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">		TrieNode current=root;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.length();i++)&#123;</span><br><span class="line">			TrieNode node=current.subNode(word.charAt(i));</span><br><span class="line">			<span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				current=node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Word Search]]></title>
      <url>http://codeinterviews.com/Word-Search/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Word Search</p>
<blockquote>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given <strong>board</strong> =</p>
<pre><code>[
  [&quot;ABCE&quot;],
  [&quot;SFCS&quot;],
  [&quot;ADEE&quot;]
]
</code></pre><p><strong>word</strong> = <code>&quot;ABCCED&quot;</code>, -&gt; returns <code>true</code>,<br><strong>word</strong> = <code>&quot;SEE&quot;</code>, -&gt; returns <code>true</code>,<br><strong>word</strong> = <code>&quot;ABCB&quot;</code>, -&gt; returns <code>false</code>.   </p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题本质上是做深度优先搜索。基本思路就是从某一个元素出发，往上下左右深度搜索是否有相等于word的字符串。这里注意每次从一个元素出发时要重置访问标记（也就是说虽然单次搜索字符不能重复使用，但是每次从一个新的元素出发，字符还是重新可以用的。</p>
<p>我们知道一次搜索的复杂度是O(E+V)，E是边的数量，V是顶点数量，在这个问题中他们都是O(mxn)量级的（因为一个顶点有固定上下左右四条边）。加上我们对每个顶点都要做一次搜索，所以总的时间复杂度最坏是O(m^2xn^2)，空间上就是要用一个数组来记录访问情况，所以是O(mxn)。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;  </span><br><span class="line">	    <span class="keyword">if</span>(word==<span class="keyword">null</span> || word.length()==<span class="number">0</span>)  </span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">	    <span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length==<span class="number">0</span> || board[<span class="number">0</span>].length==<span class="number">0</span>)  </span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">	    <span class="keyword">boolean</span>[][] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];  </span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)  </span><br><span class="line">	    &#123;  </span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)  </span><br><span class="line">	        &#123;  </span><br><span class="line">	            <span class="keyword">if</span>(search(board,word,<span class="number">0</span>,i,j,used))  </span><br><span class="line">	                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] used)</span>  </span><br><span class="line">	</span>&#123;  </span><br><span class="line">	    <span class="keyword">if</span>(index == word.length())  </span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">	    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=board.length || j&gt;=board[<span class="number">0</span>].length || used[i][j] || board[i][j]!=word.charAt(index))  </span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">	    used[i][j] = <span class="keyword">true</span>;  </span><br><span class="line">	    <span class="keyword">boolean</span> res = search(board,word,index+<span class="number">1</span>,i-<span class="number">1</span>,j,used)   </span><br><span class="line">	                || search(board,word,index+<span class="number">1</span>,i+<span class="number">1</span>,j,used)  </span><br><span class="line">	                || search(board,word,index+<span class="number">1</span>,i,j-<span class="number">1</span>,used)   </span><br><span class="line">	                || search(board,word,index+<span class="number">1</span>,i,j+<span class="number">1</span>,used);  </span><br><span class="line">	    used[i][j] = <span class="keyword">false</span>;  </span><br><span class="line">	    <span class="keyword">return</span> res;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[根据输入路径产生输出路径和清除HDFS目录]]></title>
      <url>http://codeinterviews.com/%E6%A0%B9%E6%8D%AE%E8%BE%93%E5%85%A5%E8%B7%AF%E5%BE%84%E4%BA%A7%E7%94%9F%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84%E5%92%8C%E6%B8%85%E9%99%A4HDFS%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>##一、实验内容<br>对HDFS输入目录的路径解析出来，组成输出路径，这在业务上是十分常用的。这里其实是没有多文件名输出，仅仅是调用了MultipleOutputs的addNamedOutput方法一次，设置文件名为result.</p>
<p>同时为了保证计算的可重入性，每次都需要将已经存在的输出目录删除。</p>
<a id="more"></a>
<p>复制一份MapReduce1工程，取名为MapReduce3，对LogJob.java做些修改，主要用Path, FileSystem和Configuration三个类配合，删除HDFS已经存在的目录。<br>并且只设置了一个NamedOutput，名为result.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiyanlou.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 输入路径</span></span><br><span class="line">		String inputPath = args[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (inputPath.endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			inputPath = inputPath.substring(<span class="number">0</span>, inputPath.length() - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出路径</span></span><br><span class="line">		String outputPath = inputPath + <span class="string">"/output"</span>;</span><br><span class="line"></span><br><span class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">		Job job = <span class="keyword">new</span> Job(conf, <span class="string">"sum_did_from_log_file"</span>);</span><br><span class="line">		job.setJarByClass(LogJob.class);</span><br><span class="line"></span><br><span class="line">		job.setMapperClass(LogMapper.class);</span><br><span class="line">		job.setReducerClass(LogReducer.class);</span><br><span class="line"></span><br><span class="line">		job.setOutputKeyClass(Text.class);</span><br><span class="line">		job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">		Path path1 = <span class="keyword">new</span> Path(inputPath);</span><br><span class="line">		Path path2 = <span class="keyword">new</span> Path(outputPath);</span><br><span class="line"></span><br><span class="line">		recreateFolder(path2, conf);</span><br><span class="line"></span><br><span class="line">		MultipleOutputs.addNamedOutput(job, <span class="string">"result"</span>, TextOutputFormat.class,</span><br><span class="line">				Text.class, IntWritable.class);</span><br><span class="line"></span><br><span class="line">		FileInputFormat.addInputPath(job, path1);</span><br><span class="line">		FileOutputFormat.setOutputPath(job, path2);</span><br><span class="line"></span><br><span class="line">		System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 清除目录</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> path</span><br><span class="line">	 * <span class="doctag">@param</span> conf</span><br><span class="line">	 * <span class="doctag">@throws</span> IOException</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recreateFolder</span><span class="params">(Path path, Configuration conf)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileSystem fs = path.getFileSystem(conf);</span><br><span class="line">		<span class="keyword">if</span> (fs.exists(path)) &#123;</span><br><span class="line">			fs.delete(path);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LogReducer代码也需要修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiyanlou.mapreduce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MultipleOutputs outputs;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"enter LogReducer:::setup method"</span>);</span><br><span class="line">		outputs = <span class="keyword">new</span> MultipleOutputs(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">			InterruptedException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"enter LogReducer:::cleanup method"</span>);</span><br><span class="line">		outputs.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"enter LogReducer::reduce method"</span>);</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">			sum += val.get();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"key: "</span> + key.toString() + <span class="string">" sum: "</span> + sum);</span><br><span class="line">		outputs.write(<span class="string">"result"</span>, key, sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>get下来input/output文件夹，进入本地output文件夹查看：</p>
<pre><code>$ ls
_logs  part-r-00000  result-r-00000  _SUCCESS
</code></pre><p>查看result-r-00000内容：</p>
<pre><code>536dbacc4700aab274729cca    91
536dbae74700aab274729ccb    91
536dbb284700aab274729ccd    91
536dbb864700aab274729ccf    91
536dbba04700aab274729cd3    91
536dbba04700aab274729cd4    91
536dbba04700aab274729cd5    91
536dbba04700aab274729cd7    91
536dbba04700aab274729cd8    91
536dbba04700aab274729cd9    1
536dbba04700aab274729cdc    1
536dbba04700aab274729cdd    91
536dbba04700aab274729cde    152
536dbba04700aab274729ce0    87
536dbba04700aab274729ce1    87
536dbba04700aab274729ce2    87
536dbba04700aab274729ce3    87
536dbba04700aab274729ce4    91
536dbba04700aab274729ce5    91
536dbba04700aab274729ce8    152
536dbba04700aab274729ce9    91
536dbba14700aab274729cec    87
536dbba14700aab274729cee    87
536dbba14700aab274729cef    138
536dbba14700aab274729cf1    91
536dbba14700aab274729cf5    91
536dbba14700aab274729cf6    87
536dbba14700aab274729cf7    87
536dbba14700aab274729d02    87
536dbba14700aab274729d0a    87
536dbba14700aab274729d0d    87
536dbba14700aab274729d0f    1
536dbba14700aab274729d10    87
536dbba14700aab274729d12    87
536dbba14700aab274729d1c    152
536dbba14700aab274729d27    152
</code></pre><p>代码比之前的例子简单很多，仅仅是往一个named output “result” 写出结果。</p>
<h2 id="二、小结"><a href="#二、小结" class="headerlink" title="二、小结"></a>二、小结</h2><p>我们可以根据输入路径来生成输出路径，使用Path, FileSystem和Configuration三个类可以删除HDFS中的文件，相应地也可以创建文件。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用HashPartitioner来调节Reducer的计算负载]]></title>
      <url>http://codeinterviews.com/%E4%BD%BF%E7%94%A8HashPartitioner%E6%9D%A5%E8%B0%83%E8%8A%82Reducer%E7%9A%84%E8%AE%A1%E7%AE%97%E8%B4%9F%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>##一、实验内容<br>本节介绍如何使用HashPartitioner将Mapper的输出按照key进行分组后交给Reducer来处理。合理的分组策略将使得每个Reducer获得的计算负载差距不大，从而整体reduce的性能更加均衡。</p>
<a id="more"></a>
<p>Reducer的数量由HashPartitioner函数getPartition返回值来确定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K2 key, V2 value, <span class="keyword">int</span> numReduceTasks)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) &amp; numReduceTasks;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码表示根据key的hash code 除以2的31次方后取余数，用该余数再次除以reducer的数量，再取余数。得到的结果才是这个key对应的partition的编号。<br>原因是 Integer.MAX_VALUE是2的31次方-1, 一个数如果和一个2的N次方-1的数 按位与 就 等价于 这个数对2的N次方取余数。</p>
<p>参考文档：</p>
<p><a href="http://blog.csdn.net/csfreebird/article/details/7355282" target="_blank" rel="external">http://blog.csdn.net/csfreebird/article/details/7355282</a></p>
<p>所有计算出来属于同一个partition的key，以及它的value都会被发送到对应的reducer去做处理。</p>
<p>所以结论如下：</p>
<p>partitioner不会改变reducer的数量，而会决定哪些<key,value>进入哪个组，从而改变reducer处理的数据的量</key,value></p>
<p>在MapReduce4的基础上，仅仅修改了LogJob.java的一行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.setPartitionerClass(HashPartitioner.class);</span><br></pre></td></tr></table></figure></p>
<p>其实如果不设置，默认Hadoop用的就是HashPartitioner。</p>
<h2 id="二、小结"><a href="#二、小结" class="headerlink" title="二、小结"></a>二、小结</h2><p>MapReduce中可以使用HashPartitioner中的getPartition来调节Reducer的计算负载，Hadoop默认使用的就是HashPartitioner。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Symmetric Tree]]></title>
      <url>http://codeinterviews.com/Symmetric-Tree/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Symmetric Tree</p>
<blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>But the following is not:</p>
<pre><code>  1
 / \
2   2
 \   \
 3    3
</code></pre><p>####Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<p>confused what <code>&quot;{1,#,2,3}&quot;</code> means? &gt; read more on how binary tree is serialized on OJ.</p>
<p>####OJ’s Binary Tree Serialization:<br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example:</p>
<pre><code>  1
 / \
2   3
   /
  4
   \
    5
</code></pre><p>The above binary tree is serialized as <code>&quot;{1,2,3,#,#,4,#,#,5}&quot;</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判定一个二叉树是否是中心对称的。我们可以通过对二叉树进行遍历而进行判定，是一个递归的过程，一颗树对称其实就是看左右子树是否对称，一句话就是左同右，右同左，结点是对称的相等。我们主要说说结束条件，假设到了某一结点，不对称的条件有以下三个：（1）左边为空而右边不为空；（2）左边不为空而右边为空；（3）左边值不等于右边值。根据这几个条件在遍历时进行判断即可。</p>
<p>这里可以使用栈来达到非递归的目的，不过里面的判断条件就比较多了。</p>
<p>##算法代码<br>代码采用JAVA实现：<br>算法的递归实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//判断左右子树是否对称</span></span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode left,TreeNode right)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="comment">//结束条件</span></span><br><span class="line">    	<span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">if</span>(left!=<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">return</span> left.val==right.val &amp;&amp; helper(left.left,right.right) &amp;&amp; helper(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>算法的非递归实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right!=<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">if</span>(root.left!=<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="comment">//使用两个栈来实现非递归</span></span><br><span class="line">    	LinkedList&lt;TreeNode&gt; stack1=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    	LinkedList&lt;TreeNode&gt; stack2=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    	stack1.add(root.left);</span><br><span class="line">    	stack2.add(root.right);</span><br><span class="line">    	<span class="keyword">while</span>(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty())</span><br><span class="line">    	&#123;</span><br><span class="line">    		TreeNode tn1=stack1.poll();</span><br><span class="line">    		TreeNode tn2=stack2.poll();</span><br><span class="line">    		<span class="keyword">if</span>(tn1.val!=tn2.val)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		<span class="keyword">if</span>(tn1.left==<span class="keyword">null</span> &amp;&amp; tn2.right!=<span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		<span class="keyword">if</span>(tn1.left!=<span class="keyword">null</span> &amp;&amp; tn2.right==<span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		<span class="keyword">if</span>(tn1.right==<span class="keyword">null</span> &amp;&amp; tn2.left!=<span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		<span class="keyword">if</span>(tn1.right!=<span class="keyword">null</span> &amp;&amp; tn2.left==<span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		<span class="keyword">if</span>(tn1.left!=<span class="keyword">null</span> &amp;&amp; tn2.right!=<span class="keyword">null</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			stack1.add(tn1.left);</span><br><span class="line">    			stack2.add(tn2.right);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(tn1.right!=<span class="keyword">null</span> &amp;&amp; tn2.left!=<span class="keyword">null</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			stack1.add(tn1.right);</span><br><span class="line">    			stack2.add(tn2.left);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从《琅琊榜》来看大数据]]></title>
      <url>http://codeinterviews.com/%E4%BB%8E%E3%80%8A%E7%90%85%E7%90%8A%E6%A6%9C%E3%80%8B%E6%9D%A5%E7%9C%8B%E5%A4%A7%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<p>最近看完《琅琊榜》这不热播剧后，真心感觉其是一部国产的良心之作，完美的剧情，外加杠杠的特效，使得我这个不经常看电视剧的人也能追着看完。</p>
<p>通过整个剧的回顾，我们可以惊奇的发现：人称麒麟才子的梅长苏就是一个大数据的专家先驱有木有，琅琊阁就是一个数据中心有木有！</p>
<p><img src="/img/琅琊榜/1.png" alt=""></p>
<a id="more"></a>
<p>##琅琊阁<br>俗称<strong>百事通</strong>的琅琊阁，究竟是如何做到事事都知道的呢？</p>
<p>我觉得可以从以下几个方面分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.   数据采集        </span><br><span class="line">2.   数据预处理      </span><br><span class="line">3.   数据分析与决策             </span><br><span class="line">4.   数据存储</span><br></pre></td></tr></table></figure>
<h4 id="1-数据采集"><a href="#1-数据采集" class="headerlink" title="1.数据采集"></a>1.数据采集</h4><p>飞鸽传书，这个画面在古装剧中是比较常见的，同样琅琊阁也不例外，这可是遍布天下的大数据收集端口，相当于我们现在的网络舆情监测系统之类。<br>现有大数据采集的技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flume ——一个分布式的日志收集系统          </span><br><span class="line">kafka ——分布式消息发布与订阅的系统，主要用于消息队列</span><br></pre></td></tr></table></figure>
<p>####2.数据预处理<br>小书童拆下绑在白鸽脚上的纸条，将“数据”传递给“主机”，即琅琊阁中的分析人员，然后对数据进行初步的筛选整合。这个非常像我们所做的数据预处理，需要对重要的信息进行清洗，转换，也就是ETL。<br>现有ETL工具主要为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive —— 基于hadoop的数据仓库，对HDFS中的数据进行ETL            </span><br><span class="line">spark sql —— 基于spark的数据查询与处理</span><br></pre></td></tr></table></figure>
<p>####3.数据分析与决策<br>我们风流倜傥的蔺少阁主，得到分析人员送来的数据之后，根据自己的专业背景知识和经验积累得出判断。（那个时候只能通过人靠经验来做数据分析）<br>现有的数据分析工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop —— 分布式系统，主要通过mapreduce的计算框架进行数据分析，主要面向于离线计算    </span><br><span class="line">spark —— 基于内存的分布式系统，以RDD为核心，在spark core的基础上提供了spark sql交互式查询，spark streaming流式计算，spark mlib机器学习和spark graphx图计算的支持   </span><br><span class="line">flink —— 新起之秀，与spark类似</span><br></pre></td></tr></table></figure>
<p>####4.数据存储<br>蔺少阁主发出指令，对有价值的数据信息进行归档存储。每一条数据信息都通过独有的通道进入主机，完成存储。而数以千计万计的数据信息汇总则形成了大数据。<br>现有的大数据存储工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hdfs —— 基于磁盘的分布式文件系统			</span><br><span class="line">hbase —— 基于hdfs的分布式数据库          </span><br><span class="line">mongodb —— 目前在IT行业非常流行的一种非关系型数据库(NoSql) 			</span><br><span class="line">cassandra —— 开源分布式NoSQL数据库系统</span><br></pre></td></tr></table></figure>
<p>##梅长苏<br>梅长苏与琅琊阁少阁主是好友至交，数据上能够得到琅琊阁的支持。此外，他还是江湖第一大帮派江左盟的宗主，拥有遍布天下的庞大的大数据信息收集网络。</p>
<p>在蛰伏江湖的数年之间，依托琅琊阁以及江左盟，梅长苏收集和掌握了大梁相干经济／政治／军事核心人物的海量大数据信息（错综复杂的人物及利益关系，把柄，罪证等）。经过对大数据进行系统和缜密的分析之后，这位大数据专家制定了整套洗冤／夺嫡的战略规划和解决方案，最终步步为营，实现了最初的战略目标。</p>
<p>可以说，得麒麟才子者得天下，其背后的真实玄机应该是<strong>得大数据者得天下</strong>。</p>
<p>##总结<br>如今随着数据量的急剧增长，人们开始进入大数据时代。从《琅琊榜》这部电视剧我们可以看出，充分分析大数据中的价值信息，可以为以后的决策起到关键的作用。正因为有了“琅琊阁”和“江左盟”大数据的支持，梅长苏才能凭借一身白衣，搅动这京城风云。可以说“大数据不是拥有数据，而是分析这些数据，转化为洞察，为你所用”。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-4Sum]]></title>
      <url>http://codeinterviews.com/4Sum/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####4Sum</p>
<blockquote>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
</blockquote>
<p>####Note:</p>
<ul>
<li>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)</li>
<li>The solution set must not contain duplicate quadruplets.   </li>
</ul>
<blockquote>
<pre><code>For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解是否存在四个数的和为给定的目标值，根据博客前篇的<a href="http://pisxw.com/algorithm/3Sum.html" target="_blank" rel="external">3Sum</a>和<a href="http://pisxw.com/algorithm/leetcode-two-sum.html" target="_blank" rel="external">2Sum</a>问题，该题可以将其转化为<code>3Sum</code>,然后再将<code>3Sum</code>变为<code>2Sum</code>问题。而<code>2Sum</code>问题可以通过<strong>排序后左右夹逼</strong>的方法求解，这里需要注意一点是：重复的元素需要跳过，否则会产生重复的结果。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//与求3Sum时利用2sum非常相似，4sum可以利用3sum和2sum求解</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        <span class="keyword">if</span>(num.length&lt;=<span class="number">3</span>) <span class="keyword">return</span> lists;</span><br><span class="line">        <span class="keyword">int</span> len=num.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;num[i]==num[i-<span class="number">1</span>]) <span class="comment">//表示第一个数不会重复</span></span><br><span class="line">        		<span class="keyword">continue</span>;</span><br><span class="line">        	threeSum(lists,num,i+<span class="number">1</span>,num[i],target-num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threeSum</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists,<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> term,<span class="keyword">int</span> target)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> len=num.length;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;len-<span class="number">2</span>;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span>(i&gt;start&amp;&amp;num[i]==num[i-<span class="number">1</span>])<span class="comment">//表示第二个数不会重复</span></span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		twoSum(lists,num,i+<span class="number">1</span>,term,num[i],target-num[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">twoSum</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists,<span class="keyword">int</span>[] num,<span class="keyword">int</span> start,<span class="keyword">int</span> term1,<span class="keyword">int</span> term2,<span class="keyword">int</span> target)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	 <span class="keyword">int</span> i=start;</span><br><span class="line">    	 <span class="keyword">int</span> j=num.length-<span class="number">1</span>;</span><br><span class="line">    	 <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    	 &#123;</span><br><span class="line">    	 	<span class="keyword">if</span>((num[i]+num[j])==target)</span><br><span class="line">    	 	&#123;</span><br><span class="line">    	 		ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    	 		list.add(term1);</span><br><span class="line">    	 		list.add(term2);</span><br><span class="line">    	 		list.add(num[i]);</span><br><span class="line">    	 		list.add(num[j]);</span><br><span class="line">    	 		lists.add(list);</span><br><span class="line">    	 		i++;</span><br><span class="line">    	 		j--;</span><br><span class="line">    	 		<span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]==num[i-<span class="number">1</span>]) <span class="comment">//表示第三和第四个数不会重复</span></span><br><span class="line">    	 			i++;</span><br><span class="line">    	 		<span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]==num[j+<span class="number">1</span>])</span><br><span class="line">    	 			j--;</span><br><span class="line">    	 	&#125;<span class="keyword">else</span> <span class="keyword">if</span>((num[i]+num[j])&gt;target)</span><br><span class="line">    	 	&#123;</span><br><span class="line">    	 		j--;</span><br><span class="line">    	 	&#125;<span class="keyword">else</span></span><br><span class="line">    	 		i++;</span><br><span class="line">    	 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MarkDown使用]]></title>
      <url>http://codeinterviews.com/mark-down/</url>
      <content type="html"><![CDATA[<p>##引言<br>MarkDown的目标是实现<code>易读易写</code>。它用来作为一种网络内容的写作语言。但是我们不是要用它来取代HTML，而是它能让文档更容易阅读、编写。</p>
<p>参考图灵社区<a href="http://www.ituring.com.cn/article/504" target="_blank" rel="external">MarkDown语言说明（详解版）</a>。<br><a id="more"></a></p>
<p>##标题<br>MarkDown支持的标语语法有以下两种：<code>Setext</code>和<code>Atx</code>  </p>
<p>####Setext形式<br>主要采用底线的形式表示，利用<code>=</code>(一级标题)和<code>-</code>(二级标题)，例如：  </p>
<pre><code>一级标题
=======

二级标题
-------
</code></pre><p>任何数量的<code>=</code>和<code>-</code>都有效果。</p>
<p>####Atx形式<br>Atx形式是通过在前端加入1到6个<code>#</code>，从而对应到标题<code>h1</code>到<code>h6</code>，井字的数量决定了标题的级别，例如：</p>
<pre><code>#这是h1标题

##这是h2标题

####这是h4标题
</code></pre><p>##段落、换行和首行缩进<br><strong>段落</strong>是有一个以上相连接的行句组成，段落之间是以空行来进行切分（若一行只包含空白和tab,该行也被视为空行）</p>
<p><strong>换行</strong>在html中是采用<code>&lt;br /&gt;</code>标签，在此是通过<strong>行尾加上两个以上的空白构成</strong></p>
<p><strong>首行缩进</strong>是在行的最前端插入两个<code>$emsp;</code>,从而实现缩进两字。</p>
<p>##区块引言<br>MarkDown中的区块引言采用email形式，通过在每行前面添加<code>&gt;</code>，例子：</p>
<pre><code>&gt;这是一个区块引言事例
&gt;通过&gt;符号来达到引言的效果。

&gt;而且也允许只在整个段落的第一行
最前面加上&gt;。
</code></pre><p>当然，在区块中也存在级别的划分，即<strong>引言的引言</strong>，只要根据级别添加不同数量的<code>&gt;</code>即可，例子：</p>
<pre><code>&gt;这里是第一级别
&gt;
&gt;&gt;这里是第二级别，内嵌的引言
&gt;
&gt;返回第一级别
</code></pre><p>在区块引言中也可以使用其他的MarkDown语法，包括标题，列表等，例子：</p>
<pre><code>&gt;##这是标题
&gt;
&gt;1.这是列表第一项
&gt;2.这是列表第二项
</code></pre><p>##列表<br>在MarkDowm中支持有序列表和无序列表。</p>
<p>####无序列表<br>无序列表采用<code>*</code>,<code>+</code>或是<code>-</code>作为列表标记：</p>
<pre><code>* 红
* 绿
* 蓝
</code></pre><p>等价于：</p>
<pre><code>+ 红
+ 绿
+ 蓝
</code></pre><p>也等价于：</p>
<pre><code>- 红
- 绿
- 蓝
</code></pre><p>####有序列表<br>有序列表采用数字后面接着一个英文句号<code>.</code>来表示：</p>
<pre><code>1. 红
2. 绿
3. 蓝
</code></pre><p>##程序代码区块<br>和程序相关的写作或是语言原始代码通常会有排版好的程序代码区块，一般不希望采用文本的方式去排版，而是照原有的样子去显示。</p>
<p>在MarkDown中建立程序代码区块很简单，只要简单地<strong>缩进4个空白或是1个tab</strong>即可，例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##分隔线<br>可以在一行中使用<strong>三个或以上的<code>*</code>,<code>-</code>或是<code>_</code></strong>来建立一个分割线，行内不能有其他东西，一下写法都可以建立分隔符：</p>
<pre><code>***

******

---

________
</code></pre><p>##链接<br>MarkDown支持两种形式的链接语法，分别为<strong>行内</strong>和<strong>参考</strong>两种。</p>
<p>####行内链接<br>行内形式的链接，是在方块括号后面马上接着括号并插入网址链接，如果你还想要加上链接的title文字，只要在网址后面，用双引号把title文字包起来即可，例子，创建google的链接：</p>
<pre><code>这里是搜索引擎[google](https://www.google.com)

这里是搜索引擎[google](https://www.google.com &quot;Title&quot;)
</code></pre><p>当然在上面的链接中可以使用本地的相对路径。</p>
<p>####参考链接<br>参考链接是使用另一个方括号接在链接文字的括号后面，在第二个方括号里面要填入用以辨识链接的标签：</p>
<pre><code>这里是搜索引擎[google][1]
[1]:https://www.google.com 

这里是搜索引擎[google][1]
[1]:https://www.google.com &quot;Title&quot;
</code></pre><p>默认的链接标签功能可以省略指定链接标签，在这种情况下，<strong>链接标签和链接文字会视为相同</strong>，例子：</p>
<pre><code>这里是搜索引擎[google][]
[google]:https://www.google.com 
</code></pre><p>链接的定义可以放在文档中的任何一个地方，可以直接放在链接出现段落的后面，也可以把它放在文档最后面，就像是批注一样。</p>
<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
 [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;
</code></pre><p>##自动链接<br>MarkDown也支持比较简短的自动链接形式来处理网址和电子邮件信箱，只需要使用<strong>方括号</strong>包起来，例如：</p>
<pre><code>&lt;http://www.google.com&gt;

MarkDown会转换成下面的html代码：
&lt;a href=&quot;http://www.google.com&quot;&gt;http://www.google.com&lt;/a&gt;
</code></pre><p>##强调<br>MarkDown中使用<code>*</code>和<code>_</code>作为标记强调字词的符号，主要分为<strong><em>倾斜</em></strong>和<strong>加粗</strong>。</p>
<p>####倾斜<br>用一个<code>*</code>或<code>_</code>包围的字词会被变成倾斜，从而在html中被<code>&lt;em&gt;</code>标签包围，例子：</p>
<pre><code>*倾斜*

_倾斜_
</code></pre><p>####加粗<br>用两个<code>*</code>或<code>_</code>包围的字词会被加粗，从而在html中被<code>&lt;strong&gt;</code>标签包围，例子：</p>
<pre><code>**加粗**

__加粗__
</code></pre><p>如果要在文字前后直接插入普通的星号或底线，可以用反斜杠：</p>
<pre><code>\*普通的文本\*
</code></pre><p>##图片引用<br>MarkDown中采用和链接相似的语法来标记图片，同样也允许两种样式：<strong>行内</strong>和<strong>参考</strong>。</p>
<p>####行内<br>行内的语法和链接很相似，只是在最前端加上了一个<code>!</code>符号，例子：</p>
<pre><code>![Alt text](/path/img/test.jpg)

![Alt text](/path/img/test.jpg &quot;title&quot;)
</code></pre><p>####参考<br>参考的语法如下所示：</p>
<pre><code>![Alt text][1]
[1]:/path/img/test.jpg

![Alt text][1]
[1]:/path/img/test.jpg &quot;title&quot;
</code></pre><p>但是，到目前为止，在MarkDown中无法指定图片的宽和高，如果需要的话，可以使用普通的<code>&lt;img&gt;</code>标签。</p>
<p>##转义字符<br>如果想在MarkDown中插入以下的普通的符号，需要使用<code>\</code>进行转义:</p>
<pre><code>\   反斜杠  --&gt; \\
`   反引号  --&gt; \`
*   星号    --&gt; \*
_   底线    --&gt; \_
{}  大括号  --&gt; \{  \}
[]  方括号  --&gt; \[  \]
()  括号    --&gt; \(  \)
#   井字号  --&gt; \#
+   加号    --&gt; \+
-   减号    --&gt; \-
.   英文句点 --&gt; \.
!   惊叹号  --&gt; \!
</code></pre><p>##MarkDown编辑器</p>
<p>####在线编辑器<br><a href="http://www.zybuluo.com/mdeditor" target="_blank" rel="external">Cmd Markdown</a><br><a href="http://stackedit.io/" target="_blank" rel="external">Stackedit</a></p>
<p>####本地编辑器<br><a href="http://markdownpad.com/" target="_blank" rel="external">MarkdownPad</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-TwoSum]]></title>
      <url>http://codeinterviews.com/leetcode-two-sum/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h4 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h4><blockquote>
<p>   Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>   The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.<br>   Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>   You may assume that each input would have exactly one solution.</p>
<p>   Input: numbers={2, 7, 11, 15}, target=9<br>   Output: index1=1, index2=2</p>
</blockquote>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题是在给定一个数组中，搜索是否存在两个数的和等于给定的值。如果存在，则返回两个数的数组下标。如果采用“暴搜”，则时间复杂度为<code>O(n^2)</code>,为了降低时间复杂度，显然是需要在查询方面做文章，因此可以采用<strong>散列</strong>存储。  </p>
<p>散列是将给定的值转变为一个数组的下标，即散列码，然后在数组中存放值的List。在JAVA中,散列码的求解采用<code>HashCode()</code>函数。具有散列功能的<code>Collections</code>容器有以下四种:<code>HashMap</code>,<code>LinkedHashMap</code>,<code>HashSet</code>和<code>LinkedHashSet</code>，因此本文采用<code>HashMap</code>实现散列功能，使得时间复杂度变为<code>O(n)</code>。</p>
<h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><p>代码采用JAVA实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;  </span><br><span class="line">   		HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> cha=target-numbers[i];  </span><br><span class="line">           	<span class="keyword">if</span>(map.containsKey(cha))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(cha)+<span class="number">1</span>,i+<span class="number">1</span>&#125;;</span><br><span class="line">			map.put(numbers[i],i);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python代码：</p>
<pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>
    <span class="comment"># @return a tuple, (index1, index2)</span>
    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, num, target)</span>:</span>
        process={}
        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(num)):
            <span class="keyword">if</span> target-num[index] <span class="keyword">in</span> process:
                <span class="keyword">return</span> (process[target-num[index]]+<span class="number">1</span>,index+<span class="number">1</span>)
            process[num[index]]=index
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-String to Integer (atoi)]]></title>
      <url>http://codeinterviews.com/leetcode-String-to-Integer/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####String to Integer (atoi) </p>
<blockquote>
<p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<p>####Requirements for atoi:<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是将字符串转换为整数，但是其中结束条件比较多。需要考虑正负符号问题和整数越界问题。</p>
<p>####该算法的求解步骤如下：</p>
<pre><code>1. 先去掉多余的空格字符，从第一个非空格字符开始。
2. 按顺序读数字，如果出现下面三种情况则结束：
    2.1 异常字符出现（按照C语言的标准是把异常字符后面的全部截掉，保留前面的部分作为结果）。
    2.2 数字越界（返回最接近的整数）。
    2.3 字符串结束
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">atoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c=str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len=c.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(c[i]==<span class="string">' '</span>&amp;&amp;i&lt;len) <span class="comment">//从第一个非空格字符开始</span></span><br><span class="line">        	i++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[i]==<span class="string">'+'</span>)   <span class="comment">//判断整数的符号，如果没有正负号，则默认为正</span></span><br><span class="line">        &#123;</span><br><span class="line">        	sign=<span class="number">1</span>;</span><br><span class="line">        	i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            	sign=-<span class="number">1</span>;</span><br><span class="line">            	i++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(c[i]&lt;<span class="string">'0'</span>||c[i]&gt;<span class="string">'9'</span>) <span class="comment">//如果出现异常字符则退出</span></span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	<span class="keyword">if</span>((num&gt;Integer.MAX_VALUE/<span class="number">10</span>)||((num==Integer.MAX_VALUE/<span class="number">10</span>)&amp;&amp;((c[i]-<span class="string">'0'</span>)&gt;Integer.MAX_VALUE%<span class="number">10</span>))) <span class="comment">//如果出现数值越界，则返回最接近的整数</span></span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>(sign==<span class="number">1</span>)</span><br><span class="line">        			<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        		<span class="keyword">else</span></span><br><span class="line">        			<span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        	&#125;</span><br><span class="line">        	num=num*<span class="number">10</span>+(c[i]-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign*num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-ZigZag Conversion]]></title>
      <url>http://codeinterviews.com/leetcode-ZigZag-Conversion/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####ZigZag Conversion</p>
<blockquote>
<p>The string <code>PAYPALISHIRING</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)  </p>
<pre><code>P   A   H   N  
A P L S I I G  
Y   I   R    
</code></pre><p>And then read line by line: <code>PAHNAPLSIIGYIR</code><br>Write the code that will take a string and make this conversion given a number of rows:</p>
<pre><code>string convert(string text, int nRows);
</code></pre><p>convert(“PAYPALISHIRING”, 3) should return <code>PAHNAPLSIIGYIR</code>.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是将字符串按锯齿形进行排列，然后按行进行输出。该题指定了行数<code>nRows</code>,则每个锯齿(ZigZag)中的元素个数为<code>2*nRows-2</code>,接下来就是对每一行进行遍历，由于其中从<strong>第1行</strong>到<strong>第nRows-2行</strong>中会有穿插的元素，例如上述的<code>P</code>，所以需要考虑这些元素的坐标，其实他们的坐标为<code>j+zigzag-2*i</code>,因为他们是zigzag中倒数第<code>2*i</code>个元素，<code>i</code>为行坐标。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> nRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个zigzag是2*m-2个字符就可以，这里m是结果的行的数量</span></span><br><span class="line">        <span class="keyword">char</span>[] c=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len=c.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(nRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> zigsize=<span class="number">2</span>*nRows-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;j+=zigsize)</span><br><span class="line">          &#123;</span><br><span class="line">              result+=c[j];</span><br><span class="line">              <span class="comment">//需要判断j后面紧跟的元素，它的坐标为j+zigsize-2*i,因为i表示行，正好为倒数第2*i个元素</span></span><br><span class="line">              <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=nRows-<span class="number">1</span>&amp;&amp;(j+zigsize-<span class="number">2</span>*i)&lt;len)</span><br><span class="line">                    result+=c[j+zigsize-<span class="number">2</span>*i];</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Reverse Integer]]></title>
      <url>http://codeinterviews.com/leetcode-Reverse-Integer/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Reverse Integer</p>
<blockquote>
<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321</p>
<p>Example2: x = -123, return -321</p>
<p>####Have you thought about this?<br>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p>
<p>If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.</p>
<p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p>
<p>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是将给定的整数进行逆序输出，可以通过对10进行取余而得到其个位，十位，百位等。<br>但是需要注意以下三个问题：</p>
<pre><code>1.对于负数的逆序，只需要对其正数进行翻转，然后添加符号即可。
2.类似于100这样的数，最后的结果应该是1，而不是001.
3.逆转之后可能会产生比原数更大的数，从而造成整数的溢出。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> -reverse(-x);</span><br><span class="line">        <span class="comment">//每次取模相加，考虑到末尾为0的情况</span></span><br><span class="line">        <span class="keyword">int</span> reverseNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> modnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            modnum=x%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//考虑翻转会溢出的情况</span></span><br><span class="line">            <span class="keyword">if</span>((reverseNum&gt;Integer.MAX_VALUE/<span class="number">10</span>)||((reverseNum==Integer.MAX_VALUE/<span class="number">10</span>)&amp;&amp;(modnum&gt;Integer.MAX_VALUE%<span class="number">10</span>)))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            reverseNum=reverseNum*<span class="number">10</span>+modnum;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Median of Two Sorted Arrays]]></title>
      <url>http://codeinterviews.com/leetcode-Median-of-Two-Sorted-Arrays/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Median of Two Sorted Arrays</p>
<blockquote>
<p>There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)).</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解两个以排序好的数组中的中位数，一般的想法是我们首先先将这两个数组进行合并，然后在找到其中的中位数，其坐标为<code>k=(m+n)/2</code>,但是此时的时间复杂度为<code>O(m+n)</code>,不符合题意。因此需要进行优化。</p>
<p>上述问题其实可以看成是<strong>求两个数组中的第K大的数是多少</strong>。基本思想是每次通过查看两个数组的第k/2大的数(假设为<code>A[k/2]</code>和<code>B[k/2]</code>),如果<code>A[k/2]=B[k/2]</code>,则说明当前这个数即为两个数组中的第k大的数，如果<code>A[k/2]&gt;B[k/2]</code>,则说明第k大的数肯定不在B的前k/2个元素中，此时则可以不用考虑B的前k/2个元素，同上，如果<code>A[k/2]&lt;B[k/2]</code>,则说明第k大的数肯定不在A的前k/2个元素中，此时则可以不用考虑A的前k/2个元素，这样每次可以排除k/2个元素，最终k=1时即为结果。<br>整个算法的时间复杂度为<code>O(logk)</code>，由于<code>k=(m+n)/2</code>，所以复杂度为<code>O(log(m+n))</code></p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//as表示A的重新起点，bs表示B的重新起点  </span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> as,<span class="keyword">int</span> m,<span class="keyword">int</span> B[],<span class="keyword">int</span> bs,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> B[bs+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> A[as+k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)</span><br><span class="line">            <span class="keyword">return</span> findKth(B,bs,n,A,as,m,k);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.min(A[as],B[bs]);</span><br><span class="line">        <span class="keyword">int</span> pa=Math.min((k+<span class="number">1</span>)/<span class="number">2</span>,m),pb=k-pa;</span><br><span class="line">        <span class="keyword">if</span>(A[as+pa-<span class="number">1</span>]&lt;B[bs+pb-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(A,as+pa,m-pa,B,bs,n,k-pa);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[as+pa-<span class="number">1</span>]&gt;B[bs+pb-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> findKth(A,as,m,B,bs+pb,n-pb,k-pb);</span><br><span class="line">             <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> A[as+pa-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=A.length;</span><br><span class="line">        <span class="keyword">int</span> n=B.length;</span><br><span class="line">        <span class="keyword">int</span> s=m+n;</span><br><span class="line">        <span class="keyword">if</span>(s%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> findKth(A,<span class="number">0</span>,m,B,<span class="number">0</span>,n,s/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(A,<span class="number">0</span>,m,B,<span class="number">0</span>,n,s/<span class="number">2</span>)+findKth(A,<span class="number">0</span>,m,B,<span class="number">0</span>,n,s/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Palindrome Number]]></title>
      <url>http://codeinterviews.com/leetcode-Palindrome-Number/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Palindrome Number</p>
<blockquote>
<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>####Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>
<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>
<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>
<p>There is a more generic way of solving this problem.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是判断一个整数是不是回文数，即整数逆序翻转之后与原数相同。整数的翻转可以借鉴<a href="http://pisxw.com/algorithm/leetcode-Reverse-Integer.html" target="_blank" rel="external">LeetCode-Reverse Integer</a>中的方法。这里有一个情况需要考虑，如果整数为负数，则该整数不是回文数。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//负数不是回文</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//对数值进行翻转，回文翻转之后还等于原来的数</span></span><br><span class="line">        <span class="keyword">int</span> reverseNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=x;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> modnum=num%<span class="number">10</span>;</span><br><span class="line">        	<span class="comment">//考虑翻转会溢出的情况</span></span><br><span class="line">        	<span class="keyword">if</span>((reverseNum&gt;Integer.MAX_VALUE/<span class="number">10</span>)||((reverseNum==Integer.MAX_VALUE/<span class="number">10</span>)&amp;&amp;(modnum&gt;Integer.MAX_VALUE%<span class="number">10</span>)))</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        	reverseNum=reverseNum*<span class="number">10</span>+modnum;</span><br><span class="line">        	num=num/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(reverseNum==x)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Roman to Integer]]></title>
      <url>http://codeinterviews.com/leetcode-Roman-to-Integer/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Roman to Integer</p>
<blockquote>
<p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是将罗马数字转化为整数，与<a href="http://pisxw.com/algorithm/leetcode-Integer-to-Roman.html" target="_blank" rel="external">Integer to Roman</a>的解法比较类似，都是字符串的处理问题，只需要知道罗马数字和整数之间的对应关系即可。</p>
<pre><code>罗马数字为以下表示形式：
  I 1
  V 5
  X 10
  L 50
  C 100
  D 500
  M 1,000

  罗马数字对于每个位有三个单位：1,5,10，对于1到9，表示方法如下：
  1-3：用1表示；
  4: 5左边加一个1；
  5： 直接用5表示； 
  6-8: 5右边加相应的1；
  9： 10左边加一个1。
</code></pre><p>其中需要注意的是：如果1下一个字符是对应位的5或者10，则减去该位的1（例如4，9），否则加之。遇到5或者10就直接加上对应位的5或者10</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//就是维护一个整数，然后如果1下一个字符是对应位的5或者10则减对应位的1，否则加之。遇到5或者10就直接加上对应位的5或者10</span></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">	  I	1</span><br><span class="line">      V	5</span><br><span class="line">      X	10</span><br><span class="line">      L	50</span><br><span class="line">      C	100</span><br><span class="line">      D	500</span><br><span class="line">      M	1,000</span><br><span class="line"></span><br><span class="line">      罗马数字对于每个位有三个单位：1,5,10，对于1到9，表示方法如下：</span><br><span class="line">	  1-3：用1表示；</span><br><span class="line">	  4: 5左边加一个1；</span><br><span class="line">	  5： 直接用5表示； </span><br><span class="line">	  6-8: 5右边加相应的1；</span><br><span class="line">	  9： 10左边加一个1。</span><br><span class="line">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] c=s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(c.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">switch</span>(c[i])</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'I'</span>:&#123;</span><br><span class="line">        			<span class="keyword">if</span>((i&lt;c.length-<span class="number">1</span>)&amp;&amp;(c[i+<span class="number">1</span>]==<span class="string">'V'</span>||c[i+<span class="number">1</span>]==<span class="string">'X'</span>))</span><br><span class="line">        				num-=<span class="number">1</span>;</span><br><span class="line">        			<span class="keyword">else</span></span><br><span class="line">        				num+=<span class="number">1</span>;</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'V'</span>:&#123;num+=<span class="number">5</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'X'</span>:&#123;</span><br><span class="line">        			<span class="keyword">if</span>((i&lt;c.length-<span class="number">1</span>)&amp;&amp;(c[i+<span class="number">1</span>]==<span class="string">'L'</span>||c[i+<span class="number">1</span>]==<span class="string">'C'</span>))</span><br><span class="line">        				num-=<span class="number">10</span>;</span><br><span class="line">        			<span class="keyword">else</span></span><br><span class="line">        				num+=<span class="number">10</span>;</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'L'</span>:&#123;num+=<span class="number">50</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'C'</span>:&#123;</span><br><span class="line">        			<span class="keyword">if</span>((i&lt;c.length-<span class="number">1</span>)&amp;&amp;(c[i+<span class="number">1</span>]==<span class="string">'D'</span>||c[i+<span class="number">1</span>]==<span class="string">'M'</span>))</span><br><span class="line">        				num-=<span class="number">100</span>;</span><br><span class="line">        			<span class="keyword">else</span></span><br><span class="line">        				num+=<span class="number">100</span>;</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'D'</span>:&#123;num+=<span class="number">500</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        		<span class="keyword">case</span> <span class="string">'M'</span>:&#123;num+=<span class="number">1000</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        		<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Regular Expression Matching]]></title>
      <url>http://codeinterviews.com/leetcode-Regular-Expression-Matching/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Regular Expression Matching</p>
<blockquote>
<p>Implement regular expression matching with support for ‘.’ and ‘*’.</p>
<pre><code>&apos;.&apos; Matches any single character.
&apos;*&apos; Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch(&quot;aa&quot;,&quot;a&quot;) → false
isMatch(&quot;aa&quot;,&quot;aa&quot;) → true
isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false
isMatch(&quot;aa&quot;, &quot;a*&quot;) → true
isMatch(&quot;aa&quot;, &quot;.*&quot;) → true
isMatch(&quot;ab&quot;, &quot;.*&quot;) → true
isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true
</code></pre></blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是对字符串进行正则表达式匹配，可以采用动态规划的方法进行求解。动态规划基本思想就是把我们计算过的历史信息记录下来，等到要用到的时候就直接使用，不用重新计算。<br>在这个题里面，假设我们维护一个布尔数组res[i+1][j+1],代表s的前i个字符和p的前j个字符是否匹配(注意这里res的维度是s.length()+1,p.length()+1)。以下主要分三种情况：  </p>
<pre><code>1. p[j]不是&apos;*&apos;。情况比较简单，只要判断如果当前s的i和p的j上的字符一样（如果有p在j上的字符是&apos;.&apos;,也是相同），并且res[i][j]==true，则res[i+1][j+1]也为true，否则res[i+1][j+1]=false; 
2. p[j]是&apos;*&apos;，但是p[j-1]!=&apos;.&apos;。那么只要以下条件有一个满足即可对res[i+1][j+1]=true： 
    2.1 res[i+1][j]为真（&apos;*&apos;只取前面字符一次）; 
    2.2 res[i+1][j-1]为真（&apos;*&apos;前面字符一次都不取，也就是忽略这两个字符）; 
    2.3 res[i][j+1]=true &amp;&amp; s[i]==s[i-1] &amp;&amp; s[i-1]==p[j-1](这种情况是相当于i从0到s.length()扫过来，如果p[j]对应的字符是‘*’那就意味着接下来的串就可以依次匹配下来，如果下面的字符一直重复，并且就是‘*’前面的那个字符）。 
3. p[j]是&apos;*&apos;，并且p[j-1]==&apos;.&apos;。因为&quot;.*&quot;可以匹配任意字符串，所以在前面的res[i+1][j-1]或者res[i+1][j]中只要有i+1是true，那么剩下的res[i+1][j+1],res[i+2][j+1],...,res[s.length()][j+1]就都是true了。 
</code></pre><p>这道题有个很重要的点，就是<strong>实现的时候外层循环应该是p,然后待匹配串s内层循环扫过来</strong>。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//res[i+1][j+1]结尾为是s[i]和p[j]</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span> &amp;&amp; p.length()==<span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span>(p.length()==<span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">boolean</span>[][] res = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];  </span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p.length();j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j)==<span class="string">'*'</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; res[<span class="number">0</span>][j-<span class="number">1</span>]) res[<span class="number">0</span>][j+<span class="number">1</span>]=<span class="keyword">true</span>;  </span><br><span class="line">                <span class="keyword">if</span>(j&lt;<span class="number">1</span>) <span class="keyword">continue</span>;  </span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)!=<span class="string">'.'</span>)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        <span class="keyword">if</span>(res[i+<span class="number">1</span>][j] || j&gt;<span class="number">0</span>&amp;&amp;res[i+<span class="number">1</span>][j-<span class="number">1</span>]   </span><br><span class="line">                        || i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span> &amp;&amp; res[i][j+<span class="number">1</span>]&amp;&amp;s.charAt(i)==s.charAt(i-<span class="number">1</span>)&amp;&amp;s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">1</span>))  </span><br><span class="line">                            res[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="keyword">true</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">                    <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; i&lt;s.length() &amp;&amp; !res[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; !res[i+<span class="number">1</span>][j])  </span><br><span class="line">                        i++;  </span><br><span class="line">                    <span class="keyword">for</span>(;i&lt;s.length();i++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        res[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="keyword">true</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(i)==p.charAt(j) || p.charAt(j)==<span class="string">'.'</span>)  </span><br><span class="line">                        res[i+<span class="number">1</span>][j+<span class="number">1</span>] = res[i][j];  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> res[s.length()][p.length()];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Longest Substring Without Repeating Characters]]></title>
      <url>http://codeinterviews.com/leetcode-Longest-Substring-Without-Repeating-Characters/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Longest Substring Without Repeating Characters</p>
<blockquote>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解不包含重复元素的最长字串问题，如果采用“暴力法”求解，时间复杂度为<code>O(n^3)</code>,因为每次都要对子串查看是否有元素重复。</p>
<p>本文采用动态规划的方法，假设<code>A[0]</code>到<code>A[i]</code>的最长不包含重复元素字串长度为<code>maxsublength</code>,那么当加入一个元素<code>A[i+1]</code>时，需要考虑的是包含<code>A[i+1]</code>在内的最长不包含重复元素字串，所以可以通过以<code>A[i+1]</code>起始向前搜索而找到,设长度为<code>length</code>。在这里，可以通过定义<code>barrier</code>表示以<code>A[i]</code>为起始，向前搜索而出现第一次重复的位置，这样<code>A[i+1]</code>的前向搜索最多只需搜索到<code>A[barrier+1]</code>。因此<code>A[0]</code>到<code>A[i+1]</code>的最长不包含重复元素字串长度为<code>Max(maxsublength,length)</code>。</p>
<pre><code>动态规划的形式化定义如下：
----------
length(i)：以A[i]结尾的最长不包含重复元素字串的长度；
maxlength(i,j):A[i]到A[j]的最长不包含重复元素字串的长度；
----------
if i=0 Then maxlength(0,0)=1;
if i&gt;=1 Then maxlength(0,i)=Max(maxlength(0,i-1),length(i));
----------
求解：maxlength(0,A.length);
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] c=s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(c.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxsublength=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> barrier=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=barrier;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(c[i]==c[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    barrier=j+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxsublength=Math.max(maxsublength,i-barrier+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsublength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Longest Palindromic Substring]]></title>
      <url>http://codeinterviews.com/leetcode-Longest-Palindromic-Substring/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Longest Palindromic Substring</p>
<blockquote>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解一个字符串中的最长回文字符串，<strong>回文字符串</strong>的意思是正读和反读都一样的字符串，由于该问题包含最优子结构，因此可以采用<strong>动态规划</strong>的方法求解。</p>
<p>如果<code>String.length=1</code>,则该字符串必定是回文字符串。<br>如果<code>String.length=2</code>,则只有当<code>String[0]==String[1]</code>时，该字符串才是回文字符串。<br>如果<code>String.length&gt;=3</code>,则只有当<code>String[0]==String[String.length-1]且String[1]~String[String.length-2]是回文字符串</code>，该字符串才是回文字符串。</p>
<pre><code>动态规划的形式化定义如下：
-----------
p[i][j]:字符串中第i位到第j位是否是回文
-----------
if i==j Then p[i][i]=true;
if j-i=1 &amp;&amp; c[i]==c[j] Then p[i][j]=true;
if j-i&gt;=2 &amp;&amp; c[i]==c[j] &amp;&amp; p[i+1][j-1]==true Then p[i][j]=true;
-----------
通过对长度从1到String.length进行遍历，最终就可得到最长的回文字符串。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] c=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] p=<span class="keyword">new</span> <span class="keyword">int</span>[c.length][c.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length;i++)</span><br><span class="line">            Arrays.fill(p[i],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> startindex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlong=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length;i++)</span><br><span class="line">            p[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]==c[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">               p[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">               startindex=i;</span><br><span class="line">               maxlong=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=c.length;len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length-len+<span class="number">1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((c[i]==c[i+len-<span class="number">1</span>])&amp;&amp;(p[i+<span class="number">1</span>][i+len-<span class="number">1</span>-<span class="number">1</span>]==<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    p[i][i+len-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    startindex=i;</span><br><span class="line">                    maxlong=len;</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(startindex,startindex+maxlong);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Longest Common Prefix]]></title>
      <url>http://codeinterviews.com/leetcode-Longest-Common-Prefix%20/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Longest Common Prefix</p>
<blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解一个字符串数组的最长公共前缀，这里可以采用“暴力法”，对字符从头开始进行遍历，看是否符合标准，如果不同，则跳出循环返回当前结果，否则继续下一个字符。当然这里可以选取String[0],即第一个字符串作为比较的标准。<br>整个算法的时间复杂度应该是<code>O(m*n)</code>，<code>m</code>表示字符串的最大长度，<code>n</code>表示字符串的个数，空间复杂度应该是<code>O(m)</code>,即字符串的长度。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//以第一个字符串为标准进行比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> offset=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isCommonPrefix=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(isCommonPrefix)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)</span><br><span class="line">        	&#123;</span><br><span class="line">        		<span class="keyword">if</span>((offset==strs[i].length())||(strs[i].charAt(offset)!=strs[<span class="number">0</span>].charAt(offset)))</span><br><span class="line">        		&#123;</span><br><span class="line">        			isCommonPrefix=<span class="keyword">false</span>;</span><br><span class="line">        			<span class="keyword">break</span>;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	offset+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (offset-<span class="number">1</span>)==<span class="number">0</span>?<span class="string">""</span>:strs[<span class="number">0</span>].substring(<span class="number">0</span>,offset-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Integer to Roman]]></title>
      <url>http://codeinterviews.com/leetcode-Integer-to-Roman/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Integer to Roman</p>
<blockquote>
<p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是将整数变为罗马数字，主要考虑的是字符串操作。需要注意的数字和罗马数字的对应关系。</p>
<pre><code>罗马数字为以下表示形式：
  I    1
  V    5
  X    10
  L    50
  C    100
  D    500
  M    1,000

  罗马数字对于每个位有三个单位：1,5,10，对于1到9，表示方法如下：
  1-3：用1表示；
  4: 5左边加一个1；
  5： 直接用5表示； 
  6-8: 5右边加相应的1；
  9： 10左边加一个1。
</code></pre><p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	  I	1</span><br><span class="line">      V	5</span><br><span class="line">      X	10</span><br><span class="line">      L	50</span><br><span class="line">      C	100</span><br><span class="line">      D	500</span><br><span class="line">      M	1,000</span><br><span class="line"></span><br><span class="line">      罗马数字对于每个位有三个单位：1,5,10，对于1到9，表示方法如下：</span><br><span class="line">	  1-3：用1表示；</span><br><span class="line">	  4: 5左边加一个1；</span><br><span class="line">	  5： 直接用5表示； </span><br><span class="line">	  6-8: 5右边加相应的1；</span><br><span class="line">	  9： 10左边加一个1。</span><br><span class="line">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">0</span>||num&gt;<span class="number">3999</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> dev=<span class="number">1000</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(dev&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	list.add(num/dev);</span><br><span class="line">        	num=num%dev;</span><br><span class="line">        	dev=dev/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从千位开始，对每一位进行转换，但是每一位对应的罗马数字也有范围</span></span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        result+=convert(list.get(<span class="number">0</span>),<span class="string">'M'</span>,<span class="string">' '</span>,<span class="string">' '</span>);</span><br><span class="line">        result+=convert(list.get(<span class="number">1</span>),<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'M'</span>);</span><br><span class="line">        result+=convert(list.get(<span class="number">2</span>),<span class="string">'X'</span>,<span class="string">'L'</span>,<span class="string">'C'</span>);</span><br><span class="line">        result+=convert(list.get(<span class="number">3</span>),<span class="string">'I'</span>,<span class="string">'V'</span>,<span class="string">'X'</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> c1,<span class="keyword">char</span> c5,<span class="keyword">char</span> c10)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    	String s=<span class="string">""</span>;</span><br><span class="line">    	<span class="keyword">switch</span>(num)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">9</span>:&#123;s+=c1;s+=c10;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">8</span>:&#123;s+=c5;s+=c1;s+=c1;s+=c1;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">7</span>:&#123;s+=c5;s+=c1;s+=c1;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">6</span>:&#123;s+=c5;s+=c1;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">5</span>:&#123;s+=c5;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">4</span>:&#123;s+=c1;s+=c5;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">3</span>:&#123;s+=c1;s+=c1;s+=c1;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">2</span>:&#123;s+=c1;s+=c1;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">case</span> <span class="number">1</span>:&#123;s+=c1;<span class="keyword">break</span>;&#125;</span><br><span class="line">    		<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Add Two Numbers]]></title>
      <url>http://codeinterviews.com/leetcode-Add-Two-Numbers/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Add Two Numbers</p>
<blockquote>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该方法是用链表来表示两个整数间的求和，由于采用逆序排列，因此在做加法时只需要遍历两个链表即可，其中需要保存每一位相加后产生的进位。<br>需要注意的是最后一位相加是否产生新的进位。整体的时间复杂度为<code>O(n)</code>。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode l3=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode result=l3;</span><br><span class="line">        ListNode prel3=l3;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s=l1.val+l2.val+l3.val;</span><br><span class="line">            l3.val=s%<span class="number">10</span>;</span><br><span class="line">            l3.next=<span class="keyword">new</span> ListNode(s/<span class="number">10</span>);</span><br><span class="line">            l1=l1.next;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">            prel3=l3;</span><br><span class="line">            l3=l3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode rest;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">            rest=l2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rest=l1;</span><br><span class="line">        <span class="keyword">while</span>(rest!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s=rest.val+l3.val;</span><br><span class="line">            l3.val=s%<span class="number">10</span>;</span><br><span class="line">            l3.next=<span class="keyword">new</span> ListNode(s/<span class="number">10</span>);</span><br><span class="line">            rest=rest.next;</span><br><span class="line">            prel3=l3;</span><br><span class="line">            l3=l3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l3.val==<span class="number">0</span>)</span><br><span class="line">            prel3.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l3.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode-Container With Most Water]]></title>
      <url>http://codeinterviews.com/leetcode-Container-With-Most-Water/</url>
      <content type="html"><![CDATA[<p>##题目</p>
<p>####Container With Most Water</p>
<blockquote>
<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container.</p>
</blockquote>
<a id="more"></a>
<p>##解题思路<br>该题是求解最大的容积问题，如果我们采用“暴力法”求解，则每一对pair都需要计算一次容积，然后获得最大的那个，时间复杂度为<code>O(n^2)</code>。<br>因此需要对其进行优化，这里我们可以采用<strong>左右夹逼</strong>法求解，从数组两端开始，分别设置左指针<code>pLeft</code>和右指针<code>pRight</code>,然后比较<code>pLeft</code>和<code>pRight</code>哪个数值大，假设<code>pLeft</code>小，则如果向左移动<code>pRight</code>,出现的容积不可能比现在好，因为瓶颈在<code>pLeft</code>处，所以只有向右移动<code>pLeft</code>,才可能出现更大的容积。当然，在这个左右移动指针的过程中，需要维护一个最大的容积。</p>
<p>##算法代码<br>代码采用JAVA实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//采用左右夹逼法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=height.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxarea=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">int</span> area=Math.abs(i-j)*Math.min(height[i],height[j]);</span><br><span class="line">        	<span class="keyword">if</span>(area&gt;maxarea)</span><br><span class="line">        		maxarea=area;</span><br><span class="line">        	<span class="keyword">if</span>(height[i]&lt;height[j])</span><br><span class="line">        		i++;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">        		j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hive QL 介绍]]></title>
      <url>http://codeinterviews.com/hive%20ql%E4%BB%8B%E7%BB%8D%20/</url>
      <content type="html"><![CDATA[<p>主要对hive ql进行介绍。<br><a id="more"></a></p>
<p>##二、本节目标</p>
<p>本次讲解 Hive QL 分为以下几个要点：</p>
<blockquote>
<p><strong>1. 数据定义操作 - DDL</strong></p>
<p><strong>2. 数据操作 - DML</strong></p>
<p><strong>3. Hive QL 查询操作</strong></p>
</blockquote>
<h2 id="三、数据定义操作-DDL"><a href="#三、数据定义操作-DDL" class="headerlink" title="三、数据定义操作 - DDL"></a>三、数据定义操作 - DDL</h2><p><strong>（1）建表（CREATE）的语法如下：</strong></p>
<pre><code>CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name 
  [(col_name data_type [COMMENT col_comment], ...)] 
  [COMMENT table_comment] 
  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] 
  [CLUSTERED BY (col_name, col_name, ...) 
  [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] 
  [ROW FORMAT row_format] 
  [STORED AS file_format] 
  [LOCATION hdfs_path]
</code></pre><p>上面的一些关键字解释：</p>
<ul>
<li><strong>CREATE TABLE</strong> 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXIST 选项来忽略这个异常</li>
<li><strong>EXTERNAL</strong> 关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION）</li>
<li><strong>LIKE</strong> 允许用户复制现有的表结构，但是不复制数据</li>
<li><strong>COMMENT</strong> 可以为表与字段增加描述</li>
<li><strong>ROW FORMAT</strong> <blockquote>
<p>DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char] [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, …)]</p>
<pre><code>用户在建表的时候可以自定义 SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用自带的 SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive 通过 SerDe 确定表的具体的列的数据。
</code></pre></blockquote>
</li>
<li><strong>STORED AS</strong><pre><code>     SEQUENCEFILE
     | TEXTFILE
     | RCFILE    
     | INPUTFORMAT input_format_classname OUTPUTFORMAT             output_format_classname
如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCE 。
</code></pre></li>
</ul>
<p><strong>（2）建表（CREATE）</strong></p>
<ul>
<li>创建普通表</li>
<li>创建外部表</li>
<li>创建分区表</li>
<li>创建 Bucket 表</li>
</ul>
<ul>
<li><p>创建普通表</p>
<pre><code>CREATE TABLE page_view(viewTime INT, userid BIGINT,
     page_url STRING, referrer_url STRING,
     ip STRING COMMENT &apos;IP Address of the User&apos;,
     country STRING COMMENT &apos;country of origination&apos;)
 COMMENT &apos;This is the staging page view table&apos;;
</code></pre></li>
</ul>
<ul>
<li>创建外部表：</li>
</ul>
<pre><code>CREATE EXTERNAL TABLE page_view(viewTime INT, userid BIGINT,
     page_url STRING, referrer_url STRING,
     ip STRING COMMENT &apos;IP Address of the User&apos;,
     country STRING COMMENT &apos;country of origination&apos;)
 COMMENT &apos;This is the staging page view table&apos;
 ROW FORMAT DELIMITED FIELDS TERMINATED BY &apos;\054&apos;
 STORED AS TEXTFILE
 LOCATION &apos;&lt;hdfs_location&gt;&apos;;
</code></pre><ul>
<li>创建分区表：</li>
</ul>
<pre><code>CREATE TABLE par_table(viewTime INT, userid BIGINT,
     page_url STRING, referrer_url STRING,
     ip STRING COMMENT &apos;IP Address of the User&apos;)
 COMMENT &apos;This is the page view table&apos;
 PARTITIONED BY(date STRING, pos STRING)
ROW FORMAT DELIMITED ‘\t’
   FIELDS TERMINATED BY &apos;\n&apos;
STORED AS SEQUENCEFILE;
</code></pre><ul>
<li><p>创建 Bucket 表：</p>
<pre><code>CREATE TABLE par_table(viewTime INT, userid BIGINT,
     page_url STRING, referrer_url STRING,
     ip STRING COMMENT &apos;IP Address of the User&apos;)
 COMMENT &apos;This is the page view table&apos;
 PARTITIONED BY(date STRING, pos STRING)
 CLUSTERED BY(userid) SORTED BY(viewTime) INTO 32 BUCKETS
 ROW FORMAT DELIMITED ‘\t’
   FIELDS TERMINATED BY &apos;\n&apos;
STORED AS SEQUENCEFILE;
</code></pre></li>
</ul>
<p><strong>（3）修改表结构</strong></p>
<ul>
<li>重命名表<ul>
<li>增加、删除分区</li>
<li>增加、更新列</li>
<li>修改列的名字、类型、位置、注释</li>
<li>增加表的元数据信息</li>
<li>…</li>
</ul>
</li>
</ul>
<ul>
<li>复制一个空表</li>
</ul>
<pre><code>CREATE TABLE empty_key_value_store
LIKE key_value_store;
</code></pre><ul>
<li>删除表</li>
</ul>
<pre><code>DROP TABLE table_name
</code></pre><ul>
<li>重命名表</li>
</ul>
<pre><code>ALTER TABLE table_name RENAME TO new_table_name 
</code></pre><ul>
<li>增加、删除分区</li>
</ul>
<pre><code>增加   
ALTER TABLE table_name ADD [IF NOT EXISTS] partition_spec [ LOCATION &apos;location1&apos; ] partition_spec [ LOCATION &apos;location2&apos; ] ...
partition_spec:
  : PARTITION (partition_col = partition_col_value, partition_col = partiton_col_value, ...)

删除   
ALTER TABLE table_name DROP
    partition_spec, partition_spec,...
</code></pre><ul>
<li>增加、更新列</li>
</ul>
<pre><code>ADD 是代表新增一字段，字段位置在所有列后面(partition列前)      
REPLACE 则是表示替换表中所有字段。      
ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...)
</code></pre><ul>
<li>修改列的名字、类型、位置、注释</li>
</ul>
<pre><code>这个命令可以允许改变列名、数据类型、注释、列位置或者它们的任意组合      
ALTER TABLE table_name CHANGE [COLUMN]
col_old_name col_new_name column_type
[COMMENT col_comment]
[FIRST|AFTER column_name]
</code></pre><ul>
<li>增加表的元数据信息</li>
</ul>
<pre><code>用户可以用这个命令向表中增加元数据信息 metadata      
ALTER TABLE table_name SET TBLPROPERTIES table_properties table_properties:
    : (property_name = property_value, ...)
</code></pre><ul>
<li>改变文件格式和组织</li>
</ul>
<pre><code>ALTER TABLE table_name SET FILEFORMAT file_format
ALTER TABLE table_name CLUSTERED BY(col_name, col_name, ...) 
    [SORTED BY(col_name, ...)] INTO num_buckets BUCKETS
</code></pre><ul>
<li>创建、删除视图</li>
</ul>
<pre><code># 创建视图
CREATE VIEW [IF NOT EXISTS] view_name [ (column_name [COMMENT column_comment], ...) ][COMMENT view_comment][TBLPROPERTIES (property_name = property_value, ...)]
AS SELECT ...

# 删除视图
DROP VIEW view_name
</code></pre><ul>
<li>创建、删除函数</li>
</ul>
<pre><code># 创建函数
CREATE TEMPORARY FUNCTION function_name AS class_name

# 删除函数
DROP TEMPORARY FUNCTION function_name
</code></pre><ul>
<li><p>展示/描述 语句</p>
<pre><code># 显示 表
show tables;

# 显示 数据库
show databases;

# 显示 分区
show partitions;

# 显示 函数
show functions;

# 描述 表/列
describe [EXTENDED] table_name[DOT col_name]
</code></pre></li>
</ul>
<h2 id="四、数据操作-DML"><a href="#四、数据操作-DML" class="headerlink" title="四、数据操作 - DML"></a>四、数据操作 - DML</h2><p>Hive 不支持使用 insert 语句一条一条的进行插入操作，也不支持 update 操作。数据是以 load 的方式加载到建立好的表中，数据一旦导入就不可以修改。</p>
<p><strong>（1）向数据表内加载文件</strong></p>
<pre><code>LOAD DATA [LOCAL] INPATH &apos;filepath&apos; [OVERWRITE]
    INTO TABLE tablename
    [PARTITION (partcol1=val1, partcol2=val2 ...)]
</code></pre><blockquote>
<ul>
<li><p><strong>Load</strong> </p>
<p>操作只是单纯的复制/移动操作，将数据文件移动到 Hive 表对应的位置。</p>
</li>
<li><p><strong>filepath</strong></p>
<ul>
<li>相对路径，例如：project/data1</li>
<li>绝对路径，例如： /user/hive/project/data1</li>
<li>包含模式的完整 URI，例如：hdfs://namenode:9000/user/hive/project/data1</li>
</ul>
</li>
<li><p><strong>LOCAL 关键字</strong></p>
<ul>
<li>指定了LOCAL<br>即本地 load 命令会去查找本地文件系统中的 filepath. 如果发现是相对路径，则路径会被解释为相对于当前用户的当前路径。用户也可以为本地文件指定一个完整的 URI，比如：file:///user/hive/project/data. 此时 load 命令会将 filepath 中的文件复制到目标文件系统中。目标文件系统由表的位置属性决定。被复制的数据文件移动到表的数据对应的位置。</li>
<li>没有指定LOCAL<br>如果 filepath 指向的是一个完整的 URI，hive 会直接使用这个 URI. 否则如果没有指定 schema 或者 authority，Hive 会使用在 hadoop 配置文件中定义的 schema 和 authority，fs.default.name 指定了 Namenode 的 URI. 如果路径不是绝对的，Hive 相对于 /user/ 进行解释。 Hive 会将 filepath 中指定的文件内容移动到 table （或者 partition）所指定的路径中。</li>
</ul>
</li>
<li><p><strong>OVERWRITE</strong></p>
<p>使用 OVERWRITE 关键字，目标表（或者分区）中的内容（如果有）会被删除，然后再将 filepath 指向的文件/目录中的内容添加到表/分区中。如果目标表（分区）已经有一个文件，并且文件名和 filepath 中的文件名冲突，那么现有的文件会被新文件所替代。</p>
</li>
</ul>
</blockquote>
<p>例如：</p>
<pre><code>hive&gt; LOAD DATA LOCAL INPATH &apos;./examples/files/kv1.txt&apos; OVERWRITE INTO TABLE pokes;
</code></pre><p><strong>（2）将查询结果插入Hive表</strong></p>
<pre><code>INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1 FROM from_statement
</code></pre><ul>
<li>多插入模式</li>
</ul>
<pre><code>FROM from_statement
INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1
[INSERT OVERWRITE TABLE tablename2 [PARTITION ...] select_statement2] ...
</code></pre><ul>
<li>自动分区模式</li>
</ul>
<pre><code>INSERT OVERWRITE TABLE tablename PARTITION (partcol1[=val1], partcol2[=val2] ...) select_statement FROM from_statement
</code></pre><p><strong>（3）将查询结果写入HDFS文件系统</strong></p>
<pre><code>INSERT OVERWRITE [LOCAL] DIRECTORY directory1 SELECT ... FROM ...
FROM from_statement
INSERT OVERWRITE [LOCAL] DIRECTORY directory1 select_statement1
[INSERT OVERWRITE [LOCAL] DIRECTORY directory2 select_statement2] ...
</code></pre><p>数据写入文件系统时会进行文本序列化，且每列用 <code>^A</code> 来区分，<code>\n</code> 换行。如果任何一列不是原始类型，那么这些将会被序列化为 JSON 格式。</p>
<h2 id="五、Hive-QL-查询操作"><a href="#五、Hive-QL-查询操作" class="headerlink" title="五、Hive QL 查询操作"></a>五、Hive QL 查询操作</h2><p><strong>SQL操作：</strong></p>
<blockquote>
<ul>
<li>基本的 Select 操作</li>
<li>基于 Partition 的查询</li>
<li>Join</li>
</ul>
</blockquote>
<p><strong>（1）基本的 Select 操作</strong></p>
<pre><code>SELECT [ALL | DISTINCT] select_expr, select_expr, ...
FROM table_reference
[WHERE where_condition]
[GROUP BY col_list]
[   CLUSTER BY col_list
  | [DISTRIBUTE BY col_list] [SORT BY| ORDER BY col_list]
]
[LIMIT number]
</code></pre><blockquote>
<p>使用 <strong>ALL</strong> 和 <strong>DISTINCT</strong> 选项区分对重复记录的处理。默认是 ALL，表示查询所有记录。DISTINCT 表示去掉重复的记录；</p>
<p><strong>Limit</strong> 可以限制查询输出的记录数；</p>
</blockquote>
<p><strong>（2）基于 Partition 的查询</strong></p>
<p>一般 SELECT 查询会扫描整个表，使用 PARTITIONED BY 子句建表，查询就可以利用分区剪枝（input pruning）的特性。</p>
<p>Hive 当前的分区剪枝，只有分区断言出现在离 FROM 子句最近的那个 WHERE 子句中，才会启用分区剪枝。</p>
<p>例如，一个表 page_view 按照 date 列的值进行了分区，那么下面的查询就可以检索出日期为 2010-03-01 的行记录：</p>
<pre><code>SELECT page_view
    FROM page_view
    WHERE page_view.date &gt;= &apos;2010-03-01&apos; ADN page_views.date &lt;= &apos;2010-03-31&apos;
</code></pre><p><strong>（3）Join</strong></p>
<p>Join 的语法如下：</p>
<pre><code>join_table:
    table_reference JOIN table_factor [join_condition]
  | table_reference {LEFT|RIGHT|FULL} [OUTER] JOIN table_reference join_condition
  | table_reference LEFT SEMI JOIN table_reference join_condition
  | table_reference CROSS JOIN table_reference [join_condition] (as of Hive 0.10)

table_reference:
    table_factor
  | join_table

table_factor:
    tbl_name [alias]
  | table_subquery alias
  | ( table_references )

join_condition:
    ON equality_expression ( AND equality_expression )*

equality_expression:
    expression = expression
</code></pre><blockquote>
<p>hive 只支持等连接（equality joins）、外连接（outer joins）、左半连接（left semi joins）。hive 不支持非相等的 join 条件，因为它很难在 map/reduce job 中实现这样的条件。而且，hive 可以 join 两个以上的表。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS6.5 安装git]]></title>
      <url>http://codeinterviews.com/install-git-in-CentOS6.5/</url>
      <content type="html"><![CDATA[<p>##引言<br>Git是目前世界上最先进的分布式版本控制系统，它能够对你的代码进行版本管理与控制，使你不再需要担心代码版本过多而造成发布时版本的混乱。</p>
<p>本文是在CentOS6.5上安装git，使得在linux上也可以使用git进行代码的版本控制。</p>
<a id="more"></a>
<p>##yum安装git<br>在CentOS6.5上不需要下载git源码进行编译，而直接只需要通过yum来下载安装git。<br>安装命令如下：</p>
<pre><code>$ yum install git
</code></pre><p>##查看git版本<br>为了查看git是否安装成功，我们可以打印出git的版本号以便查看。<br>打印命令如下：</p>
<pre><code>$ git --version
git version 1.7.1
</code></pre><p>##配置git<br>配置你的用户名和电子邮件：</p>
<pre><code>$ git config --global user.name &quot;your name&quot;
$ git config --global user.email &quot;your email&quot;
</code></pre><p>##拷贝远程库<br>可以拷贝你github上的库到本地进行修改。<br>拷贝命令如下：</p>
<pre><code>例如你需要拷贝用户名为：baidu下的example项目
$ git clone https://github.com/baidu/example
</code></pre><p>##提交本地库<br>当把远程库考到本地后进行修改后，需要提交到远程库中，此时需要提交命令。<br>提交命令如下：</p>
<pre><code>$ git add .
$ git commit -a -m &quot;your message&quot;
$ git push
</code></pre><hr>
<p><strong>提交错误</strong>处理：<br>git push 出错</p>
<pre><code>error: The requested URL returned error: 403 Forbidden while accessing         https://github.com/wangz/future.git/info/refs
</code></pre><p>解决方案:<br>修改.git下面的config文件</p>
<p>修改以下代码:</p>
<pre><code>[remote &quot;origin&quot;]
    url = https://github.com/wangz/example.git
</code></pre><p>为：</p>
<pre><code>[remote &quot;origin&quot;]
    url = https://wangz@github.com/wangz/example.git
</code></pre><p>再次git push，弹出框输入密码，即可提交</p>
<p>####git 原理图片一张：<br><img src="/img/CentOS/git.jpg" alt=""></p>
<p>##参考文献<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的git教程</a><br><a href="http://blog.csdn.net/harith/article/details/17691839" target="_blank" rel="external">CentOS 安装git</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在博客中插入虾米播放器]]></title>
      <url>http://codeinterviews.com/insert-xiami-to-blog/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在博客中插入虾米播放器简单的方法主要分为以下三步:<br><br>1.搜索要插入的音乐<br><br>2.获取音乐播放器的flash代码<br><br>3.插入到指定的html文件中<br></p>
</blockquote>
<a id="more"></a>
<p>##搜索插入的音乐<br>在搜索框中输入音乐名，得到如下的结果界面：<br><br><img src="/img/insert-xiami-to-blog/1.jpg" alt=""></p>
<p>##获取音乐播放器的代码<br>然后点击“转帖”得到分享界面:<br><br><img src="/img/insert-xiami-to-blog/2.jpg" alt=""></p>
<p>##插入到html文件中<br>点击复制html代码，将其直接插入到你的博客html代码中即可</p>
<p>非常简便易行,妈妈再也不用担心我不能分享音乐了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IntelliJ IDEA 常用快捷键]]></title>
      <url>http://codeinterviews.com/idea-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<p>该文主要对IntelliJ IDEA 常用快捷键进行概括。<br><a id="more"></a></p>
<p>##查询快捷键<br>    CTRL+N   查找类<br>    CTRL+SHIFT+N  查找文件<br>    CTRL+SHIFT+ALT+N 查找类中的方法或变量<br>    CIRL+B   找变量的来源<br>    CTRL+ALT+B  找所有的子类<br>    CTRL+SHIFT+B  找变量的类<br>    CTRL+G   定位行<br>    CTRL+F   在当前窗口查找文本<br>    CTRL+SHIFT+F  在指定窗口查找文本<br>    CTRL+R   在当前窗口替换文本<br>    CTRL+SHIFT+R  在指定窗口替换文本<br>    ALT+SHIFT+C  查找修改的文件<br>    CTRL+E   最近打开的文件<br>    F3   向下查找关键字出现位置<br>    SHIFT+F3  向上一个关键字出现位置<br>    F4   查找变量来源<br>    CTRL+ALT+F7  选中的字符查找工程出现的地方<br>    CTRL+SHIFT+O  弹出显示查找内容 </p>
<p>##SVN 管理<br>    把SVN库添加到IDEA中 SETTING -&gt;  VERSIONCONTROL -&gt; VCS = SVBVERSION<br>    把SVN 过滤目录或者文件类型那个 SETTING -&gt; VERSION CONTROL -&gt;  IgnoredFiles</p>
<p>##自动代码<br>    ALT+回车  导入包,自动修正<br>    CTRL+ALT+L  格式化代码<br>    CTRL+ALT+I  自动缩进<br>    CTRL+ALT+O  优化导入的类和包<br>    ALT+INSERT  生成代码(如GET,SET方法,构造函数等)<br>    CTRL+E或者ALT+SHIFT+C 最近更改的代码<br>    CTRL+SHIFT+SPACE 自动补全代码<br>    CTRL+空格  代码提示 (和系统输入法冲突，请在Settings-&gt;Keymap-&gt;mainmenu -&gt; code -&gt;Completion-&gt;basic，右键添加自己的快捷键)<br>    CTRL+ALT+SPACE  类名或接口名提示<br>    CTRL+P   方法参数提示<br>    CTRL+J   自动代码<br>    CTRL+ALT+T  把选中的代码放在 TRY{} IF{}ELSE{} 里 </p>
<p>##复制快捷方式<br>    F5   拷贝文件快捷方式<br>    CTRL+D   复制行<br>    CTRL+X   剪切,删除行<br>    CTRL+SHIFT+V  可以复制多个文本 </p>
<p>##高亮<br>    CTRL+F   选中的文字,高亮显示上下跳到下一个或者上一个<br>    F2 或SHIFT+F2  高亮错误或警告快速定位<br>    CTRL+SHIFT+F7  高亮显示多个关键字. </p>
<p>#其他快捷方式<br>    CIRL+U   大小写切换<br>    CTRL+Z   倒退<br>    CTRL+SHIFT+Z  向前<br>    CTRL+ALT+F12  资源管理器打开文件夹在WINDOW窗口快速定位到文件或者文件夹的位置<br>    ALT+F1   查找文件所在目录位置<br>    SHIFT+ALT+INSERT 竖编辑模式<br>    CTRL+/   注释//<br>    CTRL+SHIFT+/  注释<br>    CTRL+W   选中代码，连续按会有其他效果<br>    CTRL+B   快速打开光标处的类或方法<br>    ALT+ ←/→  切换代码视图<br>    CTRL+ALT ←/→  返回上次编辑的位置<br>    ALT+ ↑/↓  在方法间快速移动定位<br>    SHIFT+F6  重构-重命名<br>    CTRL+H   显示类结构图<br>    CTRL+Q   显示注释文档<br>    ALT+1   快速打开或隐藏工程面板<br>    CTRL+SHIFT+UP/DOWN 代码向上/下移动。<br>    CTRL+UP/DOWN  光标跳转到第一行或最后一行下<br>    ESC   光标返回编辑框<br>    SHIFT+ESC  光标返回编辑框,关闭无用的窗口<br>    F1   帮助 (不建议使用，很慢)<br>    CTRL+F4   关闭当前打开文件</p>
<p>##总结<br>    从eclipse切换过来的Developer们，可以设置成eclipse的快捷键模式 (只需要把keymaps选择成eclipse模式即可)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hive 安装配置]]></title>
      <url>http://codeinterviews.com/hive%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>主要对Hive 安装配置进行介绍。<br><a id="more"></a></p>
<h2 id="二、Hive-运行模式"><a href="#二、Hive-运行模式" class="headerlink" title="二、Hive 运行模式"></a>二、Hive 运行模式</h2><p>与 Hadoop 类似，Hive 也有 3 种运行模式：</p>
<blockquote>
<p><strong>1. 内嵌模式</strong></p>
<p>将元数据保存在本地内嵌的 Derby 数据库中，这是使用 Hive 最简单的方式。但是这种方式缺点也比较明显，因为一个内嵌的 Derby 数据库每次只能访问一个数据文件，这也就意味着它不支持多会话连接。</p>
<p><strong>2. 本地模式</strong></p>
<p>这种模式是将元数据保存在本地独立的数据库中（一般是 MySQL），这用就可以支持多会话和多用户连接了。</p>
<p><strong>3. 远程模式</strong></p>
<p>此模式应用于 Hive 客户端较多的情况。把 MySQL 数据库独立出来，将元数据保存在远端独立的 MySQL 服务中，避免了在每个客户端都安装 MySQL 服务从而造成冗余浪费的情况。</p>
</blockquote>
<h2 id="三、下载安装-Hive"><a href="#三、下载安装-Hive" class="headerlink" title="三、下载安装 Hive"></a>三、下载安装 Hive</h2><p>上节课程我们已经了解到，Hive 是基于 Hadoop 文件系统之上的数据仓库。因此，安装Hive之前必须确保 Hadoop 已经成功安装。（本次实验环境，已经为大家安装好了 Hadoop.）</p>
<p>本次实验，使用Hive V1.1.0版本。Hive V1.1.0 可以在 Hadoop V1.0.0 以上环境中工作。终端下输入命令来下载：</p>
<pre><code>$ wget http://labfile.oss.aliyuncs.com/apache-hive-1.1.0-bin.tar.gz
</code></pre><p>下载完成后解压：</p>
<pre><code>$ tar zxvf apache-hive-1.1.0-bin.tar.gz
</code></pre><p>解压出来的文件名很长，在终端下输入很麻烦，为了后面实验的方便，建议修改为较短文件名，例如：</p>
<pre><code>$ mv apache-hive-1.1.0-bin hive
</code></pre><h2 id="四、配置系统环境变量"><a href="#四、配置系统环境变量" class="headerlink" title="四、配置系统环境变量"></a>四、配置系统环境变量</h2><p>修改 /etc/profile 文件，这个我们在 Hadoop 和 <a href="http://www.shiyanlou.com/courses/37" target="_blank" rel="external">HBase 的课程</a> 中也修改过，应该比较熟悉了。在 PATH 中加入 Hive 的 bin 以及 conf 路径（请根据自己的实际路径修改），使用 <code>sudo vim /etc/profile</code> 来修改：</p>
<pre><code># Hive environment
export HIVE_HOME=/usr/local/hadoop/hive
export PATH=$HIVE_HOME/bin:$HIVE_HOME/conf:$PATH
</code></pre><h2 id="五、内嵌模式"><a href="#五、内嵌模式" class="headerlink" title="五、内嵌模式"></a>五、内嵌模式</h2><p><strong>（1）修改 Hive 配置文件</strong></p>
<p>$HIVE_HOME/conf 对应的是 Hive 的配置文件路径，类似于之前学习的HBase, 该路径下的 hive-site.xml 是 Hive 工程的配置文件。默认情况下，该文件并不存在，我们需要拷贝它的模版来实现：</p>
<pre><code>$ cp hive-default.xml.template hive-site.xml
</code></pre><p>hive-site.xml 的主要配置有：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427423801808" alt="图片描述信息"></p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427423813828" alt="图片描述信息"></p>
<blockquote>
<ul>
<li><p><strong>hive.metastore.warehouse.dir</strong><br>该参数指定了 Hive 的数据存储目录，默认位置在 HDFS 上面的 /user/hive/warehouse 路径下。</p>
</li>
<li><p><strong>hive.exec.scratchdir</strong><br>该参数指定了 Hive 的数据临时文件目录，默认位置为 HDFS 上面的 /tmp/hive 路径下。</p>
</li>
</ul>
</blockquote>
<p>同时我们还要修改 Hive 目录下 /conf/hive-env.sh 文件（请根据自己的实际路径修改），该文件默认也不存在，同样是拷贝它的模版来修改：</p>
<pre><code>export HADOOP_HEAPSIZE=1024

# Set HADOOP_HOME to point to a specific hadoop install directory
HADOOP_HOME=/usr/local/hadoop

# Hive Configuration Directory can be controlled by:
export HIVE_CONF_DIR=/usr/local/hadoop/hive/conf

# Folder containing extra ibraries required for hive compilation/execution can be controlled by:
export HIVE_AUX_JARS_PATH=/usr/local/hadoop/hive/lib
</code></pre><p><strong>（2）创建必要目录</strong></p>
<p>前面我们看到 hive-site.xml 文件中有两个重要的路径，切换到 hadoop 用户下查看 HDFS 是否有这些路径：</p>
<pre><code>$ hadoop dfs -ls /
</code></pre><p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427424044890" alt="图片描述信息"></p>
<p>没有发现上面提到的路径，因此我们需要自己新建这些目录，并且给它们赋予用户写（W）权限。</p>
<pre><code>$ hadoop dfs -mkdir /user/hive/warehouse
$ hadoop dfs -mkdir /tmp/hive
$ hadoop dfs -chmod 777 /user/hive/warehouse
$ hadoop dfs -chmod 777 /tmp/hive
</code></pre><p>如果你遇到  <code>no such file or directory</code> 类似的错误，就一步一步新建目录，例如：</p>
<pre><code>$ hadoop dfs -mkdir /tmp
$ hadoop dfs -mkdir /tmp/hive
</code></pre><p>检查是否新建成功 <code>hadoop dfs -ls /</code> 以及 <code>hadoop dfs -ls /user/hive/</code> ：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427424512161" alt="图片描述信息"></p>
<p><strong>（3）修改 io.tmpdir 路径</strong></p>
<p>同时，要修改 hive-site.xml 中所有包含 <code>${system:java.io.tmpdir}</code> 字段的 value 即路径（vim下 / 表示搜索，后面跟你的关键词，比如搜索 hello，则为 <code>/hello</code> , 再回车即可），你可以自己新建一个目录来替换它，例如 <code>/home/hive/iotmp</code> . 同样注意修改写权限。如果不修改这个，你很可能会出现如下错误：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427424529728" alt="图片描述信息"></p>
<p><strong>（4）运行 Hive</strong></p>
<p>前面我们已经提到过，内嵌模式使用默认配置和 Derby 数据库，所以无需其它特别修改，先 <code>./start-all.sh</code> 启动 Hadoop,  然后直接运行 <code>hive</code>：</p>
<p><strong>你很可能会遇到这个错误：</strong></p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427424670386" alt="图片描述信息"></p>
<p>这是因为 Hive 中的 Jline jar 包和 Hadoop 中的 Jline 冲突了，在路径：$HADOOP_HOME/share/hadoop/yarn/lib/jline-0.9.94.jar 将其删除。</p>
<p>再次启动 <code>hive</code>，就OK了:</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427424712845" alt="图片描述信息"></p>
<p><code>show tables;</code> 注意不要漏写了 <strong>分号</strong>。</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427424740729" alt="图片描述信息"></p>
<h2 id="六、本地模式"><a href="#六、本地模式" class="headerlink" title="六、本地模式"></a>六、本地模式</h2><p>现在我们替换默认的 Derby 数据库为 MySQL数据库。</p>
<p><strong>（1）下载安装 MySQL</strong></p>
<pre><code>$ sudo apt-get install mysql-server
</code></pre><p>本实验环境下默认是安装了 MySQL 的，直接启动它：</p>
<pre><code>$ sudo service mysql start
</code></pre><p>添加 root 用户，创建 hive 数据库：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427425205044" alt="图片描述信息"></p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427425375983" alt="图片描述信息"></p>
<p>虽然 MySQL 已经默认安装，但我们还需要下载一个 MySQL 的 JDBC 驱动包。这里使用的是 <code>mysql-connector-java-5.1.35-bin.jar</code>，你需要将其复制到  $HIVE_HOME/lib 目录下面：</p>
<pre><code>$ wget http://labfile.oss.aliyuncs.com/mysql-connector-java-5.1.35.tar.gz

$ tar zxvf mysql-connector-java-5.1.35.tar.gz

$ cd mysql-connector-java-5.1.35

$ mv mysql-connector-java-5.1.35-bin.jar /usr/local/hadoop/hive/lib/
</code></pre><p><strong>（2）修改 hive-site.xml 配置文件</strong></p>
<p>最后，依然是修改 $HIVE_HOME/conf 下的 hive-site.xml 文件，把默认的 Derby 修改为 MySQL : </p>
<pre><code>&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;
    //所连接的MySQL数据库实例
    &lt;value&gt;jdbc:mysql://localhost:3306/hive&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;
    //连接的MySQL数据库驱动
    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;
    //连接的MySQL数据库用户名
    &lt;value&gt;hive&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
    &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;
    //连接的MySQL数据库密码
    &lt;value&gt;hive&lt;/value&gt;
&lt;/property&gt;
</code></pre><p><strong>（3）启动 Hive</strong></p>
<p>启动 Hive 的方式同内嵌模式一样：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid766time1427425424217" alt="图片描述信息"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hive 简介]]></title>
      <url>http://codeinterviews.com/hive%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>主要介绍 Hive 的相关知识，将会涉及以下内容：</p>
<ul>
<li>Hive 的定义  </li>
<li>Hive 的体系结构   </li>
<li>Hive 与关系数据库的区别   </li>
<li>Hive 的应用场景  </li>
<li>Hive 的存储      <a id="more"></a>
</li>
</ul>
<p>##一、什么是 Hive ?</p>
<p>Hive 是一个基于 Hadoop 文件系统之上的数据仓库架构。它为数据仓库的管理提供了许多功能：数据 ETL （抽取、转换和加载）工具、数据存储管理和大型数据集的查询和分析能力。同时 Hive 还定义了类 SQL的语言 – Hive QL. Hive QL 允许用户进行和 SQL 相似的操作，它可以将结构化的数据文件映射为一张数据库表，并提供简单的 SQL 查询功能。还允许开发人员方便地使用 Mapper 和 Reducer 操作，可以将 SQL 语句转换为 MapReduce 任务运行，这对 MapReduce 框架来说是一个强有力的支持。 </p>
<p>##二、Hive 体系结构</p>
<p>Hive 是 Hadoop 中的一个重要子项目，从下图我们就可以大致了解 Hive 在 Hadoop 中的位置和关系。</p>
<p><img src="https://dn-anything-about-doc.qbox.me/hbase/1.jpg" alt="Alt text"></p>
<p>上图描述 Hadoop EcoSystem 中的各层系统。而 Hive 本身的体系结构如下：</p>
<p><img src="https://dn-anything-about-doc.qbox.me/userid46108labid759time1427342632496" alt="图片描述信息"></p>
<p>从图中我们可以看出 Hive 其基本组成可以分为：</p>
<ul>
<li>用户接口，包括 CLI, JDBC/ODBC, WebUI    </li>
<li><strong>元数据存储，通常是存储在关系数据库如 MySQL, Derby 中</strong>      </li>
<li>解释器、编译器、优化器、执行器     </li>
<li>Hadoop, 用 HDFS 进行存储，利用 MapReduce 进行计算     </li>
</ul>
<p>##三、Hive 与关系数据库的区别</p>
<p>Hive 在很多方面与传统关系数据库类似（例如支持 SQL 接口），但是其底层对 HDFS 和 MapReduce 的依赖意味着它的体系结构有别于传统关系数据库，而这些区别又影响着 Hive 所支持的特性，进而影响着 Hive 的使用。</p>
<p>我们可以列举一些简单区别：</p>
<ul>
<li>Hive 和关系数据库存储文件的系统不同，Hive 使用的是 Hadoop 的HDFS（Hadoop的分布式文件系统），关系数据库则是服务器本地的文件系统；         </li>
<li>Hive 使用的计算模型是 MapReduce，而关系数据库则是自己设计的计算模型；       </li>
<li>关系数据库都是为实时查询的业务进行设计的，而 Hive 则是为海量数据做数据挖掘设计的，实时性很差；实时性的区别导致 Hive 的应用场景和关系数据库有很大的不同；         </li>
<li>Hive 很容易扩展自己的存储能力和计算能力，这个是继承 Hadoop 的，而关系数据库在这个方面要差很多。             </li>
</ul>
<p>##四、Hive 应用场景</p>
<p>通过对 Hive 与传统关系数据库的比较之后，其实我们不难得出 Hive 可以应用于哪些场景。</p>
<p>Hive 构建在基于静态批处理的 Hadoop 之上，Hadoop 通常都有较高的延迟并且在作业提交和调度的时候需要大量的开销。因此，Hive 不适合在大规模数据集上实现低延迟快速的查询。</p>
<p>Hive 并不适合那些需要低延迟的应用，例如，联机事务处理（OLTP）。Hive 查询操作过程严格遵守 Hadoop MapReduce 的作业执行模型，Hive 将用户的 HiveQL 语句通过解释器转换为 MapReduce 作业提交到 Hadoop 集群上，Hadoop 监控作业执行过程，然后返回作业执行结果给用户。Hive 并非为联机事务处理而设计，Hive 并不提供实时的查询和基于行级的数据更新操作。</p>
<p>Hive 的最佳使用场合是大数据集的批处理作业，例如，网络日志分析。</p>
<p>##五、Hive 的数据存储</p>
<p>Hive 的存储是建立在 Hadoop 文件系统之上的。Hive 本身没有专门的数据存储格式，也不能为数据建立索引，因此用户可以非常自由地组织 Hive 中的表，只需要在创建表的时候告诉 Hive 数据中的列分隔符就可以解析数据了。</p>
<p>Hive 中主要包括 4 种数据模型：<code>表（Table）</code>、<code>外部表（External Table）</code>、<code>分区（Partition）</code>以及 <code>桶（Bucket）</code>。</p>
<p>Hive 的表和数据库中的表在概念上没有什么本质区别，在 Hive 中每个表都有一个对应的存储目录。而外部表指向已经在 HDFS 中存在的数据，也可以创建分区。Hive 中的每个分区都对应数据库中相应分区列的一个索引，但是其对分区的组织方式和传统关系数据库不同。桶在指定列进行 Hash 计算时，会根据哈希值切分数据，使每个桶对应一个文件。</p>
<p>##六、Hive 的元数据存储</p>
<p>由于 Hive 的元数据可能要面临不断地更新、修改和读取操作，所以它显然不适合使用 Hadoop 文件系统进行存储。目前 Hive 把元数据存储在 RDBMS 中，比如存储在 MySQL, Derby 中。这点我们在上面介绍的 Hive 的体系结构图中，也可以看出。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop介绍]]></title>
      <url>http://codeinterviews.com/hadoop%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>###1. Hadoop是什么？<br>Apache Hadoop是一款支持数据密集型分布式应用并以Apache 2.0许可协议发布的开源软件框架。它支持在商品硬件构建的大型集群上运行的应用程序。Hadoop是根据Google公司发表的MapReduce和Google档案系统的论文自行实作而成。</p>
<p>Hadoop框架透明地为应用提供可靠性和数据移动。它实现了名为MapReduce的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和PB级的数据。现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等。</p>
<p>Hadoop的框架最核心的设计就是：HDFS和MapReduce.HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。</p>
<a id="more"></a>
<p>###2. Hadoop历史</p>
<p>Hadoop由 Apache Software Foundation 公司于 2005 年秋天作为Lucene的子项目Nutch的一部分正式引入。它受到最先由 Google Lab 开发的 Map/Reduce 和 Google File System(GFS) 的启发。</p>
<p>2006 年 3 月份，Map/Reduce 和 Nutch Distributed File System (NDFS) 分别被纳入称为 Hadoop 的项目中。</p>
<p>Hadoop 是最受欢迎的在 Internet 上对搜索关键字进行内容分类的工具，但它也可以解决许多要求极大伸缩性的问题。例如，如果您要 grep 一个 10TB 的巨型文件，会出现什么情况？在传统的系统上，这将需要很长的时间。但是 Hadoop 在设计时就考虑到这些问题，采用并行执行机制，因此能大大提高效率。</p>
<p>目前有很多公司开始提供基于Hadoop的商业软件、支持、服务以及培训。Cloudera是一家美国的企业软件公司，该公司在2008年开始提供基于Hadoop的软件和服务。GoGrid是一家云计算基础设施公司，在2012年，该公司与Cloudera合作加速了企业采纳基于Hadoop应用的步伐。Dataguise公司是一家数据安全公司，同样在2012年该公司推出了一款针对Hadoop的数据保护和风险评估。</p>
<p>###3. Hadoop相关项目</p>
<ul>
<li>Hadoop Common：在0.20及以前的版本中，包含HDFS、MapReduce和其他项目公共内容，从0.21开始HDFS和MapReduce被分离为独立的子项目，其余内容为Hadoop Common</li>
<li>HDFS：Hadoop分布式文件系统（Distributed File System）－HDFS（Hadoop Distributed File System）</li>
<li>MapReduce：并行计算框架，0.20前使用org.apache.hadoop.mapred旧接口，0.20版本开始引入org.apache.hadoop.mapreduce的新API</li>
<li>Apache HBase：分布式NoSQL列数据库，类似谷歌公司BigTable。</li>
<li>Apache Hive：构建于hadoop之上的数据仓库，通过一种类SQL语言HiveQL为用户提供数据的归纳、查询和分析等功能。Hive最初由Facebook贡献。</li>
<li>Apache Mahout：机器学习算法软件包。</li>
<li>Apache Sqoop：结构化数据（如关系数据库）与Apache Hadoop之间的数据转换工具。</li>
<li>Apache ZooKeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。</li>
<li>Apache Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。</li>
</ul>
<p>###4. Hadoop优点</p>
<ul>
<li>高可靠性。Hadoop按位存储和处理数据的能力值得人们信赖。</li>
<li>高扩展性。Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。</li>
<li>高效性。Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。</li>
<li>高容错性。Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。</li>
<li>低成本。与一体机、商用数据仓库以及QlikView、Yonghong Z-Suite等数据集市相比，hadoop是开源的，项目的软件成本因此会大大降低。</li>
</ul>
<p>Hadoop带有用Java语言编写的框架，因此运行在 Linux 生产平台上是非常理想的。Hadoop 上的应用程序也可以使用其他语言编写，比如 C++。</p>
<p>###5. Hadoop应用场景</p>
<p>美国着名科技博客GigaOM的专栏作家Derrick Harris在一篇文章中总结了10个Hadoop的应用场景：</p>
<ul>
<li>在线旅游：全球80%的在线旅游网站都是在使用Cloudera公司提供的Hadoop发行版，其中SearchBI网站曾经报道过的Expedia也在其中。</li>
<li>移动数据：Cloudera运营总监称，美国有70%的智能手机数据服务背后都是由Hadoop来支撑的，也就是说，包括数据的存储以及无线运营商的数据处理等，都是在利用Hadoop技术。</li>
<li>电子商务：这一场景应该是非常确定的，eBay就是最大的实践者之一。国内的电商在Hadoop技术上也是储备颇为雄厚的。</li>
<li>能源开采：美国Chevron公司是全美第二大石油公司，他们的IT部门主管介绍了Chevron使用Hadoop的经验，他们利用Hadoop进行数据的收集和处理，其中这些数据是海洋的地震数据，以便于他们找到油矿的位置。</li>
<li>节能：另外一家能源服务商Opower也在使用Hadoop,为消费者提供节约电费的服务，其中对用户电费单进行了预测分析。</li>
<li>基础架构管理：这是一个非常基础的应用场景，用户可以用Hadoop从服务器、交换机以及其他的设备中收集并分析数据。</li>
<li>图像处理：创业公司Skybox Imaging 使用Hadoop来存储并处理图片数据，从卫星中拍摄的高清图像中探测地理变化。</li>
<li>诈骗检测：这个场景用户接触的比较少，一般金融服务或者政府机构会用到。利用Hadoop来存储所有的客户交易数据，包括一些非结构化的数据，能够帮助机构发现客户的异常活动，预防欺诈行为。</li>
<li>IT安全：除企业IT基础机构的管理之外，Hadoop还可以用来处理机器生成数据以便甄别来自恶意软件或者网络中的攻击。</li>
<li>医疗保健：医疗行业也会用到Hadoop,像IBM的Watson就会使用Hadoop集群作为其服务的基础，包括语义分析等高级分析技术等。医疗机构可以利用语义分析为患者提供医护人员，并协助医生更好地为患者进行诊断。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop2.6.0伪分布模式配置部署]]></title>
      <url>http://codeinterviews.com/hadoop2.6.0%E4%BC%AA%E5%88%86%E5%B8%83%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h2 id="二、Hadoop伪分布式模式配置"><a href="#二、Hadoop伪分布式模式配置" class="headerlink" title="二、Hadoop伪分布式模式配置"></a>二、Hadoop伪分布式模式配置</h2><h3 id="1-配置core-site-xml-hdfs-site-xml，mapred-site-xml及yarn-site-xml"><a href="#1-配置core-site-xml-hdfs-site-xml，mapred-site-xml及yarn-site-xml" class="headerlink" title="1. 配置core-site.xml, hdfs-site.xml，mapred-site.xml及yarn-site.xml"></a>1. 配置core-site.xml, hdfs-site.xml，mapred-site.xml及yarn-site.xml</h3><h4 id="1-修改core-site-xml"><a href="#1-修改core-site-xml" class="headerlink" title="1).修改core-site.xml:"></a>1).修改<code>core-site.xml</code>:</h4><pre><code>$ sudo gvim /usr/local/hadoop/etc/hadoop/core-site.xml
</code></pre><p>&gt;</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;

&lt;!-- Put site-specific property overrides in this file. --&gt;

&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.default.name&lt;/name&gt;
        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;/home/hadoop/tmp&lt;/value&gt;
   &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><a id="more"></a>
<p>常用配置项说明：</p>
<ul>
<li><code>fs.default.name</code>这是一个描述集群中NameNode结点的URI(包括协议、主机名称、端口号)，集群里面的每一台机器都需要知道NameNode的地址。DataNode结点会先在NameNode上注册，这样它们的数据才可以被使用。独立的客户端程序通过这个URI跟DataNode交互，以取得文件的块列表。</li>
<li><code>hadoop.tmp.dir</code> 是hadoop文件系统依赖的基础配置，很多路径都依赖它。如果hdfs-site.xml中不配置namenode和datanode的存放位置，默认就放在<code>/tmp/hadoop-${user.name}</code>这个路径中</li>
</ul>
<p>更多说明请参考<a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/core-default.xml" target="_blank" rel="external">core-default.xml</a>，包含配置文件所有配置项的说明和默认值。</p>
<h4 id="2-修改hdfs-site-xml"><a href="#2-修改hdfs-site-xml" class="headerlink" title="2).修改hdfs-site.xml:"></a>2).修改<code>hdfs-site.xml</code>:</h4><pre><code>$ sudo gvim /usr/local/hadoop/etc/hadoop/hdfs-site.xml
</code></pre><p>&gt;</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;

&lt;!-- Put site-specific property overrides in this file. --&gt;

&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>常用配置项说明：</p>
<ul>
<li><code>dfs.replication</code>它决定着系统里面的文件块的数据备份个数。对于一个实际的应用，它应该被设为3（这个数字并没有上限，但更多的备份可能并没有作用，而且会占用更多的空间）。少于三个的备份，可能会影响到数据的可靠性(系统故障时，也许会造成数据丢失)</li>
<li><code>dfs.data.dir</code>这是DataNode结点被指定要存储数据的本地文件系统路径。DataNode结点上的这个路径没有必要完全相同，因为每台机器的环境很可能是不一样的。但如果每台机器上的这个路径都是统一配置的话，会使工作变得简单一些。默认的情况下，它的值为<code>file://${hadoop.tmp.dir}/dfs/data</code>这个路径只能用于测试的目的，因为它很可能会丢失掉一些数据。所以这个值最好还是被覆盖。</li>
<li><code>dfs.name.dir</code>这是NameNode结点存储hadoop文件系统信息的本地系统路径。这个值只对NameNode有效，DataNode并不需要使用到它。上面对于/temp类型的警告，同样也适用于这里。在实际应用中，它最好被覆盖掉。</li>
</ul>
<p>更多说明请参考<a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="external">hdfs-default.xml</a>，包含配置文件所有配置项的说明和默认值。</p>
<h4 id="3-修改mapred-site-xml"><a href="#3-修改mapred-site-xml" class="headerlink" title="3).修改mapred-site.xml:"></a>3).修改<code>mapred-site.xml</code>:</h4><pre><code>$ sudo cp /usr/local/hadoop/etc/hadoop/mapred-site.xml.template /usr/local/hadoop/etc/hadoop/mapred-site.xml
$ sudo gvim /usr/local/hadoop/etc/hadoop/mapred-site.xml
</code></pre><p>&gt;</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;

&lt;!-- Put site-specific property overrides in this file. --&gt;

&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
        &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>常用配置项说明：</p>
<ul>
<li><code>mapred.job.tracker</code>JobTracker的主机（或者IP）和端口。</li>
</ul>
<p>更多说明请参考<a href="hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml">mapred-default.xml</a>，包含配置文件所有配置项的说明和默认值</p>
<h4 id="4-修改yarn-site-xml"><a href="#4-修改yarn-site-xml" class="headerlink" title="4).修改yarn-site.xml:"></a>4).修改<code>yarn-site.xml</code>:</h4><pre><code>&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;
        &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre><p>常用配置项说明：</p>
<ul>
<li><code>yarn.nodemanager.aux-services</code>通过该配置，用户可以自定义一些服务</li>
</ul>
<p>更多说明请参考<a href="http://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-common/yarn-default.xml" target="_blank" rel="external">yarn-default.xml</a>，包含配置文件所有配置项的说明和默认值</p>
<p>这样简单的伪分布式模式就配置好了</p>
<h2 id="三、格式化HDFS文件系统"><a href="#三、格式化HDFS文件系统" class="headerlink" title="三、格式化HDFS文件系统"></a>三、格式化HDFS文件系统</h2><p>在使用hadoop前，必须格式化一个全新的HDFS安装，通过创建存储目录和NameNode持久化数据结构的初始版本，格式化过程创建了一个空的文件系统。由于NameNode管理文件系统的元数据，而DataNode可以动态的加入或离开集群，因此这个格式化过程并不涉及DataNode。同理，用户也无需关注文件系统的规模。集群中DataNode的数量决定着文件系统的规模。DataNode可以在文件系统格式化之后的很长一段时间内按需增加。</p>
<h3 id="1-先切换到hadoop账户，按照提示输入账户密码"><a href="#1-先切换到hadoop账户，按照提示输入账户密码" class="headerlink" title="1.先切换到hadoop账户，按照提示输入账户密码"></a>1.先切换到hadoop账户，按照提示输入账户密码</h3><pre><code>$ su hadoop
</code></pre><h3 id="2-格式化HDFS文件系统"><a href="#2-格式化HDFS文件系统" class="headerlink" title="2.格式化HDFS文件系统"></a>2.格式化HDFS文件系统</h3><pre><code>$ hadoop namenode -format
</code></pre><p>会输出如下信息，则表格式化HDFS成功：</p>
<pre><code>DEPRECATED: Use of this script to execute hdfs command is deprecated.
Instead use the hdfs command for it.

INFO namenode.NameNode: STARTUP_MSG:
/************************************************************
STARTUP_MSG: Starting NameNode
STARTUP_MSG:   host = [你的主机名]/127.0.0.1
STARTUP_MSG:   args = [-format]
STARTUP_MSG:   version = 2.4.1
...
...
INFO util.ExitUtil: Exiting with status 0
INFO namenode.NameNode: SHUTDOWN_MSG:
/************************************************************
SHUTDOWN_MSG: Shutting down NameNode at [你的主机名]/127.0.0.1
************************************************************/
</code></pre><h2 id="四、Hadoop集群启动"><a href="#四、Hadoop集群启动" class="headerlink" title="四、Hadoop集群启动"></a>四、Hadoop集群启动</h2><h3 id="1-启动hdfs守护进程，分别启动NameNode和DataNode"><a href="#1-启动hdfs守护进程，分别启动NameNode和DataNode" class="headerlink" title="1.启动hdfs守护进程，分别启动NameNode和DataNode"></a>1.启动hdfs守护进程，分别启动NameNode和DataNode</h3><pre><code>$ hadoop-daemon.sh start namenode    
$ hadoop-daemon.sh start datanode
</code></pre><p>或者一次启动</p>
<pre><code>$ start-dfs.sh
</code></pre><p>输出如下（可以看出分别启动了namenode, datanode, secondarynamenode，因为我们没有配置secondarynamenode，所以地址为0.0.0.0）：</p>
<pre><code>Starting namenodes on []
hadoop@localhost&amp;#39;s password:
localhost: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-namenode-G470.out
hadoop@localhost&amp;#39;s password:
localhost: starting datanode, logging to /usr/local/hadoop/logs/hadoop-hadoop-datanode-G470.out
localhost: OpenJDK 64-Bit Server VM warning: You have loaded library /usr/local/hadoop/lib/native/libhadoop.so.1.0.0 which might have disabled stack guard. The VM will try to fix the stack guard now.
localhost: It&amp;#39;s highly recommended that you fix the library with &amp;#39;execstack -c &amp;lt;libfile&amp;gt;&amp;#39;, or link it with &amp;#39;-z noexecstack&amp;#39;.
Starting secondary namenodes [0.0.0.0]
hadoop@0.0.0.0&amp;#39;s password:
0.0.0.0: starting secondarynamenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-secondarynamenode-G470.out
</code></pre><h3 id="2-启动yarn-使用如下命令启ResourceManager和NodeManager"><a href="#2-启动yarn-使用如下命令启ResourceManager和NodeManager" class="headerlink" title="2.启动yarn,使用如下命令启ResourceManager和NodeManager:"></a>2.启动yarn,使用如下命令启ResourceManager和NodeManager:</h3><pre><code>$ yarn-daemon.sh start resourcemanager
$ yarn-daemon.sh start nodemanager
</code></pre><p>或者一次启动：</p>
<pre><code>$ start-yarn.sh
</code></pre><h3 id="3-检查是否运行成功"><a href="#3-检查是否运行成功" class="headerlink" title="3.检查是否运行成功"></a>3.检查是否运行成功</h3><p>打开浏览器</p>
<ul>
<li>输入：<code>http://localhost:8088</code>进入ResourceManager管理页面</li>
<li>输入：<code>http://localhost:50070</code>进入HDFS页面</li>
</ul>
<h2 id="六、测试验证"><a href="#六、测试验证" class="headerlink" title="六、测试验证"></a>六、测试验证</h2><p>测试验证还是使用上一节的WordCount</p>
<h3 id="1-创建输入的数据，采用-etc-protocols文件作为测试"><a href="#1-创建输入的数据，采用-etc-protocols文件作为测试" class="headerlink" title="1.创建输入的数据，采用/etc/protocols文件作为测试"></a>1.创建输入的数据，采用/etc/protocols文件作为测试</h3><pre><code>$ cd /usr/local/hadoop
$ mkdir input
$ cp /etc/protocols ./input
</code></pre><h3 id="2-执行Hadoop-WordCount应用（词频统计）"><a href="#2-执行Hadoop-WordCount应用（词频统计）" class="headerlink" title="2.执行Hadoop WordCount应用（词频统计）"></a>2.执行Hadoop WordCount应用（词频统计）</h3><pre><code># 如果存在上一次测试生成的output，由于hadoop的安全机制，直接运行可能会报错，所以请手动删除上一次生成的output文件夹
$ hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.4.1-sources.jar org.apache.hadoop.examples.WordCount input output
</code></pre><h3 id="3-查看生成的单词统计数据"><a href="#3-查看生成的单词统计数据" class="headerlink" title="3.查看生成的单词统计数据"></a>3.查看生成的单词统计数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat output/*</span><br></pre></td></tr></table></figure>
<h2 id="七、关闭服务"><a href="#七、关闭服务" class="headerlink" title="七、关闭服务"></a>七、关闭服务</h2><p>输入命令</p>
<pre><code>$ hadoop-daemon.sh stop namenode
$ hadoop-daemon.sh stop datanode
$ yarn-daemon.sh stop resourcemanager
$ yarn-daemon.sh stop nodemanager
</code></pre><p>或者</p>
<pre><code>$ stop-dfs.sh
$ stop-yarn.sh
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop2.6.0单机版模式安装]]></title>
      <url>http://codeinterviews.com/hadoop2.6.0%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>##一、Hadoop启动模式</p>
<p>Hadoop集群有三种启动模式：</p>
<ul>
<li>单机模式：默认情况下运行为一个单独机器上的独立Java进程，主要用于调试环境</li>
<li>伪分布模式：在单个机器上模拟成分布式多节点环境，每一个Hadoop守护进程都作为一个独立的Java进程运行</li>
<li>完全分布式模式：真实的生产环境，搭建在完全分布式的集群环境</li>
</ul>
<a id="more"></a>
<p>##二、用户及用户组</p>
<p>需要先添加用来运行Hadoop进程的用户组hadoop及用户hadoop。</p>
<p>###1. 添加用户及用户组</p>
<p>创建用户hadoop</p>
<pre><code>$ sudo adduser hadoop
</code></pre><p>并按照提示输入hadoop用户的密码。</p>
<p>###2. 添加sudo权限</p>
<p>将hadoop用户添加进sudo用户组</p>
<pre><code>$ sudo usermod -G sudo hadoop
</code></pre><p>##三、安装及配置依赖的软件包</p>
<p>###1. 安装openssh-server、java、rsync等</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install openssh-server rsync
$ sudo service ssh restart
$ sudo apt-get install openjdk-7-jdk
$ java -version
</code></pre><p>###2. 配置ssh免密码登录</p>
<p>切换到hadoop用户，需要输入添加hadoop用户时配置的密码。后续步骤都将在hadoop用户的环境中执行。</p>
<pre><code>$ su -l hadoop
</code></pre><p>配置ssh环境免密码登录。</p>
<pre><code>$ ssh-keygen -t rsa -P &quot;&quot;;
</code></pre><p>在/home/hadoop/.ssh目录下生成了id_rsa（私钥）和id_rsa.pub（公交两个文件）,将公钥追加到authorized_keys中，该文件保存所有允许以当前用户身份登录到ssh客户端用户的公钥内容。</p>
<pre><code>$ cat ~/.ssh/id_rsa.pub &gt;&gt;; ~/.ssh/authorized_keys
</code></pre><p>验证登录本机是否还需要密码，配置正确的话是可以不需密码登录的。</p>
<pre><code>$ ssh localhost
</code></pre><p>##四、下载并安装Hadoop</p>
<p>在hadoop用户登录的环境中进行下列操作：</p>
<p>###1. 下载Hadoop 2.6.0</p>
<pre><code>$ wget http://mirrors.aliyuncs.com/apache/hadoop/common/hadoop-2.6.0/hadoop-2.6.0.tar.gz
</code></pre><p>###2. 解压并安装</p>
<pre><code>$ tar zxvf hadoop-2.6.0.tar.gz
$ sudo mv hadoop-2.6.0 /usr/local/hadoop
$ sudo chmod 774 /usr/local/hadoop
</code></pre><p>###3. 配置Hadoop</p>
<pre><code>$ vim /home/hadoop/.bashrc
</code></pre><p>在/home/hadoop/.bashrc文件末尾添加下列内容：</p>
<pre><code>#HADOOP START
export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64
export HADOOP_INSTALL=/usr/local/hadoop
export PATH=$PATH:$HADOOP_INSTALL/bin
export PATH=$PATH:$HADOOP_INSTALL/sbin
export HADOOP_MAPRED_HOME=$HADOOP_INSTALL
export HADOOP_COMMON_HOME=$HADOOP_INSTALL
export HADOOP_HDFS_HOME=$HADOOP_INSTALL
export YARN_HOME=$HADOOP_INSTALL
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_INSTALL/lib/native
export HADOOP_OPTS=&amp;#34;-Djava.library.path=$HADOOP_INSTALL/lib&amp;#34;
#HADOOP END
</code></pre><p>保存退出后，激活新加的环境变量</p>
<pre><code>$ source ~/.bashrc
</code></pre><p>至此，Hadoop单机模式安装完成，可以通过下述步骤的测试来验证安装是否成功。</p>
<p>##五、测试验证</p>
<p>创建输入的数据，暂时采用/etc/protocols文件作为测试</p>
<pre><code>$ cd /usr/local/hadoop
$ sudo mkdir input
$ sudo cp /etc/protocols ./input
</code></pre><p>执行Hadoop WordCount应用（词频统计）</p>
<pre><code>$ bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.6.0-sources.jar org.apache.hadoop.examples.WordCount input output
</code></pre><p>查看生成的单词统计数据</p>
<pre><code>$ cat output/*
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop1.2.1本地伪分布式安装]]></title>
      <url>http://codeinterviews.com/hadoop1.2.1%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>##引言<br>由于最近需要大数据的处理，所以需要用到hadoop.因此在这里记录本地伪分布式的安装过程。</p>
<a id="more"></a>
<p>##下载jdk以及配置环境变量<br>这里采用jdk1.6 将其拷贝到/usr/jdk下面，执行安装文件后。然后需要配置JAVA_HOME和CLASSPATH.<br>使用vim 进入/etc/profile.在结尾部分添加如下内容：</p>
<pre><code>JAVA_HOME=/usr/java/jdk1.6.0_45
PATH=$JAVA_HOME/bin:$PATH
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export JAVA_HOME PATH CLASSPATH
</code></pre><p>保存后，执行以下命令使配置文件生效</p>
<pre><code>source /etc/profile
</code></pre><p>检查java是否安装成功</p>
<pre><code>java -version
</code></pre><p>##安装hadoop<br>这里使用hadoop1.2.1，解压到/usr/hadoop1.2.1中。<br>然后配置SSH</p>
<pre><code>1.生成秘钥
ssh-keygen -t rsa
2.一直回车即可,然后进入.ssh目录,执行命令
cd ~/.ssh
cp id_rsa.pub authorized_keys
3.检查是否需要密码
ssh localhost
</code></pre><p>进入hadoop安装路径，对hadoop进行配置。</p>
<p>##配置hadoop<br>配置core-site.xml:<br>vi core-site.xml打开core-site.xml文件，然后在configuration标签中加入以下内容：</p>
<pre><code>&lt;property&gt;

&lt;name&gt;fs.default.name&lt;/name&gt; 

&lt;value&gt;hdfs://localhost:9000&lt;/value&gt;

&lt;/propety&gt;

&lt;!—fs.default.name：用来配置namenode,指定HDFS文件系统的URL，通过该URL我们可以访问文件系统的内容，也可以把localhost换成本机IP地址；如果是完全分布模式，则必须把localhost改为实际namenode机器的IP地址；如果不写端口，则使用默认端口8020。 --&gt;

&lt;property&gt;

&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;

&lt;value&gt;/tmp/hadoop/hadoop_tmp&lt;/value&gt;

&lt;/property&gt;

&lt;!-- hadoop.tmp.dir：Hadoop的默认临时路径，这个最好配置，如果在新增节点或者其他情况下莫名其妙的DataNode启动不了，就删除此文件中的tmp目录即可。不过如果删除了NameNode机器的此目录，那么就需要重新执行NameNode格式化的命令。该目录必须预先手工创建。--&gt;
</code></pre><p>配置hdfs-site.xml:<br>在configuration标签中加入以下内容，所有不存在的目录都要预先创建：</p>
<pre><code>&lt;property&gt;

&lt;name&gt;dfs.data.dir&lt;/name&gt;   

&lt;value&gt;/home/hadoop/hadoop_dir/dfs/data&lt;/value&gt;

&lt;/property&gt;

&lt;!--配置HDFS存储目录,数据存放目录,用于datanode存放数据--&gt;

&lt;property&gt;

&lt;name&gt;dfs.name.dir&lt;/name&gt;

&lt;value&gt;/home/hadoop/hadoop_dir/dfs/name&lt;/value&gt;

&lt;/property&gt;

&lt;!—用来存储namenode的文件系统元数据，包括编辑日志和文件系统映像，如果更换地址的话，则需要重新使用hadoop namenode –format命令格式化namenode--&gt;

&lt;property&gt;

&lt;name&gt;dfs.replication&lt;/name&gt;

&lt;value&gt;1&lt;/value&gt; 

&lt;/proerty&gt;

&lt;!—用来设置文件系统冗余备份数量，因为只有一个节点，所有设置为1，系统默认数量为3--&gt;
</code></pre><p>配置mapred-site.xml:<br>在configuration标签中加入以下内容：</p>
<pre><code>&lt;property&gt;

&lt;name&gt;mapred.job.tracker&lt;/name&gt;

&lt;value&gt;localhost:9001&lt;/value&gt;     

&lt;/property&gt;

&lt;!—该项配置用来配置jobtracker节点，localhost也可以换成本机的IP地址；真实分布模式下注意更改成实际jobtracker机器的IP地址--&gt;
</code></pre><p>##运行hadoop</p>
<p>####1.格式化HDFS文件</p>
<pre><code>bin/hadoop namenode -format
</code></pre><p>这里有可能会报“主机找不到错误”，此时需要查看主机名是否有问题，详情见<a href="http://blog.csdn.net/shirdrn/article/details/6562292" target="_blank" rel="external">主机找不到处理</a></p>
<p>####2.启动hadoop环境</p>
<pre><code>bin/start-all.sh
</code></pre><p>####3.查看是否启动完全</p>
<pre><code>jps
</code></pre><p>查看是否成功启动SecondaryNamenode，JobTracker，NameNode，DataNode，TraskTracker五个进程，而刚好这五个进程是hadoop所需要的。如果有一个进程没有启动成功，就表示整个集群没有正常工作，我们可以进入/data/software/hadoop/hadoop-1.2.1/libexec/../logs/目录下查看失败日记</p>
<p>####4.从浏览器查看hadoop信息:<br>我们可以从本机或者其他机器的浏览器访问hadoop。（<strong>ip地址自己修改成自己的</strong>）</p>
<p>查看jobtracker信息：</p>
<p><a href="http://192.168.0.107:50030/jobtracker.jsp" target="_blank" rel="external">http://192.168.0.107:50030/jobtracker.jsp</a></p>
<p>查看namenode信息：</p>
<p><a href="http://192.168.0.107:50070/dfshealth.jsp" target="_blank" rel="external">http://192.168.0.107:50070/dfshealth.jsp</a></p>
<p>查看trasktracker信息：</p>
<p><a href="http://192.168.0.107:50060/tasktracker.jsp" target="_blank" rel="external">http://192.168.0.107:50060/tasktracker.jsp</a></p>
<p>##WordCount测试<br>1.我们创建一个input文件夹，并且创建3个文件，给每个文件写一些内容：</p>
<pre><code>mkdir input

echo “hello hadoop” &gt;input/f1.txt

echo “hello word” &gt;input/f2.txt

echo “hello java” &gt;input/f3.txt
</code></pre><p>2.使用以下命令在hadoop中创建文件夹：</p>
<pre><code>bin/hadoop fs –mkdir input
</code></pre><p>3.我们查看在hadoop中是否已经创建该文件夹：</p>
<pre><code>bin/hadoop fs –ls /user/root
</code></pre><p>4.使用以下命令把文件从Linux中复制到hadoop中：</p>
<pre><code>bin/hadoop fs –put input/* input
</code></pre><p>5.查看文件是否在hadoop中：</p>
<pre><code>bin/hadoop fs –ls input
</code></pre><p>6.查看文件内容是否一致：</p>
<pre><code>bin/hadoop fs –cat input/f1.txt
</code></pre><p>7.执行wordcount示例程序</p>
<pre><code>bin/hadoop jar hadoop-examples-1.2.1.jar wordcount /user/root/input /user/root/output (注：这里的root为hadoop运行时的用户名，根据需要换成自己的实际用户名)
</code></pre><p>8.从hdfs中取回文件到本地</p>
<pre><code>bin/hadoop fs -get /user/root/output /root (这样，就把运算结果output中的文件放到本地root目录下了)
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[贝叶斯网络中的依赖关系]]></title>
      <url>http://codeinterviews.com/dependence-in-bn/</url>
      <content type="html"><![CDATA[<p>贝叶斯网络（Bayesian Network，简称 BN）是机器学习中最重要的工具之一，它以贝叶斯规则（Bayesian Rule）为基础，并为马尔可夫模型奠定了基础。</p>
<p>简单来说，贝叶斯网络就是一个有向无环图。节点 node 表示变量，弧 arc 表示依赖关系。比如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1ehple2py1lj206u03kdft.jpg" alt=""></p>
<p>「Sprinkler」是洒水器的意思。这三个变量代表三种事件。下雨和洒水器都能影响草地湿度，而下雨又可以影响洒水器是否洒水。三个变量的依赖关系如图所示。</p>
<p>在 BN 中，有些 node 是可以观察到的observable，有些是无法观察到的 hidden。比如下雨和草地湿可以观察到，洒水器是否洒水了是无法观测得到的。对于一个 BN，我们可以求所有变量的联合概率，也可以求某个隐节点的后验概率。前提是我们已经得到了这个 BN 所需要的参数：每个 arc 所代表的条件概率。</p>
<p>不过我今天要讲的东西并不是这些，而是条件依赖关系，这类概念让我颇费脑子。</p>
<a id="more"></a>
<p>下面通过两种结构来讨论四种依赖关系。</p>
<p>###条件独立</p>
<p>先看图：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1ehpln4jn8yj203f03k0sl.jpg" alt=""></p>
<p>C 表示 cancer，取值空间是{C,-C} ；T1 和 T2表示两个检测结果，取值空间是{+,-}。每个箭头代表的条件概率表已知。</p>
<ol>
<li>已知 C，那么 T1, T2是否独立？ 假如知道这个病人实际上患癌症，在估计 T2的时候，知道「T1是+」与否对这个估计有影响吗？其实是没有影响的。T1和 T2相当于对 C 做了两次独立观测。在 C 已知的情况下，T1,T2独立，因此属于条件独立。用全概率公式计算一下会更加的一目了然，会发现计算 P(T2)的过程中并没有涉及到 T1.</li>
<li>若 C 未知，那么 T1,T2是否独立。假如 T1为+，那么我们会认为 C 很有可能也是+，进而认为 T2同样取+的概率会提升。因此 T1,T2不独立。如果有兴趣，可以计算一下 P(T2=+ | T1=+)和 P(T2=+)，可以看到分别是0.2301和0.207，前者大。如图：</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1ehpm233shmj20kp0bc0uf.jpg" alt=""></p>
<p>###条件依赖</p>
<p>先看例子：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1ehpm762vsoj204003mmx1.jpg" alt=""></p>
<p>S: sunny; R: raise of salary; H: happiness.条件概率表已知。</p>
<ol>
<li>若 H 未知，则P(R | S) = P(R)，即两者独立。直白的解释就是：我朋友并不知道我是否高兴，只看到天气是晴朗的，他能推测我是否涨了工资吗？当然不能。</li>
<li>若 H 已知，这时候出现一个有趣的现象，叫 explain away.朋友看到我很高兴，又看了看天，发现是个大晴天，他就会认为我的高兴应该是由于天晴的缘故，不大可能是由于涨工资的原因；朋友若看到我高兴，同时又看到天气很糟糕，那么他会认为我很可能是涨工资了。也就是说，在已知 H 的情况下，对 S 的观测影响到了对 R 的估计，说明 S 和 R 是条件依赖的。</li>
</ol>
<p>掌握了上述四种情况的依赖关系，那么整个 BN 中任意两个节点的依赖关系就可以知道了。</p>
<p>好，主要内容讲完了，顺便说一下，BN 中最重要的 basics 是 chain rule, Bayesian Rule 和 total probability，在计算中会大量使用；最重要的参数是每个 arc 的条件概率表。BN 可以做分类器，node 为特征向量中的各分量，并有一个 node 表示label，学习的过程就是求得上述参数。BN 较其他分类器的优势在于考虑了各特征之间的依赖关系。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[聊聊 Google 被封锁这件事]]></title>
      <url>http://codeinterviews.com/google-blocked/</url>
      <content type="html"><![CDATA[<p>老实说，Google 这次被封锁对我的影响不是特别大，它在中国的服务本来就已经被 ZF「政府，下同」 搞的支离破碎，早已不稳定，像我等 Google 重度用户几乎都常备科学上网工具的。不过区别还是挺明显的，之前的时候常常不必打开那些工具，直接使用 Google 即可，方便；现在却一点都不能用了。科学上网的工具由于其机制问题，对于某些服务如谷歌图片、谷歌学术，常常会有网址重定向的问题，很麻烦，这时候多么幻想 free Internet.</p>
<p>####Google 为何被封？</p>
<p>Google 的原则是几乎不对用户搜索的结果进行过滤，这是为保障网络信息自由。而我国由于特殊原因，有大量的信息是敏感的，ZF不愿让民众接触到；或者 ZF 不自信，怕民众接触到。这样的信息一般来说有政治、色情、恐怖暴力这几个方面。对于第一项，ZF 似乎忌惮着什么。对于第二项，我实在不理解「两性解放」为何还不到来。对于第三项，我支持。这次的封锁似乎比以往更彻底、更持久，据说是因为64才封锁的，可64已经过了，封锁还没有解除。私以为可能与近来国内严重的恐怖暴力事件有关。可能 ZF 现在的原则是「安全、维稳大于一切」，而 Google 是一个经常被恐怖分子利用的工具，如此看来，ZF 的因噎废食就可以理解了。在他们眼里，关键时期，以阻碍国家的经济社会发展为代价换取国家社会的安全是值得的。</p>
<p>####Google 被封有何影响？</p>
<p>据我所知，Google 应该是科技从业人士离不开的利器，尤其广大的 IT 人，使用的密度特别大。以我个人为例，Google 搜索是我知识的重要来源，Google 学术是读论文不可缺少的工具，Google 图片是我图片素材的重要来源，Gmail 是我的主邮箱，每天都会使用，Google calendar 是我计划日程不可或缺的工具，Youtube 有大量优质的公开课、教育视频。。。</p>
<p>此外，全世界的网站大多在使用 Google 提供的 cdn 服务，比如 google font, jquery 等等，这次封锁导致很多网站打开缓慢，因为这些 cdn 被封锁了。</p>
<p>不过，对于不同的人，影响的大小是不一样的。</p>
<p>程序员：作为重度使用者，其实所受影响差不多最小，因为我们知道怎么 counter block，除了吐槽ZF几句，该怎么用 Google 还是怎么用。</p>
<p>恐怖分子： 我想ZF 此次加大封锁力度主要是针对这些有碍国家安全的人吧。但他们是有组织、有科技、有训练的，科学上网都不会他们还怎么做恐怖分子，所以我觉得对他们的影响也很小。</p>
<p>「政治爱好者」：这里特指通过国外信息了解国内政治的人，这样的人一直都有。我的观点是，当你的信息足够充分时，你就不太会一叶障目做出偏激的事情来。国外并不只有批评中国 ZF 的声音，其他声音也有，我想他们是不至于只看到一家之言就开始反 ZF 的。如果 ZF 的目的是防止他们接触西方的思想，防止走资，防止意识形态渗透，那你封就封吧。</p>
<p>「色情爱好者」：从中国互联网诞生到现在，色情内容一直是被过滤的，这类人早就熟知怎么翻过去，所以影响很小。</p>
<p>普通大众： 我认为中国大多数的人是不用 Google 的，一来 ZF 已经把它赶了出去，Google 服务很不稳定；二来 Google 的本土化做的没有百度好，在生活、娱乐这些受众面最大的服务上，Google 不如百度。那么对于他们的影响自然不大了。</p>
<p>综上，ZF 封锁 Google 除了徒然浪费民众很多时间、精力外，其实并不能阻止人们做本打算做的事情。从这个意义上讲，这样一刀切式的封锁得不偿失。而且，我相信会有比一刀切更好的办法，ZF 这样做，显然是一种懒政。</p>
<p>####怎么破？</p>
<p>据说 Goagent、免费 VPN 什么的都不好使了， 付费 VPN 一直很稳定，Shadowsocks 还可以。</p>
<p>如果只需要使用 Google Search，那么最简单方便，甚至最好的办法是直接用 IP <a href="http://203.208.46.148/" target="_blank" rel="external">http://203.208.46.148/</a>。当然，IP 不限这一个，有兴趣的同学可以通过下面的方式得到需要的 IP：</p>
<p>在 shell 中输入<code>ping google.cn</code>。</p>
<p>或在 cmd 中输入<code>ping -4 google.cn</code>。</p>
<p>如果还需要使用其他的 Google 服务，那最好是学习一下科学上网。</p>
<p>还有一种方式是在 Chrome://flag 中修改某些东西，我试过，挺慢的，不如 IP 的方式好。</p>
<a id="more"></a>
<p>####还需要做些什么？</p>
<p>有人发起去工信部投诉 Google 上不去，就像当年的 Github 事件；有人反对，说没用。</p>
<p>我支持投诉，从「认了」到「行动维权」本身就是一个进步，无论结果如何，都是值得鼓励和庆祝的事情。</p>
<p>有人说支持和反对投诉的人在 v2ex 的辩论是「闲的蛋疼」，我认为这样的辩论恰恰也是进步。人们的观点尽管都是有逻辑的，但往往还是不同，为什么，一个原因是个人的信息和见识不充分。通过充分、坦率的讨论，正反双方把自己的观点和盘托出，如果能说服对方，说明自己的观点站住了脚，如果不能说服，起码对方已经理解了你。在他信息相对充分的情况下，无论是坚持己见还是倒戈，他的选择都是认真的，是值得尊重的。民智渐强需要广泛、深刻的讨论。</p>
<p>我始终相信 ZF 也有很多有理想有担当的当权者，当然也有很多眼光狭隘、思想顽固、自私自利的绊脚石，因为党内民主或集体领导的原则，当权者不能利用自己的魄力或权力强迫大家意见一致，只能博弈、讨论、说服，虽然这个过程慢，但这不就是我们期待的「民主」嘛，虽然这民主目前只限于领导集团。我们眼前看到的，可能就是他们斗争博弈妥协的结果，我相信里面有人在为我们争取权益。</p>
<p>我之前在微博发动好友关注 google 事件，企图通过民意影响政治。现在觉得不很现实，对 Google 最关注的是程序员，而程序员只是小众，他们的呼声够不成民意。只有像「招远事件」这种跨越了职业藩篱的共同意见，这种每个人都可以不费力地参与进来的讨论，才可能构成民意。</p>
<p>结论是，该表达的表达，该争取的争取，要有希望，有信心，相信有人在为我们战斗。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Chrome Extensions I Use]]></title>
      <url>http://codeinterviews.com/chrome-addons/</url>
      <content type="html"><![CDATA[<p>Chrome 最强大的一个地方就是丰富的扩展插件了，在它的商店里寻找，只有你想不到的，很难有找不到的。Chrome 也是我的默认浏览器，一边使用一边优化体验，现在来说说我都用了哪些插件吧。</p>
<p>首先介绍我平时一直在使用的：</p>
<ol>
<li>AdBlock。 还有一个叫 AdBlock Plus 也不错，但最近 Plus 这个插件导致我的 pdf 无法在浏览器打开，于是换成 AdBlock 了，没差。装上这个插件之后，浏览器里的整个世界都清爽了，那些恼人的 Flash 广告一一自动清除了。</li>
<li>Copy as Markdown。用 Markdown 写作时经常需要一些图片或文字的链接，这个小插件使得 Markdown 中插入图片、链接轻而易举，一直在用。</li>
<li>Flashcontrol。Chrome 的使用很容易导致 Mac 发烫，经了解，是 Flash 所致，而 Flash 大部分都是无用的广告。这个插件是的那些 Flash 无法自动加载，如果需要看 Flash 的视频，只需要点击一下就行了，非常方便。BTW,貌似 Safari 没有发热的问题，不过这货太难用了，我顺便安装了 Firefox 来做备用浏览器，装上一些好用的插件后，FF 也是相当不错的选择。</li>
<li>Halo Word Dictionary。查字典用。</li>
<li>Proxy SwitchySharp。科学上网，You know.</li>
<li>Send to Kindle。有什么好文章了，用这个发到 Kindle 中看。这里面还有个小窍门，由于选中的文字可以编辑，我完全可以把任何文字、图片拷贝过去发到 Kindle。</li>
<li>Session Buddy。查找某个问题时打开了一浏览器的 Tab，乱糟糟的，今天不想看了，改天再看这些东西，咋办？用这个。它可以把浏览器打开的 Tab 都保存下来。</li>
<li>Vimium。神器，用 Vim 的方式操作 Chrome，效率的提升是惊人的，我现在已经离不开它了。</li>
<li>印象笔记·剪藏。方便地把页面内容保存到 Evernote 中。</li>
<li>围脖是个好图床。用 Markdown 写作必备的图床。</li>
</ol>
<p>下面要说的是挺不错，但偶尔才用用的：</p>
<ol>
<li>Chrome YouTube Downloader。安装好后，在 Youtube 的视频下边会出现一个下载按钮，可以选择下载哪种分辨率的视频或者下载音频。</li>
<li>FaWave(发微)。如果有多个社交帐号，比如微博、人人、twitter、facebook，用这个可以将一条状态发送到所有这些 SNS 中。</li>
<li>Pervasive GRE。显示当前页面所有的 GRE 词汇。</li>
<li>Pocket。好用的收藏管理，如果不习惯用 Chrome 的 Bookmark，Pocket 将是一个绝佳的选择。</li>
<li>隐藏帖自动回复 (AutoReply 纯净版)。很多BBS 的内容需要回复可见，这个插件就解决这个烦人的问题。</li>
</ol>
<p>至于主题，在 Mac 下，默认的主题最干净。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vim Tips 2]]></title>
      <url>http://codeinterviews.com/vim-tips-2/</url>
      <content type="html"><![CDATA[<p>此前写过一篇<a href="http://zipperary.com/2013/09/03/vim-commands/" target="_blank" rel="external">VIM常用命令</a>。Vim 学习曲线还是比较陡峭的，很多教程都是直接给出一个Vim 命令或快捷键的参考列表，求全，这反而把有心学习的潜在用户吓跑了。我在学习使用 Vim 的时候尽量先总结最常用的，并按照操作类型归类，符合自己的认知结构。由此总结出该文中所记述的笔记。写作该文时比较急促，直接把 Evernote 中的 notes 拿过来，没有调整格式，也没有写注解。</p>
<p>有了基础，并能基本使用 vim 编程，以后就是问题驱动型的学习了，aka，coding 中遇到什么不方便的地方，就 google 一下有没有对应的命令、快捷键、插件之类。不久后写了一篇<a href="http://zipperary.com/2013/08/24/vim-tips/" target="_blank" rel="external">vim使用中的几个问题</a>。</p>
<p>时间已经过去很久。去年入手 Mac 后，编程几乎都是在 Vim 中，之前用 terminal 的，现在已经习惯使用 Macvim 了。同样基于问题驱动，又 get 了一些技能，在此呈上。</p>
<ol>
<li>插件管理用<code>pathogen</code>，安装插件非常简单，也比<code>vundle</code>灵活。</li>
<li><code>Normal</code>模式下，寻找上次光标所在位置为<code>ctrl + o</code>，下次的为<code>ctrl + i</code>，跳到某行修改并返回的时候非常方便。</li>
<li>用<code>:!command</code>可以在 Vim 中写 shell 命令，自动转入 shell 执行。不过，我现在一般用<code>iTerm</code> + <code>Macvim</code>，不再需要用这个命令了。</li>
<li>查看缓存文件<code>:ls</code>，是不是很像 shell 中的那个。切换到其中一个用<code>:buffer n</code>。</li>
<li>File browser 自然使用大名鼎鼎的<strong>NERDTREE</strong>，在 nerdtree 中新建文件的方式是<code>m-a</code>并写出文件名称。刷新用<code>r</code>。忘记快捷键了，要习惯使用<code>?</code>打开和关闭帮助。<code>Bookmarks</code>功能刚开始用，赞！</li>
<li>分屏之后切换窗口，用<code>ctrl + w + h</code>是切换到左边的窗口，自然，其他方向的分别是<code>j, k, l</code>。另外还有两个非常重要，吐血推荐，<code>t, b</code>，分别是直接切换到最左或最右，如果你用过<code>Taglist</code>并打开了多个窗口，你就知道这东西多重要了。</li>
<li>交换两个窗口的位置，或者说移动窗口，用<code>ctrl + w + r/x</code>，试试就知道了，很多时候需要这东西。</li>
<li>窗口大小调整，宽度和高度分别用<code>ctrl + w + &lt;/&gt;</code>和<code>ctrl + w + +/-</code>，或者使用更加灵活的<code>:res +n</code>，<code>:vertical res +n</code>。自动分割的窗口未必好用，所以很多时候是需要自己调整的。</li>
<li>把鸡肋的 Caps Lock 键换成了 Esc，太爽了。</li>
<li>粘贴到 vim 中时由于 indent 的原因，经常会导致格式乱掉。在<code>.vimrc</code>中添加<code>set pastetoggle=&lt;F9&gt;</code>，插入模式下按下 F9即可进入粘贴模式，之后再次通过 F9返回即可。</li>
</ol>
<a id="more"></a>
<p>另外，安装了以下插件：</p>
<ul>
<li><a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="external">pathogen</a>:方便的插件管理器。</li>
<li><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="external">nerdtree</a>: 目录树。</li>
<li><a href="http://www.vim.org/scripts/script.php?script_id=273" target="_blank" rel="external">taglist</a>:方便预览代码的block.</li>
<li><a href="https://github.com/pangloss/vim-javascript" target="_blank" rel="external">vim-javascript</a>:改善 vim 对 js 的高亮和语法支持。</li>
<li><a href="https://github.com/plasticboy/vim-markdown" target="_blank" rel="external">vim-markdown</a></li>
<li><a href="https://github.com/hdima/python-syntax" target="_blank" rel="external">python-syntax</a>：直接拷贝的，并修改、添加了对 self 的支持。</li>
<li><a href="https://github.com/Yggdroot/indentLine" target="_blank" rel="external">indentLine</a></li>
<li><a href="https://github.com/scrooloose/syntastic" target="_blank" rel="external">syntastic</a>：语法检查。</li>
<li><a href="https://github.com/jcrocholl/pep8" target="_blank" rel="external">pep8</a>:检查python代码是否符合 pep8规范。</li>
<li><a href="https://github.com/gmarik/Vundle.vim#about" target="_blank" rel="external">Vundle</a>：插件管理。</li>
<li><a href="https://github.com/ervandew/supertab" target="_blank" rel="external">supertab</a></li>
<li><a href="https://github.com/davidhalter/jedi-vim" target="_blank" rel="external">jedi-vim</a></li>
<li><a href="https://github.com/digitaltoad/vim-jade" target="_blank" rel="external">vim-jade</a></li>
<li><a href="http://www.vim.org/scripts/script.php?script_id=2075" target="_blank" rel="external">html.vim</a>: indent improved</li>
<li><a href="https://github.com/mattn/emmet-vim" target="_blank" rel="external">emmet-vim</a>: zen coding in vim, a tutorial is <a href="http://www.zfanw.com/blog/zencoding-vim-tutorial-chinese.html" target="_blank" rel="external">here</a></li>
<li><a href="https://github.com/bling/vim-airline" target="_blank" rel="external">vim-airline</a>: awsome statusline</li>
</ul>
<p>vimrc 和插件列表同步在 github 上，从<a href="https://github.com/zippera/vimsettings" target="_blank" rel="external">这里</a>进入。</p>
<p>最后上一张效果图：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1egfuz1hon0j21hc0u0tkd.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[阿里数据挖掘]]></title>
      <url>http://codeinterviews.com/ali-data-mining/</url>
      <content type="html"><![CDATA[<p>前段时间阿里巴巴组织了一个大数据的竞赛，全国高校积极响应，报名者、参与者、提交者众多，最好成绩也一直在刷新当中。初赛选出 Top500 进入复赛，其他人就炮灰了。</p>
<p>虽然是搞图像的，但念在未来图像不太好就业，而大数据是现在及未来的热门，正巧在修习一门《数据挖掘》课程，就把阿里这个题目作为大作业的题目了。</p>
<p>###题目介绍</p>
<p>题目大意是这样的：</p>
<blockquote>
<p>给定 4.15-7.15 这四个月的用户数据作为训练数据，大概18万条。然后预测下一个月哪些用户会购买哪些品牌。数据提交到阿里的竞赛平台，阿里会给出准确率、召回率和 F1值。</p>
</blockquote>
<p>数据的说明如图：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eg6xzalotrj20j805jjs2.jpg" alt=""></p>
<p>准确率、召回率就不解释了，大多数预测性的实验都以此作为评价指标。阿里用这两个值计算一个综合的评价指标 F1 作为排名依据。</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1eg6y25tsnij204601jt8j.jpg" alt=""></p>
<a id="more"></a>
<p>###思路</p>
<p>从这个题目，可以直观地想到我们机器学习中的<strong>Supervised Learning</strong>。另外，这是一个推荐问题，由此可以联系到亚马逊、Netflix 的推荐系统，想到 SVD等用户关联和协同过滤方法。此外，还可以发现一些经验规则，比如周期性、重复购买性等等。</p>
<p>协同过滤，一个非常直观的方法是用二部图得到推荐系数，同学用这个来做，效果不错。</p>
<p>我开始用的逻辑回归，但效果不好。现在想想，方法没问题，问题出在了特征的处理和最后推荐结果的选择上。</p>
<p>现在使用的是感知器，由于阿里初赛已经结束，无法提交结果以测试实验效果，只能把有限的本地数据分割成训练集和测试集来做。目前取得的 F1 为 4.3% 。虽然还很低，但至少证明思路是对的。</p>
<p>感知器属于线性分类器，也可以理解为最简单的神经网络。它非常直观，通过训练集，训练出每个特征对应的权值。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eg6ydhd8tbj20in0bedg5.jpg" alt=""></p>
<p>具体就不介绍了，可以参考 wikipedia。</p>
<p>###程序</p>
<p>程序代码用 Python 完成。如果去掉注释行、没有使用的函数，总共100行左右。使用了第三方包<code>sklearn</code>。</p>
<p>代码已经上传到<a href="https://github.com/zippera/dm_ali" target="_blank" rel="external">Github</a>，欢迎讨论和给出建议。代码中做了注释，就不再多做解释了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解 javascript 回调函数]]></title>
      <url>http://codeinterviews.com/js-callback/</url>
      <content type="html"><![CDATA[<p>最近在看 express,满眼看去，到处是以函数作为参数的回调函数的使用。如果这个概念理解不了，nodejs、express 的代码就会看得一塌糊涂。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not Found'</span>);</span><br><span class="line">    err.status = <span class="number">404</span>;</span><br><span class="line">    next(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>app</code>是对象，<code>use</code>是方法，方法的参数是一个带参的匿名函数，函数体直接在后面给出了。这段代码怎么理解呢？我们先来了解<em>回调函数</em>这个概念。</p>
<p>首先要了解，在 js 中，函数也是对象，可以赋值给变量，可以作为参数放在函数的参数列表中。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思是定义一个匿名函数，这个匿名函数除了没有名字之外，其他跟普通的函数没有什么两样。然后把匿名函数赋值给变量<code>doSomething</code>。接下来我们调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(doSomething(<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>这样会输出<code>5</code>。</p>
<a id="more"></a>
<p>回调函数，就是放在另外一个函数（如 parent）的参数列表中，作为参数传递给这个 parent，然后在 parent 函数体的某个位置执行。说来抽象，看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// To illustrate the concept of callback</span></span><br><span class="line"><span class="keyword">var</span> doit = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">        b = <span class="number">2</span>,</span><br><span class="line">        c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> t = callback(a,b,c);</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> d = doit(<span class="function"><span class="keyword">function</span>(<span class="params">x,y,z</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x+y+z);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure>
<p>先定义 doit 函数，有一个参数 callback。这个 callback 就是回调函数，名字可以任意取。看函数体，先定义三个变量 a,b,c。然后调用 callback 函数。最后返回一个值。</p>
<p>下面就调用 doit 函数了。要注意的是，刚才定义 doit 时，callback 并没有定义，所以刚才并不知道 callback 是干什么用的。这其实很好理解，我们平时定义函数的时候，参数也只是给出了一个名字，比如 a,在函数体中使用 a，但整个过程也并不知道 a 到底是什么，只有在调用那个函数的时候才指定 a 的具体值，比如2.回过头来，在调用 doit 的时候，我们就需要指定 callback 究竟是个什么东西了。可以看到，这个函数完成了一个 sum 功能。</p>
<p>上述代码的执行过程是：</p>
<p>调用 doit函数，参数是一个匿名函数；进入 doit 的函数体中，先定义 a,b,c，然后执行刚才的匿名函数，参数是 a,b,c，并返回一个 t，最后返回一个 t+10给 d。</p>
<p>回到最初的例子，<code>app.use(...)</code>是函数调用。我们可以想象，之前一定定义了一个 use 方法，只是这里没有给出。这两个例子一对比，就可以马上理解了。</p>
<p>在使用nodejs、express 的时候，不可能每个方法或函数我们都要找到它的函数定义去看一看。所以只要知道那个定义里面给 callback 传递了什么参数就行了。然后在调用方法或函数时，在参数里我们自己定义匿名函数来完成某些功能。</p>
<p>Over!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[wiz to evernote]]></title>
      <url>http://codeinterviews.com/wiz-to-evernote/</url>
      <content type="html"><![CDATA[<p>Evernote 刚刚诞生不久我就成为了它的用户，后来中国有趋势成为用户第二多的国家，于是印象笔记诞生，同步的速度快了不知道多少倍。由于对它的依赖，我的笔记数量迅速增加。当时用的是 windows，印象笔记的优化可能还没做好，随着笔记量增大，笔记经常会卡顿到无法忍受。开始考虑其他的笔记应用。</p>
<p><strong>印象笔记当初让我很难忍受的另外两个原因：</strong></p>
<ul>
<li>流量限额，只有60M，几乎没办法保存图片和附件。</li>
<li>没有格式刷功能，非常不便。关于这个问题我咨询过印象笔记的官方微博，回应说，印象笔记是基于 html 的，技术上做格式刷的难度太大。于是我就不抱期望了。</li>
</ul>
<p>经过各种寻找、尝试、推荐，最后确定用国内的「为知笔记」。由于是国内的，其安全性是我最大的担心，不过在网上看到很多貌似靠谱的人推荐，我也就不消怀疑了。</p>
<p><strong>为知笔记好用的地方：</strong></p>
<ul>
<li>方便的格式刷功能。</li>
<li>个人用户流量不限。</li>
<li>windows 上非常流畅。</li>
<li>支持各种小插件，比如 markdown 写作。</li>
<li>与社交账户的结合。</li>
</ul>
<p>于是我就下定决心转过来。当时印象笔记转到为知笔记是没有很好支持的，需要太多的手工劳动，必须要坚定的决心和顽强的意志才行。</p>
<a id="more"></a>
<p>经过一番摧残，终于在为知笔记安了家，然后相安无事。</p>
<p>过了很久，我买了Mac，用为知笔记的 Mac 版，太过鸡肋，功能少的可怜，各种不方便。为知笔记一直在进步，但Mac 版的功能始终太过简单了。这几个月又接连发生笔记乱码、丢笔记、笔记图片挂掉的情况，苦不堪言，忍无可忍，必须换笔记了。找了一圈，印象笔记的 Mac 版是做的最好的。得，还得回来。</p>
<p><strong>为知笔记的 Mac 版有这些问题：</strong></p>
<ul>
<li>笔记乱码。我的一个重要笔记内容全编程 html 码了，通过云端都无法恢复，痛苦。</li>
<li>笔记丢失。好几条笔记懒腰斩断，后面的内容全没了。</li>
<li>图片丢失。有些笔记里的图片挂掉，永远挂掉了。</li>
<li>搜索功能鸡肋。几乎可以认为没有搜索功能了，对于一个笔记软件，这是致命的。</li>
<li>没有无格式粘贴功能。</li>
</ul>
<p>回来可麻烦了，现在的笔记都提供了从印象笔记导入的功能，却几乎都没有导入到印象笔记的功能。哎，还是得手动。</p>
<p><strong>经过探索，目前找到的最好的方法如下：</strong></p>
<ol>
<li>参考<a href="http://www.zhihu.com/question/20287008/answer/23591722?utm_source=weibo&amp;utm_medium=weibo_share&amp;utm_content=share_answer&amp;utm_campaign=share_button" target="_blank" rel="external">知乎</a>里面提到的这种方法，把能转移的全部转移。</li>
<li>上面的情况只能导入部分笔记，其他笔记还是需要手动拷贝。直接在客户端（转移操作都在 windows 客户端进行，因为 windows 客户端的功能是最丰富的。）拷贝会遇到图片挂掉或丢失的情况，或者其他格式错误。解决方法是：打开为知笔记的网页版，从网页版的笔记拷贝，这样能完美的把笔记内容和格式拷贝到印象笔记。</li>
</ol>
<p>回来了，印象笔记的不足依然没变，但相对于为知笔记的致命 bug，那些不足也微不足道了。<strong>印象笔记的 Mac 版用了几天了，非常好用。</strong></p>
<ul>
<li>支持笔记搜索和笔记内搜索，可以上下查找，很方便。</li>
<li>笔记支持各种方式排列，我一直在用根据更新时间的排列方式。</li>
<li>支持各种快捷键操作。</li>
<li>支持共享笔记，可以与好友、同事共同维护一些笔记。</li>
</ul>
<p><strong>另外推荐几个 tips：</strong></p>
<ul>
<li>在微博关注<a href="http://weibo.com/myyxbj?topnav=1&amp;wvr=5&amp;topsug=1" target="_blank" rel="external">@我的印象笔记</a>，以后看到喜欢的微博，评论、转发时只要评论一下<code>@我的印象笔记</code>就可以自动记录到印象笔记。</li>
<li>微信关注「印象笔记」后，也可以轻松把微信内容保存到笔记中。</li>
<li>Chrome 插件<a href="https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc" target="_blank" rel="external">印象笔记-剪藏</a>，真心的良心产品。</li>
</ul>
<p>比较遗憾的是，印象笔记仍然没有做出「格式刷」，我一点也不指望了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[An Intuition to Locality Sensitive Hashing]]></title>
      <url>http://codeinterviews.com/lsh/</url>
      <content type="html"><![CDATA[<p>在 Stackoverflow 的「Machine Learning」标签下随便看，看到一个<a href="http://stackoverflow.com/questions/12952729/how-to-understand-locality-sensitive-hashing" target="_blank" rel="external">How to understand Locality Sensitive Hashing?</a>的问题，刚好看视频跟踪时看到有一个 Coherency Sensitive Hashing，莫非两者有不可告人的联系。。索性就学习一下。</p>
<p>先用例子直观地说明一下，请看下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1ef0c2v4ps1j20nf0ddt9l.jpg" alt=""></p>
<p>上图是一个平面，其中有一个红点和一个黄点，都是二维向量。我们的目的是通过 LSH 方法近似求得这两个点的余弦相似度。</p>
<p>余弦相似度是求向量相似度的一种方法，在图像匹配中很常用。</p>
<p>怎么求呢？</p>
<p>现在，在这个平面上，随记产生 n 条过坐标零点的线，这里 n 取6.</p>
<p>分别给红点和黄点一个 hash 表，实际就是一个二值数组，每个元素取0或1，如左上图所示。白色代表0，黑色代表1.这个 hash 表叫做signature。</p>
<p>先看红点，分别看看这6条线在红点的上方还是下方，并分别标注为0/1，填写在signature 中。需要注意的是，这两个 signature 对应元素代表同一条线。</p>
<p>映射完后，计算这两个 signature 中对应元素不同的个数（hamming distance），比如这里是1个，即最后一个。这有什么意义呢？看图，两个点中只有一条线。由于向量的夹角在[0,PI]之间，有6个线，两个点中只插入了1条，那么两点之间的夹角就可以近似为<code>PI * 1/6</code>。</p>
<p>如图所示：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ef0ccvna1dj20of0de405.jpg" alt=""></p>
<a id="more"></a>
<p>当 n 足够大时，这个估计会非常接近真实值：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ef0coa709fj20dm02qjrf.jpg" alt=""></p>
<p>实际上 LSH 是用采样的方法来近似解析方法求得的真值。至于为什么不直接用解析的方法，我现在还不清楚，可能有些时候解析方法无法求吧。</p>
<p>我觉得这东西跟用蒙特卡洛方法近似求解不规则多边形的面积很像。所谓的 hash，只是一个小 trick 而已。</p>
<p>至于名字「Locality Sensitive Hashing」，应该是说，位置上越接近的向量，其 hash 越相似。</p>
<p><a href="http://stackoverflow.com/users/1667256/greeness" target="_blank" rel="external">greeness</a>提供了一段用 python 写的 demo，很值得看一看：</p>
<script src="https://gist.github.com/greeness/94a3d425009be0f94751.js"></script>

<p>代码很简单，不介绍了。值得注意的是其中的移位运算很巧妙，值得学习。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Play Github]]></title>
      <url>http://codeinterviews.com/play-github/</url>
      <content type="html"><![CDATA[<p>今天花时间把 github使用中的一些疑点消灭一下。</p>
<p>###fork &amp; watch &amp; star</p>
<p>到 github 中某人的某个 repo中，会在右上角看到这样的标签：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1eelei341aoj20us01wglm.jpg" alt=""></p>
<p>原来一直困惑为啥要有三个，一个 fork 不就得了嘛，其实有三个还是很有必要的。</p>
<p><strong>fork</strong>: 把该 repo 拷贝到自己的账户下，相当于成为自己的 repo。不同之处是可以通过<code>pull request</code>和 original 的那个建立联系。</p>
<p><strong>watch</strong>: 分为三种级别：not watching,watching,ignore.其实就是用来设置提醒的，比如watching，该 repo 有任何 update 都会收到邮件或 github 中的通知；ignore 就是不接收任何通知。</p>
<p><strong>star</strong>: 可以理解成「收藏」，这个 repo 的 update 不会出现在 news feed 中。在主页通过「star」标签可以查看自己 star 过的 repo。</p>
<p>一般情况下，遇到好的 repo 想要收藏，就 star。想要自己改改、完善一下，可以 fork。想追踪它的某些 update，可以 watch。</p>
<a id="more"></a>
<p>###pull request</p>
<p>比如 tommy351的 hexo 这个 repo，我 fork 了一下。在我这边修改后，想要告诉 tommy351「我完善了一下，你把我修改后的版本合并到你的 repo 吧」，那么我可以向 tommy351发送一个 pull request。</p>
<p>发送的步骤是：在我这边的 hexo 中，点击右侧的「pull request」，然后「New pull request」，然后查看一下我对 tommy351的 repo 做了哪些改变，确认没错之后，点击「Create pull request」，填写一下说明，即可发送。</p>
<p>tommy351收到我的「pull request」后，如果觉得好，可以 merge，这个就不是我的事了。</p>
<p>###branch</p>
<p>新建一个 repo，默认的branch 是 master。master 作为主分支，要稳定。我们进行迭代开发时，可以新建一个 branch，在这个 branch 中开发，搞定后再合并到 master 中。这样的流程比较合理。</p>
<p>创建： <code>git branch test</code>，会新建一个 test 分支，并拷贝 master 的内容到这个分支下。</p>
<p>切换： <code>git checkout test</code> 从 master 分支切换到 test 分支。</p>
<p>查看： <code>git branch</code> 看看这个 repo 下有哪些分支了。带星号的为当前分支。</p>
<p>删除本地分支： <code>git branch -d test</code></p>
<p>删除远端分支： <code>git push origin :test</code> ，注意冒号的意思是删除。</p>
<p>在 test 下的其他操作，如add,commit,push和在 master 下是一样的。</p>
<p>如何合并两个分支呢？</p>
<ol>
<li>通过<code>git checkout master</code>切换到主分支。  </li>
<li>通过<code>git diff test</code>查看这两个分支的不同。</li>
<li>确认无误后，通过<code>git merge test</code>把 test 合并到 master。</li>
</ol>
<p>###pull and fetch</p>
<p>这两个操作都是把别处的 repo 拉到这里来，有什么不同嫩？</p>
<p><code>git pull</code> = <code>git fetch</code> + <code>git merge</code></p>
<p>比如我目前在我的 hexo 下操作，我想要与 tommy351的 hexo 保持同步。</p>
<p>首先，<code>git add remote upstream &lt;tommy351的 hexo 地址&gt;</code>    </p>
<p>如果他五分钟前对hexo这个 repo 做了更改，我现在执行<code>git fetch upstream</code> ，并<code>git diff upstream/master</code>就可以看到这些变化。 如果我觉得不错，那么通过<code>git merge upstream/master master</code>就可以把他做的更改合并到我的 hexo 下。</p>
<hr>
<p>okay，到现在为止，在自己 repo 的 master 下的操作，分支操作，与 original的同步和反馈，以及与他人的社交都会了。以后就要尽量多写代码，并用github 管理代码了。</p>
<p>Have fun!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在 Mac 上安装 Opencv]]></title>
      <url>http://codeinterviews.com/install-opencv-on-mac/</url>
      <content type="html"><![CDATA[<p>在 Mac 安装 opencv，使用的方案和 linux 是一样的。</p>
<p>先在<a href="http://opencv.org/" target="_blank" rel="external">官网</a>页面右侧下载<code>OpenCV for Linux/Mac</code>。</p>
<p>打开终端，用<code>tar -xvf opencv压缩文件</code>解压文件。</p>
<p>cd 进入解压后的文件夹。</p>
<p><code>mkdir release</code></p>
<p><code>cd release</code></p>
<p><code>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..</code></p>
<p><code>make</code></p>
<p><code>sudo make install</code></p>
<p>依次执行，最后没报错就是成功了。</p>
<p>我在安装的过程中遇到了一个棘手的问题，大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Linking CXX shared library ../../lib/libopencv_highgui.dylib</span><br><span class="line">[ 35%] Building CXX object modules/video/CMakeFiles/opencv_video.dir/src/bgfg_gaussmix.cpp.o</span><br><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;_ModPlug_GetCurrentOrder&quot;, referenced from:</span><br><span class="line">     _modplug_read_packet in libavformat.a(libmodplug.o)</span><br><span class="line">  &quot;_ModPlug_GetCurrentPattern&quot;, referenced from:</span><br><span class="line">     _modplug_read_packet in libavformat.a(libmodplug.o)</span><br><span class="line">  &quot;_ModPlug_GetCurrentRow&quot;, referenced from:</span><br><span class="line">     _modplug_read_packet in libavformat.a(libmodplug.o)</span><br><span class="line">  &quot;_ModPlug_GetCurrentSpeed&quot;, referenced from:</span><br><span class="line">     _modplug_read_packet in libavformat.a(libmodplug.o)</span><br><span class="line">  &quot;_ModPlug_GetCurrentTempo&quot;, referenced from:</span><br><span class="line">     _modplug_read_packet in libavformat.a(libmodplug.o)</span><br><span class="line">  &quot;_ModPlug_GetLength&quot;, referenced from:</span><br><span class="line">     _modplug_read_header in libavformat.a(libmodplug.o)</span><br><span class="line">  &quot;_ModPlug_GetMessage&quot;, referenced from:</span><br><span class="line">     _modplug_read_header in libavformat.a(libmodplug.o)</span><br><span class="line">  &quot;_ModPlug_GetName&quot;, referenced from:</span><br><span class="line">     _modplug_read_header in libavformat.a(libmodplug.o)</span><br></pre></td></tr></table></figure>
<p>各种方法都试了，in vain.最后哥们儿帮我找到了答案：</p>
<p>在 cmake 那步，改成：</p>
<p><code>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. -DWITH_FFMPEG=OFF</code></p>
<p>也就是最后添加了一个参数。什么意思呢？不知道。</p>
<p>参考：</p>
<ol>
<li><a href="http://docs.opencv.org/doc/tutorials/introduction/linux_install/linux_install.html#linux-installation" target="_blank" rel="external">Installation in Linux — OpenCV 2.4.8.0 documentation</a></li>
<li><a href="http://stackoverflow.com/questions/14517406/opencv-make-error" target="_blank" rel="external">c++ - openCV make error - Stack Overflow</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法笔记：三（大结局）]]></title>
      <url>http://codeinterviews.com/dsv-notes-3/</url>
      <content type="html"><![CDATA[<p><a href="http://zipperary.com/2014/01/04/dsv-notes/" target="_blank" rel="external">数据结构与算法笔记：一 | Zippera’s blog</a></p>
<p><a href="http://zipperary.com/2014/01/06/dsv-notes-2/" target="_blank" rel="external">数据结构与算法笔记：二 | Zippera’s blog</a></p>
<p><a href="http://zipperary.com/2014/02/23/dsv-notes-3/" target="_blank" rel="external">数据结构与算法笔记：三（大结局） | Zippera’s blog</a></p>
<hr>
<p>#Heap-like Data Structures</p>
<ul>
<li><p>Heaps：小顶堆（二叉树，完全树），每个节点都比它的左右子树小。按照层级从左到右插入节点，然后自下向上调整大小。删除最小值的时候，直接删除根节点（一直是最小的），然后把最后一个节点移到根节点，然后自顶向下调整大小。若给出一个已经建立好的完全树，想调整为堆，则需要自底向上、从右到左地逐层调整，调整时还需要考虑子树是否不再满足堆条件，if so，自顶向下调整。由于堆是一个按照层次编号的完全树，所以用一个数组作为数据结构。操作堆就是操作数组。</p>
</li>
<li><p>Binomial Queues：二项队列，也叫Binomial heap，是一种形状很有特点的树。首先要知道什么是二项树：如图为四个不同的二项树，其规律为：度数为k的二项树有一个根结点，根结点下有k个子女，每个子女分别是度数分别为k-1,k-2,…,2,1,0的二项树的根。度数为k的二项树共有2^{k}个结点，高度为k。在深度d处有<code>{\tbinom  nd}</code>（二项式系数）个结点。二项堆自然就是满足节点相对大小关系的二项树。二项堆的插入很简单，只需要新建一个节点，并合并。合并的对象只能是两个度相同的二项堆：比较二个根结点关键字的大小，其中含小关键字的结点成为结果树的根结点，另一棵树则变成结果树的子树。删除最小的节点就是删除根节点，根节点下的几个子树全部分开。二项堆在各类操作中时间复杂度都为O(logn)，可以说性能很好。其存储结构一般为链表。</p>
</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1edr9eqj7s2j20k009xgmb.jpg" alt=""></p>
<a id="more"></a>
<ul>
<li>Fibonacci Heaps：如图，斐波那契堆由这样一些小顶堆组成，其中每个节点ADT 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct FibonacciHeapNode &#123;</span><br><span class="line">       int key;       //结点</span><br><span class="line">       int degree;    //度</span><br><span class="line">       FibonacciHeapNode * left;  //左兄弟</span><br><span class="line">       FibonacciHeapNode * right; //右兄弟</span><br><span class="line">       FibonacciHeapNode * parent; //父结点</span><br><span class="line">       FibonacciHeapNode * child;  //第一个孩子结点</span><br><span class="line">       bool marked;           //是否被删除第1个孩子</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>并且用min 指向最小的根节点。每个节点有一个指针指向其一个子女，它的所有子女由双向循环链表连接，不同的小顶堆的根节点也是通过这种链表连接，叫做根表。</p>
<p>插入新元素时，只要将其作为单元素 F 堆，并跟原有堆合并，合并的方式是新 F 堆加入原 F 堆的根表中。</p>
<p>删除元素时，先把 min 指向的最小节点删除，然后将剩下的小顶堆分开，并按照二项堆组合的方式重新组合。</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1eduqnjhkqdj20du06074l.jpg" alt=""></p>
<ul>
<li>Leftist Heaps：左偏堆，每个节点除了有左右孩子和键值外，还有一个距离。什么是距离呢？ 引用维基百科的话：「当且仅当节点 i 的左子树且右子树为空时，节点被称作外节点（实际上保存在二叉树中的节点都是内节点，外节点是逻辑上存在而无需保存。把一颗二叉树补上全部的外节点，则称为extended binary tree）。节点 i 的距离是节点 i 到它的后代中的最近的外节点所经过的边数。特别的,如果节点 i 本身是外节点,则它的距离为 0;而空节点的距离规定为-1 。」如图。除了堆的性质外，还有一条「节点的左子节点的距离不小于右子节点的距离。」其插入删除等基本操作都是基于合并。怎样合并呢？找到 root 键值最小的那个，用其右子树与其他树合并，若右子树为空，把另外的树直接弄过来，若此时右子树距离比左子树大了，那就交换左右子树；若右子树不空，把右子树摘下来与其他树合并，如此递归进行。删除堆中最小值时，先删除它，再把遗留的几个子树按照前述方法合并。左偏堆合并操作的平摊时间复杂度为O(log n)。</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1edrakap9umj206203pweg.jpg" alt=""></p>
<ul>
<li>Skew Heaps：斜堆，上述左偏堆就是一种特殊的斜堆。斜堆没有距离的概念，其合并过程与左偏堆几乎一样，只是在每次合并之后都要左右子树互换一下（启发规则）。这样往往能导致最后形成的树中左子树比右子树深，所以是斜的。</li>
</ul>
<p>#Graph Algorithms</p>
<ul>
<li>Breadth-First Search：广度优先搜索。图可分为有向图和无向图（都可应用本算法），其表示形式有图形、邻接表、临界矩阵，注意图中 Parent 和 Visited 两个数组。</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1eds3ts9pxkj21140i476d.jpg" alt=""></p>
<ul>
<li><p>Depth-First Search：深度优先搜索，基本同上，除了搜索的顺序不同。搜索过程中会涉及到回溯问题，而回溯可以用栈这种数据结构，也可以用递归的这种运行形式。广度优先搜索则不会有回溯的情况。</p>
</li>
<li><p>Connected Components：连通分量，对于无向图，就是这样的一个子图：任意两个节点都可以路径可达，再加入该子图之外的节点后就不满足任意可达性了，所以也可以叫做最大连通子图。其实每个独立的无向图都是连通分量。还有一个叫强联通分量，是对应于有向图的，这时就不太容易寻找一个有向图的强连通分量了，因为要保证任意两个节点是互相可达的。Kosaraju算法、Tarjan算法、Gabow算法是目前比较有效的算法。DSV 中用的哪种，我还没看明白，等看完《算法概论》中介绍的那种再说。</p>
</li>
</ul>
<ul>
<li>Dijkstra’s Shortest Path：用于求解带权有向图（也可求无向图）的单源最短路径。如图，我们用这样一个表格来演示并记录。Vertex 表示图中的节点；Known 表示运行到目前为止，是否确定了该节点的最终最短路径，初始为 F（否）；Cost 表示目前为止从源节点到该节点的最短路径，初始为 INF（无穷大）； Path 是源点经过哪个节点到达的这个节点，初始为-1（无）。算法运行的过程：假设源点为2，此时2为 T，寻找2的直接邻节点，并更新 Cost（如果新 cost 比当前的小就更新，否则不更新），同时更新 Path 为2；然后，在所有F 的节点中，选择当前 Cost 最大的一个，标记为 T，这个节点的全局最短路径就确定下来了，以此作为中间节点，寻找其直接邻节点，并更新 Cost（注意，已经为 T 的不再更新）和 Path；如此循环，直到所有节点都为 T。</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eds5aom0dij20tq0dsq3w.jpg" alt=""></p>
<p>最终得到如下图所示的表格。接下来就是把 Path 表示出来。比如运行到7的时候，7的 path 是5，5的是6，6的是2，所以7的最终 path 是 2 6 5 7.</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eds6kkf9paj20an07iaa9.jpg" alt=""></p>
<ul>
<li><p>Prim’s Minimum Cost Spanning Tree：Prim 算法，对于给定的无向图，找出最小生成树。最小生成树就是包含图中所有节点和部分边是一个树，并且其权值之和最小。该算法的运行过程就是从源节点出发，选择权值最小的邻近节点，再以此为当前节点，选择未访问的权值最小的邻近节点，如此循环，若到头了，则回溯。总体来说是大 DFS 中包含着小 BFS。具体的运行过程可以使用Dijkstra算法中使用的表格形式。</p>
</li>
<li><p>Topological Sort (Using Indegree array)：对于一个DAG，一定存在拓扑排序，使得对于 uv,在拓扑排序中，u 一定在 v 前面。这里使用直观的Kahn算法：有两个集合，L 表示已经排好的，S 表示入度为0的节点；每次从 S 中取出一个节点 n 放入 L 中，并查看从 n 出发的节点中是否有入度减为0的，若有，加入到 S 中，然后再从 S 中取节点，循环。。。如果最后剩下边，说明该图是有环的，不存在拓扑序列，否则最后得到的 L 即拓扑序列。从算法的执行过程来看，它是基于队列的。</p>
</li>
<li><p>Topological Sort (Using DFS)：基于 DFS 的拓扑排序，这里 S 是所有<strong>出度</strong>为0的节点的集合。对于每个节点，递归访问以它为尾的所有节点，并标记为 Visited，并按照递归的退出顺序把节点加入到 L 中。这种方法其实也很直观，出度为0的节点，回溯到头一般就是入度为0的节点了。深度优先遍历会用到递归或栈。</p>
</li>
<li><p>Floyd-Warshall (all pairs shortest paths)：留着，太复杂了。</p>
</li>
<li><p>Kruskal Minimum Cost Spanning Tree Algorithm：Kruskal 算法，对于给定的无向图，找出最小生成树。其方法很简单，就是从所有边中，依次挑选最小的边形成树的一个边，加入到当前的树中，如果这个边使树成为图，就舍弃，寻找次最小的，直到所有的节点都进入这个树中。</p>
</li>
</ul>
<p>#Dynamic Programming</p>
<p>Calculating nth Fibonacci number，<br>Making Change，<br>Longest Common Subsequence：动态规划适用于有最优子结构和重叠子问题的问题。最优子结构是指局部最优解能决定全局最优解，这样我们才能把问题分解成子问题来解决。子问题重叠性质是指「在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。<br>」最常用的例子是斐波那契数列。其求解最常用的算法是如下递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fib(n)</span><br><span class="line">       if n = 0 or n = 1</span><br><span class="line">           return 1</span><br><span class="line">       return fib(n − 1) + fib(n − 2)</span><br></pre></td></tr></table></figure>
<p>虽然通过递归把问题分解为子问题了，但是，递归过程中很多子问题被重叠计算了，比如当n=5时，fib(5)的计算过程如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fib(5)</span><br><span class="line">fib(4) + fib(3)</span><br><span class="line">(fib(3) + fib(2)) + (fib(2) + fib(1))</span><br><span class="line">((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))</span><br><span class="line">(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))</span><br></pre></td></tr></table></figure>
<p>改进的方法是，我们可以通过保存已经算出的子问题的解来避免重复计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array map [0...n] = &#123; 0 =&gt; 0, 1 =&gt; 1 &#125;</span><br><span class="line">fib( n )</span><br><span class="line">    if ( map m does not contain key n)</span><br><span class="line">        m[n] := fib(n − 1) + fib(n − 2)</span><br><span class="line">    return m[n]</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>Disjoint Sets：并查集，也叫union-find algorithm，因为该数据结构上的主要操作是 find 和 union，还有一个基本的 makeset 操作。</li>
</ul>
<p>数据结构是一个树，每个节点除了有值外，还有一个指针指向父节点。一个树就是一个集合，树的根节点代表这个集合。由于只需要一个指针指向父节点，一般用一个数组表示这棵树。</p>
<p>数据结构说清楚了，接下来谈谈其操作。makeset 的作用是建立一个只含X 的集合。find 的作用是找到 X 的根节点，即找到 X 属于哪个集合。union 的作用是把 x 和 y 代表的集合合并。这三个操作的代码非常简单，但是得到的树会很高很偏，在之后的操作中效率就低了。对此有两种优化方法：路径压缩和按秩合并。下面给出最终代码，在注释处注明其改进：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MAX];<span class="comment">//用数组表示树，记录每个节点的父节点索引</span></span><br><span class="line"><span class="keyword">int</span> rank[MAX];<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化集合*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Make_Set</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    father[x] = x; <span class="comment">//只有一个元素的集合，父节点是自身，也可指定其他，如-1.</span></span><br><span class="line">    rank[x] = <span class="number">0</span>;   <span class="comment">//只有一个节点，秩（深度）为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找x元素所在的集合,回溯时压缩路径*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find_Set</span><span class="params">(<span class="keyword">int</span> x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != father[x])</span><br><span class="line">        &#123;</span><br><span class="line">            father[x] = Find_Set(father[x]); <span class="comment">//回溯时把中间经过的节点的父节点都指向根节点，使树扁平化，压缩路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按秩合并x,y所在的集合 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    x = Find_Set(x);</span><br><span class="line">    y = Find_Set(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;<span class="comment">//在一个集合中，不用合并</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &gt; rank[y])</span><br><span class="line">        &#123;</span><br><span class="line">            father[y] = x;<span class="comment">//总是把秩小的树的根节点指向较大的树的根节点，这样秩不会增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[x] == rank[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    rank[y]++;</span><br><span class="line">                &#125;</span><br><span class="line">            father[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考《<a href="http://www.cnblogs.com/cherish_yimi/archive/2009/10/11/1580839.html" target="_blank" rel="external">并查集–学习详解</a>》和《<a href="http://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="external">并查集 - 维基百科，自由的百科全书</a>》。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用采样方法]]></title>
      <url>http://codeinterviews.com/sampling-methods/</url>
      <content type="html"><![CDATA[<p>最近在学习 MCMC，一种特殊的采样方法，顺便把其他常用的方法了解了一下。</p>
<p>###为什么要采样？</p>
<p>很多问题，我们只需要使用数学解析的方法即可解决。例如对 f(x)做积分，如果 <code>f(x) = x^2</code>，那么直接积分就行，很简单。</p>
<p>若f(x)是标准正态分布的概率密度函数（pdf），求[a,b]之间的定积分，那么直接用数学解析方法就搞不定了，因为我们知道正态分布的积分是不可求的。既然无法用解析方法计算精确值，那么退而求其次，不妨寻找一种可以求得近似值的方法。例如：</p>
<p><code>f(x) = f(x) * g(x) * 1/g(x) = g(x) * (f(x) * 1/g(x))</code>。这里我们找到一个容易采样的 pdf g(x)，并对其采样得到{X1…Xn}。连续函数的积分就可以转化为离散值的求和。这被称为蒙特卡洛积分。</p>
<p>从上面例子可以看到，采样方法可以对诸如积分这种无法用解析方法求解的方法进行近似求解。接下来就是问题的核心：怎样采样？</p>
<p>###简单采样方法</p>
<p>最简单的抽样是均匀采样，也就是均匀产生[0,1]之间的随机数，编程语言中一般使用 rand()函数。之所以说是均匀采样，是因为这些样本服从均匀分布。随机数的产生，在计算机中一般通过线性同余的方法实现。</p>
<p>另外，一些简单的分布，如正态分布，也可以在均匀采样的基础上实现采样。</p>
<p>对于其他函数我们就无能为力了，只能通过一些高级点的方式进行采样。</p>
<p>###接受-拒绝采样</p>
<p>我们需要对一个分布π(x)进行采样，但是却很难直接进行采样，所以我们想通过另外一个容易采样的分布q(x)的样本，用某种机制去除掉一些样本，从而使得剩下的样本就是来自与所求分布f(x)的样本。</p>
<p>条件：</p>
<ul>
<li>对q(x)采样比较容易</li>
<li>q(x)的轮廓接近π(x)，且有 π(x)≤Mq(x),∀x</li>
</ul>
<p>过程：</p>
<ul>
<li>产生样本X~q(x)，和U~Uniform[0,1]</li>
<li>Y=U*Mq(x)，若Y≤π(X)，则接受X，否则拒绝。</li>
</ul>
<p>解释：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1edq3b3al1ij207z061wek.jpg" alt=""></p>
<ul>
<li>根据 q(x)采样 X，得到 Mq(X)，在[0,1]之间产生随机数U，也就是在[0,Mq(X)]产生随机数Y=U*Mq(x)。如果Y 在π(x)曲线下方，那么就选择接受，否则拒绝。为什么呢？在上图两个曲线相隔越远的地方，随机Y在π(x)下方的概率越小，即接受这个采样X的概率越小。这是合理的，这时候两个曲线间隔远， Mq(x)的采样X不能直接用于π(X)。反之，如果两个曲线相隔近，那么U越可能在π(X)下方，越可能接受这个采样，既然曲线相隔近，那么对Mq(x)的采样就可以近似对π(X)的采样了嘛！</li>
</ul>
<p>但是拒绝采样效率会比较低，因为有很多采样都拒绝了嘛！</p>
<p>###重要性采样</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1edq3njein6j20ab052dft.jpg" alt=""></p>
<p>如图，如果我们想求积分，也就是面积，且 f(x)不能求积分形式，一种方法就是在[a,b]间<strong>均匀</strong>采样N 个点，并用 f(Xi)乘以(b-a)/N 即宽度，累加求和就能得到近似的积分值。这里我们用的权重是相同的：(b-a)/N，就是说每个小矩形的宽度都是相等的。</p>
<p>但很多时候，曲线比较高的地方需要多采样并精确刻画，曲线低的地方可以少采样，这样能减小最后结果与真实值之间的误差。如下图：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1edq3v5oc42j20aj05iaa3.jpg" alt=""></p>
<p>我们采用与 f(x)类似的 g(x)来采样，g(x)如图中右上角所示。此时宽度怎么确定呢？宽度就是1/g(Xi)，这就能体现出不同点的权重不同了。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1edq40yum9vj205w00w743.jpg" alt=""></p>
<p>###MCMC采样</p>
<p>上述都是独立性采样，采样的效率还不高。MCMC 是一种关联采样，当前采样有赖于前一个采样结果。MCMC 的全程是马尔可夫蒙特卡罗。马尔可夫，是说前后两个采样结果的关联性。蒙特卡罗是一种随机模拟方法，用采样的方法解决解析问题，如前面提到的蒙特卡洛积分。</p>
<p>若想对π(x)进行采样，首先构建一个马尔可夫链，该马尔可夫链的状态转移矩阵满足特定条件时，会存在一个稳定状态，稳定分布就是π(x)。根据某定律，我们从某个状态出发，在马尔可夫链每步得到的分布中采样，得到 M 个样本，这些样本就近似服从π(x)。要想构建符合条件的状态转移矩阵并抽样，有两种方法：Metropolis-Hastings 算法和Gibbs Sampling方法。具体介绍可参考文末给出的链接。</p>
<p>参考：</p>
<p><a href="http://www.wuhaijia.com/wordpress/%E6%8E%A5%E5%8F%97-%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B7%EF%BC%88acceptance-rejection-sampling%EF%BC%89/" target="_blank" rel="external">http://www.wuhaijia.com/wordpress/%E6%8E%A5%E5%8F%97-%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B7%EF%BC%88acceptance-rejection-sampling%EF%BC%89/</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4e5740460100cw5b.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4e5740460100cw5b.html</a></p>
<p><a href="http://www.52nlp.cn/lda-math-mcmc-%E5%92%8C-gibbs-sampling2" target="_blank" rel="external">http://www.52nlp.cn/lda-math-mcmc-%E5%92%8C-gibbs-sampling2</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[中文分词之词性标注与关键词提取]]></title>
      <url>http://codeinterviews.com/posseg-and-key-words/</url>
      <content type="html"><![CDATA[<p>之前<a href="http://zipperary.com/2013/12/27/chinese-segmentation-3/" target="_blank" rel="external">发文</a>剖析了「结巴分词」中用「DAG」和「Viterbi」算法进行中文分词的两个方案。有了前面的基础，这里再来讨论词性标注（POS）与关键词提取。</p>
<p>###词性标注</p>
<p>如图，在 DAG分词时所用的 dict 里面含有词汇、词频和词性三个信息。所以，最简单的情况下，只需要在分词时查询 dict 记录下每个词的词性即可。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eby0f7c9a4j20v50h5ta6.jpg" alt=""></p>
<p>对于 dict 中没有给出 pos 信息，或者采用 Viterbi 算法对 OOV 做分词时，需要采用另外一种方法。这种方法本质上很简单，也是采用 Viterbi 算法，只是 model 稍微做些改变。</p>
<a id="more"></a>
<p>之前的文章介绍用 Viterbi 做中文分词时，我们指出观察空间为所有中文字组成的集合，状态空间为{B,E,M,S}，并给出了三个先验的概率表：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ebyo4y4cv1j20jo06nq3t.jpg" alt=""></p>
<p>这样，Viterbi 算法所基于的 HMM 模型就构建完全了，只需要执行 Viterbi 算法，就能计算出最可能的状态序列，并据此得到分词方案。</p>
<p>针对词性标注，我们对 HMM 模型稍作修改。观察空间不变；状态空间在前述基础上融入词性；初始状态分布表、状态转移概率表、发射概率表也做相应修改。如图所示：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ecwx8xf48pj20pd0bhq4c.jpg" alt="初始状态分布表"></p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ecwxacbb66j20pf0bgtak.jpg" alt="状态转移概率表"></p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ecwxbiko18j20b106rdgw.jpg" alt="发射概率表"></p>
<p>给定了新的 HMM 模型，再应用 Viterbi 算法，就能得到最可能的状态序列了。然后怎么做呢？</p>
<p>对上面得到的状态序列，从左到右扫描：如果是 E，则此时的 pos 即为 E 对应的 pos，此时的 word 为上一个 B 到该 E 之间的字组；如果是 S，则该字单独作为词，其对应的 pos 就是该词的 pos。在此过程中，分词和词性标注是同时完成的。</p>
<p>###关键词提取</p>
<p>在<a href="http://zipperary.com/2013/12/27/chinese-segmentation-2/" target="_blank" rel="external">《中文分词（二）》</a>中我提到过，生成 trie 时，顺便把 lfreq 转为 FREQ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FREQ = dict([(k,log(float(v)/total)) <span class="keyword">for</span> k,v <span class="keyword">in</span> FREQ.iteritems()]) <span class="comment">#normalize</span></span><br></pre></td></tr></table></figure>
<p>说道是为了「计算TF-IDF，以实现关键词提取的功能」。既然已经计算好了，要实现关键词提取就手到擒来了。在分词完成之后，对每个词汇，查询对应的TF-IDF值，并取出值最高的 k 个词汇即可。</p>
<p>TF-IDF的概念很简单，可参考阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="external">《TF-IDF与余弦相似性的应用（一）：自动提取关键词》</a>。</p>
<p>###多说一句</p>
<p>上述分词、词性标注和关键词提取，方法原理都很简单，在使用时，最关键的是 Model 的建立，如 dict.txt 和 HMM 模型中的那些表。这些东西可以通过语言学家们提供的现成的语料库获得，也可以自己通过现成的工具训练得到。算法是死的，个人改进的空间不太大，而先验数据是活的，大有提升的余地。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[认识布隆过滤器]]></title>
      <url>http://codeinterviews.com/bloom-filter/</url>
      <content type="html"><![CDATA[<p>去年学习爬虫的时候接触过这个概念，得知可以用来 url 查重。不过当时没有涉及这个问题，就搁置下了。前日又看到这个词，正好最近对各种 filter 有些兴趣，索性 break 一下。</p>
<p>所谓 Bloom filter，实际上就是1个数组加上 k 个 hash function组成的一个数据结构.Bloom 是该数据结构的发明人，filter 表明这个数据结构是个过滤器，可以对数据结构中的一部分内容进行操作。</p>
<p>首先给定一个 m 位的 bit 数组，每位取值0或1.初始设置为0.</p>
<p>再给定 k 个hash function，分别把元素a 映射到m 中的 k 个位置。</p>
<a id="more"></a>
<p><strong>插入元素 a：</strong>如上所述，把映射后的 k 个位置全部置1，已经为1的则保持不变。</p>
<p><strong>查询元素 a：</strong>同样地做上述映射，得到 k 个位置，只要有非0的，则说明元素 a 不存在。如果 k 个位置都是1，则说明有很大的概率证明 a 存在。为什么说不是百分百？因为k 个位置中的某一个1可能是元素 b 映射过来之后导致的。</p>
<p><strong>删除元素 a：</strong>No！Never！布隆过滤器中是不能删除元素的。把 a 映射后的 k 个位置置为0可不可以？Nope！因为这些位置不是 a 自己家的，而是全部元素共享的。</p>
<p>在爬虫程序中使用 bloom filter，每访问一个 url，用 bloom filter 看是否存在，if so，说明 url 重复，不需要再访问这个 url 了；if not,说明这个 url 是新的，那么访问该 url，并添加到 bloom filter.</p>
<p>值得指出的是，插入和查询的时间复杂度非常低，速度极快；由于并不存储 url，只是在固定大小的数组里面用组合信息来标志 url，所以空间也非常节省；至于天生存在的错误率，只要m、k、hash functions 设置合适，就能保证错误率在允许的范围内。例如 url 查重中，哪怕存在错误，最多也就多偶尔多访问一次，其弊端几乎可以忽略不计。</p>
<p>bloom filter 简单好用，很值得大家学习了解。另外 Python 中有 lib 可供使用。要让我自己从头设计一个很好的 bloom filter，还不会..</p>
<p>另外，stackoverflow 的一个帖子讨论了一些不常见但很好用的数据结构，推荐给各位： <a href="http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures" target="_blank" rel="external">http://stackoverflow.com/questions/500607/what-are-the-lesser-known-but-useful-data-structures</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解 MapReduce]]></title>
      <url>http://codeinterviews.com/matrix-multiply-with-hadoop/</url>
      <content type="html"><![CDATA[<p>所谓大数据时代，大数据带来了巨大的好处，也带来了巨大的挑战，其中之一就是大数据的存储和计算。如新浪微博的巨大用户群，若想用矩阵存储用户之间的关系，矩阵的大小是惊人的，不仅传统的存储方式不再适用，在进行一些矩阵运算（如乘法）时更是无能为力了，这时候就需要我们的 MapReduce 上场啦。</p>
<p>MapReduce 是 Google 提出的概念，由于论文中木有提到实现细节，大家只能根据论文所述理论自己实现了。其中最火的是当年雅虎牵头做的开源项目 Hadoop，目前已经得到了非常广泛的应用（如亚马逊、百度）。尽管有这么多顶尖人才在不断优化，但据说 Hadoop 的性能目前还不及 Google 的十分之一。Whatever，大家现在能用的只有 Hadoop 了，而且一般也够用了。</p>
<p>MapReduce 本质是上很简单，就是把原始问题分解成易解的小问题，分发给不同的节点（computer）进行处理，再收集处理后的结果，汇总运算一下，得到最终结果。像极了人工智能中的 And/Or。原理虽简单，MapReduce 的最大贡献还是在于 Scalability,Fault-tolerance 以及对并发和分布式的管理。</p>
<p>在 MapReduce 中，data（可以存储在文件系统，也可数据库） 被主节点计算机（master node） 分配给不同的子节点计算机(worker nodes)进行并行处理，这些 worker nodes 被称为 cluster 或 grid。</p>
<p>下面结合一个矩阵乘法的例子进行说明。</p>
<a id="more"></a>
<p>大矩阵直接存储在文件中不够灵活，而且大矩阵中一般都很稀疏（0元素很多），这样比较浪费。一般的做法是用一个三元组来存储每一个元素。</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ecmdkso46aj202f00jgld.jpg" alt=""></p>
<p>表示第 i 行第 j 列的元素为 A。</p>
<p>有如下两个矩阵，我们想求矩阵的乘积：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ecmdmf49tkj209902xq2w.jpg" alt=""></p>
<p>则用上述方法表示两个矩阵：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ecmdohcuhaj206l0cw0t3.jpg" alt=""></p>
<p>矩阵乘法的计算过程很简单，只需要把对应的行列求内积，最后得到一个4行2列的矩阵C。</p>
<p>通过计算过程可以看出，C 中各元素的计算是独立的互不干扰的。这样，我们在Map阶段，就可以把 Cij计算所需要的元素都集中到同一个key（i,j）中，然后，在Reduce阶段就可以从中解析出各个元素来计算。</p>
<p>同时注意到，Aij 会被C 中多个元素的计算用到，所以在 Map 阶段，也要把一个 Aij存储成多个键值对，以备稍后根据不同的键值划分给不同的 reducer 来处理。</p>
<p>处理流程如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ecmdvp19d5j20oz0ergpo.jpg" alt=""></p>
<p>其中 shuffle 阶段是 Hadoop 自动完成的；Map 和 Reduce 需要用户自己写代码。上图所示很明晰，不再解释了。</p>
<p>在<a href="http://en.wikipedia.org/wiki/MapReduce" target="_blank" rel="external">wiki</a> 中有更加正式的流程定义，同时有另外几个例子，等我理解后再发文分享吧。</p>
<p>欢迎有兴趣者一起交流！</p>
<p><em>参考：<a href="http://blog.csdn.net/xyilu/article/details/9066973" target="_blank" rel="external">http://blog.csdn.net/xyilu/article/details/9066973</a></em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[熵与分类]]></title>
      <url>http://codeinterviews.com/entropy-and-classification/</url>
      <content type="html"><![CDATA[<p>「熵」这个字，又难念又难记更难理解。「人工智能」课中学习「决策树」时用信息熵增益作为属性的优劣判断标准。下面结合这门课里所学的内容，简单地讲解一下什么叫做熵。</p>
<p>这里，我们把「熵」的概念局限在「信息论」领域里，物理学中所说的熵其实也类似，我们不加考虑。</p>
<p>熵，表征的是状态的混乱程度，或者说是信息的不确定性。熵的值越大，信息的不确定性越大。如等概率的时候熵最大，为1，为什么呢，既然选择 a 和选择 b 是等概率的，就相当于没有一点有用的信息，跟透支骰子似的；如果 a 的概率大一点，b 的小一点，说明我们的信息是有用的，不再是完全随机了，这时候熵就会小点，即不确定性就会小点。</p>
<a id="more"></a>
<p>下面给出熵的计算公式，很简单：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1echzyug87zj207g01ljr9.jpg" alt=""></p>
<p>其中 S 是一个数据集，这些数据一共分为 m 类。Pi 为每个类别的数据个数/S 中总的数据个数，即比例。熵是一个介于0和1之间的数。</p>
<p>什么意思呢？我们来举例说明。</p>
<p>e.g.S={a,b,c,d}，其中 a,b 属于类1，c,d 属于类2。则，这时候的熵：</p>
<p>Entropy(S)=- 2/4 <em>log(2/4) - 2/4 </em> log(2/4) =1/2 + 1/2 = 1.</p>
<p>可见这时熵为1，即不确定性最大。什么叫不确定性大呢？就是说这个数据集的数据是均匀的，越均匀代表信息越少，选任何一个的概率都是相等的。就像掷骰子，我们要预测投出的骰子点数，根本没法预测，因为六种点数的概率是一样的，这就是很大的不确定性。与此相反，如果数据集中只有一个类别，即每个数据属于这个类别的概率为1，这时候熵是多少呢？简单计算一下就知道，熵是0.概率为1，就是百分百地确定它属于这个类别，可见这时候的不确定性是最小的，为0.</p>
<p>熵的这个特性，可以用于分类问题。</p>
<p>e.g.若想购买商品，有这样几个属性可以考虑：喜欢程度、价格、替代物和是否急用。那么优先选用哪个属性判断是否购买呢？（亦即分为两类：买和不买）</p>
<p>给定一个训练数据集，如图：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eck1xv1yt8j20nw0di40u.jpg" alt=""></p>
<p>最好的属性，要有最好的分类能力。怎么说呢？如果对于价格来说，价格高就不买，价格低就买，确定性很高，价格的属性值就能把数据正确的分为两类，这就是好的属性。如果价格高时，买和不买的概率都是0.5，价格低时，买和不买的概率也都是0.5，那么这个属性根本没有任何区分力，应该丢弃不用。</p>
<p>我们用信息增益来表示某个属性对数据的分类能力。</p>
<p>首先，用属性 A 分类 S 后，熵为：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1eck24dcvvhj20b501w0sp.jpg" alt=""></p>
<p>信息增益，即：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1eck255455wj20be01oq2v.jpg" alt=""></p>
<p>即不确定性的减少量，或确定性的增加程度。</p>
<p>对于上例来说，我们计算一下「急用」的信息增益：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1eck2777ogtj20dt09dmxy.jpg" alt=""></p>
<p>类似地，可以计算其他属性的信息增益，选择增益最大的属性作为首选属性。</p>
<p>用这种方式设计的分类器叫做基于信息增益的决策树，也就是大名鼎鼎的 ID3.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[协方差矩阵的实例与意义]]></title>
      <url>http://codeinterviews.com/covariance/</url>
      <content type="html"><![CDATA[<p>在机器学习中经常需要计算协方差矩阵，本科时没学过这个概念，一直对此非常头疼。现在试图通过实例的计算、图形化的表示来梳理一下什么是协方差矩阵。</p>
<p>###A numerical example</p>
<p>问题：</p>
<p>有一组数据（如下），分别为二维向量，这四个数据对应的协方差矩阵是多少？</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1echx7v33n4j20a500tq2s.jpg" alt=""></p>
<p>解答：</p>
<p>由于数据是二维的，所以协方差矩阵是一个2*2的矩阵，矩阵的每个元素为：</p>
<p>元素(i,j) = (第 i 维所有元素 - 第 i 维的均值) * (第 j 维所有元素 - 第 j 维的均值)  。</p>
<p>其中「*」代表向量内积符号，即两个向量求内积，对应元素相乘之后再累加。</p>
<p>我们首先列出第一维：</p>
<p>D1: (1,3,4,5)  均值：3.25<br>D2: (2,6,2,2)  均值：3</p>
<p>下面计算协方差矩阵第(1,2)个元素：</p>
<p>元素(1,2)=(1-3.25,3-3.25,4-3.25,5-3.25)*(2-3,6-3,2-3,2-3)=-1</p>
<p>类似的，我们可以把2*2个元素都计算出来：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1echxl3524yj20gn04g0t5.jpg" alt=""></p>
<p>这个题目的最终结果就是：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1echxmbd27vj203e01pgle.jpg" alt=""></p>
<a id="more"></a>
<p>###An explanation</p>
<p>我们来分析一下上面的例子。首先看一下元素(1,1)的计算过程：</p>
<p>把所有数据的第一个维度拿出来，求出均值，之后的求解过程完全是我们熟悉的「方差」的求法。也就是说，这完完全全就是在求所有数据第一维元素（共4个）的方差（8.75）嘛。类似地，元素(2,2)求的是第二维(共4个)元素的方差（12）。</p>
<p>再来看元素(1,2)，这分明就是我们高数里面学的求 x 和 y 的协方差，不再单独计算某一维度的分散程度，而是把两个维度的分散值结合起来，这里才真正体现了「协方差矩阵」中「协方差」的意味。从计算过程和计算结果都能看出，元素(2,1)与元素(1,2)是一样的。也就是说，所有协方差矩阵都是一个对称阵。</p>
<p>总结一下协方差矩阵的特点：</p>
<ul>
<li>对角线元素(i,i)为数据第 i 维的方差。</li>
<li>非对角线元素(i,j)为第 i 维和第 j 维的协方差。</li>
<li>协方差矩阵是对称阵。</li>
</ul>
<p>现在只需要了解这些就够了。</p>
<p>###A vivid reprensatation</p>
<p>这里借鉴一下模式识别课件中的五个图来形象地展示一下不同的协方差矩阵代表了什么。这几个都是二维的高斯分布（正态分布），每个例子中有三个分布，分别给出了均值和协方差矩阵。均值代表正态分布的中心点，方差代表其分布的形状（黑色的分割线请 ignore）。请欣赏：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1echy74l0twj20i20k9ac3.jpg" alt="1.三个协方差矩阵相同，都为对角阵，对角线元素相同"></p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1echy88m4cej20i20ll0un.jpg" alt="2.三个协方差矩阵相同，都为对角阵，对角线元素不同"></p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1echy90c82tj20i00lf76c.jpg" alt="3.三个协方差矩阵相同，不是对角阵，对角线元素不同"></p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1echya36p9xj20i00jwq4u.jpg" alt="4.三个协方差矩阵不同，都是对角阵，对角线元素相同"></p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1echyb84lpbj20hx0izgnf.jpg" alt="5.三个协方差矩阵不同，不是对角阵，对角线元素不同"></p>
<p>从这五个图可以看出：</p>
<ul>
<li>均值为分布的中心点位置。</li>
<li>对角线元素决定了分布图形是圆还是扁。</li>
<li>非对角线元素决定了分布图形的轴向（扁的方向）。</li>
</ul>
<p><em>参考：<a href="http://blog.csdn.net/ybdesire/article/details/6270328" target="_blank" rel="external">http://blog.csdn.net/ybdesire/article/details/6270328</a></em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[机器学习资料推荐]]></title>
      <url>http://codeinterviews.com/materials-for-ml/</url>
      <content type="html"><![CDATA[<p>最近高强度学习人工智能和模式识别，一肚子，不，一脑子的东西想写出来分享，但由于公式太多，写一篇需要很多时间，下周就要考试了，我还是多多学习好了。今天再偷懒下，把我Chrome机器学习书签夹中的一些资料拿来分享下。</p>
<ul>
<li><p><a href="http://suanfazu.com/discussion/109/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E4%B9%A6%E7%B1%8D" target="_blank" rel="external">机器学习经典书籍 - 算法组</a>：给出了一些经典书籍，并附有 pdf 链接，值得参考并下载。</p>
</li>
<li><p><a href="http://www.youku.com/playlist_show/id_21508721.html" target="_blank" rel="external">吴立德 《深度学习课程》 - 专辑 - 优酷视频</a>：几个视频，专门讲解深度学习的，收藏了还没看，看过的可以反馈下。</p>
</li>
<li><p><a href="http://deeplearning.stanford.edu/wiki/index.php/UFLDL%E6%95%99%E7%A8%8B" target="_blank" rel="external">UFLDL教程 - Ufldl</a>：Ng 的 wiki 项目，有中文翻译，致力于深度学习的方方面面，从神经网络基础概念讲起，非常推荐。</p>
</li>
<li><p>Python 包：Scipy项目下的所有包、sklearn。 这里能找到更多的可用包，不限于 python <a href="http://mloss.org/software/" target="_blank" rel="external">mloss | All entries</a>。</p>
</li>
<li><p><a href="http://blog.csdn.net/abcjennifer/article/details/7691571" target="_blank" rel="external">Stanford机器学习—第一讲. Linear Regression with one variable - Rachel Zhang的专栏 - 博客频道 - CSDN.NET</a>：这个系列是 Ng 在 coursera 机器学习课程的笔记，我看完视频后照这个重新整理了笔记，非常推荐。</p>
</li>
<li><p><a href="http://v.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程<em>全20集</em>网易公开课</a>：这里有<a href="http://pan.baidu.com/s/1i3DQN3J" target="_blank" rel="external">讲义</a>。涉及到 ML 的方方面面，讲的很细致，唯一的缺点是 Ng 讲英语口齿不清。我也在学习中，强烈推荐！ 初学者可以先看他在 coursera 上的 ML 课，内容少，讲的更加浅显易懂，下载版请转<a href="http://pan.baidu.com/s/1pJPjRGR" target="_blank" rel="external">百度网盘</a>。</p>
</li>
<li><p><a href="http://blog.pluskid.org/?cat=4" target="_blank" rel="external">Machine Learning « Free Mind</a>：这位是大牛，我们 google 机器学习的相关知识，经常会走到他的博客里来，讲的实在太好了。</p>
</li>
<li><p><a href="http://machinelearningmastery.com/self-study-guide-to-machine-learning/" target="_blank" rel="external">Self-Study Guide to Machine Learning | Machine Learning Mastery</a>：给 ML 学习者写的导航图。</p>
</li>
</ul>
<p>我承认这篇博客太没诚意了，内容少、缺乏整理，原谅我们老师吧，考试对学习和消化知识很有好处。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模式识别课思维导图]]></title>
      <url>http://codeinterviews.com/pr-mindmap/</url>
      <content type="html"><![CDATA[<p>仅仅是结构图，没有细部信息。首先copy 课件，画出英文的导图，然后逐条翻译（小伙伴的要求）。最后小伙伴对此进行了校正和着色，对比之下，我的初稿太土鳖了。</p>
<p>使用的软件的是 Mindjet MindManager14，导出为图片。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ecc7cdzpgej21kw1ri4d9.jpg" alt=""></p>
<a id="more"></a>
<p>补一刀：今早搜索下载并开始使用 Mindjet，学习的过程中发现一个有意思的事情。刚开始用最 intuitive 的方法一句一句copy、点击插入 branch，paste；发现 pdf 文字用矩形框选择比光标选择更快捷；发现插入子树和同级节点的快捷键；发现把 pdf 文字放入纯文本再逐条复制比较快；发现用 Sublime Text 比 记事本更好复制（三击鼠标）；发现直接在 Mindjet 的一个节点上 paste 自动添加为子节点；发现可以同时复制好几条，在节点上 paste，自动分条生成。搞定之后，style 不美观，心想应该有个类似「平衡」的功能，然后鼠标右击空白处，果然有。</p>
<p>学习的过程，如果加入 randomness（比如点错了，偶然发现某工功能），就可能在其中找到最优解，避免陷入局部最优。所以，学习东西的时候，要允许犯错、要敢于尝试。</p>
<p>知识和工具都是基于理性的，都是讲道理的。当你发现目前的方法有很多不便时，要想到应该有个方法已经解决了这个问题，然后寻找（比如 balance 功能）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法笔记：二]]></title>
      <url>http://codeinterviews.com/dsv-notes-2/</url>
      <content type="html"><![CDATA[<p><a href="http://zipperary.com/2014/01/04/dsv-notes/" target="_blank" rel="external">数据结构与算法笔记：一 | Zippera’s blog</a></p>
<p><a href="http://zipperary.com/2014/01/06/dsv-notes-2/" target="_blank" rel="external">数据结构与算法笔记：二 | Zippera’s blog</a></p>
<p><a href="http://zipperary.com/2014/02/23/dsv-notes-3/" target="_blank" rel="external">数据结构与算法笔记：三（大结局） | Zippera’s blog</a></p>
<hr>
<p>#Sorting</p>
<ul>
<li>Comparison Sorting<ul>
<li>Bubble Sort: 从头到尾，两两比较，若&gt;，则交换，再往后比较；实际上就是传递大个，从头往后，遇到大个就让大个往后走，直到最大的挪到最后面。然后从头开始第二遍，一直到倒数第二个…每一次遍历，确定队尾部分的一个元素。</li>
<li>Selection Sort: 有一个 min 指针，先指向第一个，然后依次与后面的比较，如果&gt;，则 min 挪到该出，再继续往后比较，直到最后，然后把 min 处和开始处交换，这样就得到了第一个最小的。第二次，从第二个开始，重复上述过程。每一次遍历，确定队首部分的一个元素。</li>
<li>Insertion Sort： 从头到尾，依次把当前元素插入到前面合适的位置，插入时从后往前比较，前面的部分已经有序，但不是最终结果。这样，走到最后，就排序成功了。</li>
<li>Shell Sort：希尔排序，第一次以 d1为步长对列表分段，每个片段里对应元组排序；第二次以 d2（&lt;d1）为步长…最后一次以1为步长。<a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科</a>的分组表示形式也很直观容易理解。</li>
<li>Merge Sort：归并排序，排序的操作为：1-2，3-4，1-4；5-6，7-8，5-8；1-8；9-10，11-12。。。也就是说，从左到右，把2个排好，再来2个，拍前4个；后面再找4个，像前面一样递归排序；然后合并这8个，再找8个，像前面一样递归排序。。。</li>
<li>Quck Sort：快速排序，稍微复杂，<a href="http://www.cnblogs.com/morewindows/archive/2011/08/13/2137415.html" target="_blank" rel="external">这篇文章</a>给出一个直观的描述，叫「挖坑填数+分治法」非常好。首先让 i 指向第一个，j 指向最后一个，挖走第一个数存在 X；从 j 开始向左找到一个小于 X 的数，挖走放在刚才的坑，形成新坑；从 i 开始向右找到一个大于 X 的数，挖走放在上一个坑，形成新坑，再从 j 开始向左找。。。直到i 和 j 相遇，把 X 放在最后一个坑中。这时左边都比 X 小，右边都比 X 大。这样，我们就用 X 把原问题划分了一下，左边和右边。第二次就用同样的方法分治 X 左边的和 X 右边的，用递归调用方法。如图：<br><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ecarl1m6b1j20n004jq4g.jpg" alt=""></li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>Bucket Sort：桶排序。先创建一个同样大小的数组，把待排序数组中的数 Hash（Open Hash） 到这个数组， 形成的新数组中从左到右是有序的，每个位置的链表也是有序的。第二步是从左到右遍历，把元素都放回去。这种方法特别快，但耗空间。截图如下，非常直观：<br><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ecarhr5uhej20s10himzp.jpg" alt="第一步进行中"><br><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1ecarjcexqcj20r30arjsl.jpg" alt="第二步进行中"></p>
</li>
<li><p>Counting Sort：计数排序，很有技巧很好玩。<a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260299.html" target="_blank" rel="external">这篇文章</a>讲的很好理解：整个过程分为拉选票和入桶两个过程。投票完毕是这样的：<br>待排数组[ 6 2 4 1 5 9 ]<br>票箱数组[ 4 1 2 0 3 5 ]<br>带排数组中每个元素，比如6，要拉票，所有小于我的都给我投票，所以一共4票。其他元素依次拉票，票箱数组显示了最终拉到的票数。第二步就是入桶：<br>入桶后 [ 1 2 4 5 6 9 ]<br>6有4票，入的是4号桶；2有1票，入的是1号桶，以此类推。<br>（有重复数字怎么处理，日后再研究）</p>
</li>
<li><p>Radix Sort：基数排序，按照个位数用上述计数排序方法（或其他稳定排序方法）排好，在此基础上按照十位数排序，依次类推。</p>
</li>
<li><p>Heap Sort：堆排序，利用小顶堆的特点进行排序。在堆调整的过程中同时对数组中的元素调整顺序。堆调整完毕，数组就排序完毕了。如图：<br><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ecasj4lkd4j20s80ba765.jpg" alt=""></p>
</li>
</ul>
<p>这阵子复习准备考试，时间比较紧，少写一点。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构与算法笔记：一]]></title>
      <url>http://codeinterviews.com/dsv-notes/</url>
      <content type="html"><![CDATA[<p><a href="http://zipperary.com/2014/01/04/dsv-notes/" target="_blank" rel="external">数据结构与算法笔记：一 | Zippera’s blog</a></p>
<p><a href="http://zipperary.com/2014/01/06/dsv-notes-2/" target="_blank" rel="external">数据结构与算法笔记：二 | Zippera’s blog</a></p>
<p><a href="http://zipperary.com/2014/02/23/dsv-notes-3/" target="_blank" rel="external">数据结构与算法笔记：三（大结局） | Zippera’s blog</a></p>
<hr>
<p>这两天在看一个很不错的资源，通过将常见的数据结构和算法可视化为动画或图画的形式，让学习者直观了解这些数据结构的结构形式与常用操作，以及常用算法的代码执行过程，非常受教。</p>
<p>这些知识大部分都有所涉猎或者在课堂上学过，但直观的观察执行过程有助于加深理解。这里简要做些笔记。打算先把内容都看完，然后写代码练习。</p>
<p>网站地址：<a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="external">http://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<a id="more"></a>
<p>###Basics</p>
<ul>
<li><p>Stack: Array Implementation： 数组从前往后插入，从后往前删除，用 top 指针指示栈顶（待插入位置）。</p>
</li>
<li><p>Stack: Linked List Implementation Top： 指针指向非空的链头元素，每次插入都从 top指向的链头位置插入，删除也是从链头。</p>
</li>
<li><p>Queues: Array Implementation： 数组，head 指向队首元素（在左边），tail 指向队尾元素后面的待插入位置（在右边），插入元素在 tail 处，删除元素在 head 处，两个指针都是从左往右走。</p>
</li>
<li><p>Queues: Linked List Implementation： head 指向队首元素（在左边），tail 指向队尾元素（在右边），从 tail 插入，从 head 删除。</p>
</li>
</ul>
<p>###Recursion</p>
<ul>
<li><p>Factorial： 求 n 的阶乘。函数if 分支给出分解终止条件；else 分支给出分解函数（自调用）和回溯（整合）的递推式。用 Python 写的。简单、经典。</p>
</li>
<li><p>Reversing a String： 翻转字符串。过程同上，关键是分解方案。</p>
</li>
<li><p>N-Queens Problem： n 阶皇后问题：给出 n*n 的棋盘，放上 n 个皇后，使得任意两个横着竖着斜着都不相邻。这个问题之所以用到递归，是因为在试探性（确定性试探，有固定顺序）地放置过程中，如果走入死胡同就需要回溯，倒退到之前的某一步。本质上是图的深度优先搜索策略。Python 代码有点复杂，需要研究并练习。</p>
</li>
</ul>
<p>###Indexing</p>
<ul>
<li><p>Binary Search Trees： 二叉查找树，简单好用。对于每一个节点，左子树任意节点都比他小，右大。中序遍历是一个升序序列。要会插入、删除和查找操作。复杂度为 O(h)。</p>
</li>
<li><p>AVL Trees (Balanced binary search trees)： 平衡二叉树，首先是二叉查找树，然后满足平衡条件。平衡就是说任意节点的左右子树深度不得超过1，否则就需要旋转变换。这里最重要的知识点就是在插入、删除时，不满足条件时需要进行旋转操作。有三种形式：左旋、右旋、双旋。插入和删除时的旋转是不同的。平衡，保证了树的查找深度可以更小。</p>
</li>
<li><p>Red-Black Trees： 红黑树，首先也是二叉查找树。然后根据一些规则，保证从跟节点，走到每个叶子节点，经过的黑色节点数相通。这也是保证「平衡」和较小深度的一种方法。<br>红黑树五个性质：1. 只有红黑。2. 根黑。 3. 叶（NULL）黑。 4. 红点黑儿子。5. 条条大路同黑数。<br>插入过程中，新插入的节点N总是红色的。然后根据其父亲节点P和叔父节点U的情况，进行适当的旋转和变色：P 红 N 红，右右，单旋；P 红 N 红，右左，双旋；P 红 U 红 N 红，黑色下沉一级。<br>删除时，先找到替换节点，直接替换，如果不满足结构，则调整。</p>
</li>
<li><p>Splay Trees： 伸展树，除了二叉查找树的性质，最新访问的节点总是调整到根节点处。这是基于查找的时间和空间局部性原理，可用于 cache。那么，关键之处就在调整了。三种：<br>zig-step: p为 root，只需简单旋转。<br>zig-zig step：有 g p n，且 p n 都是左或都是右，那么，先旋 g p，再旋 n。<br>zig-zag step: 有 g p n，且 p n 不同为左或右，那么先 n p，再 g。</p>
</li>
<li><p>Open Hash Tables (Closed Addressing)： 同一个位置上，用链表链接多个节点。对于 strings 的 hash，如’hello’，先32位0与’o’的 ascii 求和；结果左移四位，用0补齐；左数11-14位，与’0000’异或；结果与’l’的 ascii 求和…最后的结果，求出10进制，然后hash 到某位置。</p>
</li>
<li><p>Closed Hash Tables (Open Addressing)： 区别于上面那个，某位置被占后，不可再添加新的元素，应该用再探测法找到其他位置。再探测法包括：线性探测（依次往后找空位），二次探测（1，4，9…）和再 hash（用 hash2）。</p>
</li>
<li><p>Closed Hash Tables, using buckets： 每连续三个位置为一组（bucket），编号。hash 时，先 hash 到对应的组，如果第一个被占，则用第二个，否则第三个；如果三个都已经被占，则用最后面的额外 overflow 区。</p>
</li>
<li><p>B Trees： 就是有些书上说的 B-树，英文是 B-tree，是多路查找树，也是平衡树，用于磁盘之类的存储结构。B 树在数据结构一书中是着重学习过的，主要知识点是 m 阶B 树的性质、插入后的分裂操作和删除后的合并操作。</p>
</li>
<li><p>B+ Trees： 跟 B 树挺像，但有些不同：每层包括所有元素，每层的节点之间有链表链接，有更好的索引性能。在数据结构学习中，这种结构不是重点。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[中文分词（三）]]></title>
      <url>http://codeinterviews.com/chinese-segmentation-3/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="http://zipperary.com/2013/12/25/chinese-segmentation/" target="_blank" rel="external">《中文分词（一）》</a></li>
<li><a href="http://zipperary.com/2013/12/27/chinese-segmentation-2/" target="_blank" rel="external">《中文分词（二）》</a></li>
<li><a href="http://zipperary.com/2013/12/27/chinese-segmentation-3/" target="_blank" rel="external">《中文分词（三）》</a></li>
</ul>
<p>承接上文<a href="http://zipperary.com/2013/12/27/chinese-segmentation-2/" target="_blank" rel="external">《中文分词（二）》</a>，本篇是最后一篇，介绍使用基于 HMM 的 Viterbi 算法做中文分词。</p>
<p>###Viterbi 算法</p>
<p>了解 HMM（隐马尔可夫模型）的朋友都知道 HMM 这个模型可以用五元组表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（states，//状态空间</span><br><span class="line">observations，//观察空间</span><br><span class="line">start_probability，//状态的初始分布</span><br><span class="line">transition_probability，//状态的转移概率矩阵</span><br><span class="line">emission_probability）//状态产生观察的概率</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>举个例子：</p>
<p>『想象一个乡村诊所。村民有着非常理想化的特性，要么健康要么发烧。他们只有问诊所的医生的才能知道是否发烧。 聪明的医生通过询问病人的感觉诊断他们是否发烧。村民只回答他们感觉正常、头晕或冷。</p>
<p>假设一个病人每天来到诊所并告诉医生他的感觉。医生相信病人的健康状况如同一个离散马尔可夫链。病人的状态有两种“健康”和“发烧”，但医生不能直接观察到，这意味着状态对他是“隐含”的。每天病人会告诉医生自己有以下几种由他的健康状态决定的感觉的一种：正常、冷或头晕。这些是观察结果。 整个系统为一个隐马尔可夫模型(HMM)。</p>
<p>医生知道村民的总体健康状况，还知道发烧和没发烧的病人通常会抱怨什么症状。 换句话说，医生知道隐马尔可夫模型的参数。 』</p>
<p>这里给出该 HMM 的五元组值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">states = (<span class="string">'Healthy'</span>, <span class="string">'Fever'</span>)</span><br><span class="line"> </span><br><span class="line">observations = (<span class="string">'normal'</span>, <span class="string">'cold'</span>, <span class="string">'dizzy'</span>)</span><br><span class="line"> </span><br><span class="line">start_probability = &#123;<span class="string">'Healthy'</span>: <span class="number">0.6</span>, <span class="string">'Fever'</span>: <span class="number">0.4</span>&#125;</span><br><span class="line"> </span><br><span class="line">transition_probability = &#123;</span><br><span class="line">   <span class="string">'Healthy'</span> : &#123;<span class="string">'Healthy'</span>: <span class="number">0.7</span>, <span class="string">'Fever'</span>: <span class="number">0.3</span>&#125;,</span><br><span class="line">   <span class="string">'Fever'</span> : &#123;<span class="string">'Healthy'</span>: <span class="number">0.4</span>, <span class="string">'Fever'</span>: <span class="number">0.6</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">emission_probability = &#123;</span><br><span class="line">   <span class="string">'Healthy'</span> : &#123;<span class="string">'normal'</span>: <span class="number">0.5</span>, <span class="string">'cold'</span>: <span class="number">0.4</span>, <span class="string">'dizzy'</span>: <span class="number">0.1</span>&#125;,</span><br><span class="line">   <span class="string">'Fever'</span> : &#123;<span class="string">'normal'</span>: <span class="number">0.1</span>, <span class="string">'cold'</span>: <span class="number">0.3</span>, <span class="string">'dizzy'</span>: <span class="number">0.6</span>&#125;,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上述五元组及其含义，可以用下图形象表示：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1ebynhgilr0j20de0e5js4.jpg" alt=""></p>
<p>模型已经建立，那么问题来了：『病人连续三天看医生，医生发现第一天他感觉正常，第二天感觉冷，第三天感觉头晕。 于是医生产生了一个问题：怎样的健康状态序列最能够解释这些观察结果？』</p>
<p>实际上，在我之前的文章<a href="http://zipperary.com/2013/10/17/3-problems-in-hmm/" target="_blank" rel="external">《隐马尔可夫模型三个问题的求解(一)》</a>中就做过介绍，刚才提出的那个问题，正是 HMM 三大基本问题之一：根据观察序列，求隐藏状态序列。</p>
<p><strong>我们总结一下目前的已知条件和待求解问题：</strong></p>
<p>已知：观察结果 [‘normal’, ‘cold’, ‘dizzy’]  + 如图三个参数。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ebynmdilkcj20cn04lgm1.jpg" alt=""></p>
<p>求：最有可能由状态序列？ （如[‘Healthy’, ‘Healthy’, ‘Fever’]）</p>
<p>求解就用到了 Viterbi 算法，具体的过程请参考52NLP 的<a href="http://www.52nlp.cn/hmm-learn-best-practices-six-viterbi-algorithm-2" target="_blank" rel="external">文章</a>，讲的非常好。另外，刚才上面的例子，我借用的是<a href="http://zh.wikipedia.org/wiki/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科</a>。</p>
<p>到此，Viterbi 算法就能把隐藏状态序列求解出来了。</p>
<p>那么，怎样把这厮应用到中文分词呢？</p>
<p>###用 Viterbi 算法做中文分词</p>
<p>一切的算法应用问题，都是把现实问题抽象化，并向算法要解决的问题模型靠拢。</p>
<p>问题模型是什么？HMM。HMM有上面讲过的五个参数，我们要一一对应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（states，//状态空间：&#123;B,E,M,S&#125;，稍后介绍</span><br><span class="line">observations，//观察空间：所有汉字组成的集合。</span><br><span class="line">start_probability，//状态的初始分布</span><br><span class="line">transition_probability，//状态的转移概率矩阵</span><br><span class="line">emission_probability）//状态产生观察的概率</span><br></pre></td></tr></table></figure>
<p><strong>介绍下{B,E,M,S}：</strong></p>
<p>汉字按照BEMS四个状态来标记，分别代表 Begin End Middle 和 Single，比如：</p>
<p>北京（BE），中华民族（BMME），有意见分歧（SBEBE）</p>
<p>用这四个状态符号依次标记输入句子中的字，便可轻松得到分词方案。 如：</p>
<p>观察序列：我是一个中国人<br>状态序列：SSBEBME</p>
<p>对于上面的状态序列，根据简单的固定的规则进行组合划分，得到 S/S/BE/BEM/</p>
<p>对应于观察序列：我/是/一个/中国人/</p>
<p>分词任务就完成了。</p>
<p>而后面的三个参数，也可以通过对语料库的统计得到，比如结巴分词中给出的是：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ebyo4y4cv1j20jo06nq3t.jpg" alt=""></p>
<p>已知：观察序列S，初始状态概率prob_start，状态观察发射概率prob_emit，状态转换概率prob_trans。 求状态序列W。</p>
<p>用上面提到的 Viterbi 算法，可以求出 W，也就得到分词方案了。</p>
<p>至此，关于中文分词就介绍完了。有兴趣的同学欢迎交流。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[中文分词（二）]]></title>
      <url>http://codeinterviews.com/chinese-segmentation-2/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="http://zipperary.com/2013/12/25/chinese-segmentation/" target="_blank" rel="external">《中文分词（一）》</a></li>
<li><a href="http://zipperary.com/2013/12/27/chinese-segmentation-2/" target="_blank" rel="external">《中文分词（二）》</a></li>
<li><a href="http://zipperary.com/2013/12/27/chinese-segmentation-3/" target="_blank" rel="external">《中文分词（三）》</a></li>
</ul>
<p>接上文<a href="http://zipperary.com/2013/12/25/chinese-segmentation/" target="_blank" rel="external">《中文分词（一）》</a>继续介绍中文分词。</p>
<p>###Dict to Trie</p>
<p><strong>结巴分词源码中附带了一个 dict.txt 文件，是分词的基础：</strong></p>
<ul>
<li>2万多条词。</li>
<li>根据北大语料、人民日报1998 语料、小说（用张华平老师的ICTCLAS进行分词）得到。</li>
<li>可加入用户自定义词典。</li>
<li>无dict亦可，用HMM也可实现分词。</li>
</ul>
<p>dict.txt 的内容如图：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eby0f7c9a4j20v50h5ta6.jpg" alt=""></p>
<p>其中第一列是 word，第二列是词频，第三列是词性（pos）。</p>
<p><strong>什么是 Trie?</strong></p>
<p>Trie 又称前缀树或字典树，是一种数据结构，可以大大提高词典的查询速度。下图是一个简单的 Trie：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1eby0iikaeuj208a083jrk.jpg" alt=""></p>
<p>可以看到，不同的词汇中相通前缀共享同一个节点，如「阿根廷」和「阿胶」共享「阿」。这种结构可以缩短树的深度，因而检索可以非常快。</p>
<a id="more"></a>
<p>怎样用 Python 表示这种数据结构呢？我们用嵌套的 dict 类型：</p>
<p>下面是<code>foobar foobah fooxar foozap fooza</code>完全插入后的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;f&apos; =&gt; &#123;</span><br><span class="line">           &apos;o&apos; =&gt; &#123;</span><br><span class="line">                    &apos;o&apos; =&gt; &#123;</span><br><span class="line">                             &apos;b&apos; =&gt; &#123;</span><br><span class="line">                                      &apos;a&apos; =&gt; &#123;</span><br><span class="line">                                               &apos;h&apos; =&gt; &#123;</span><br><span class="line">                                                        &apos;&apos; =&gt; 1</span><br><span class="line">                                                      &#125;,</span><br><span class="line">                                               &apos;r&apos; =&gt; &#123;</span><br><span class="line">                                                        &apos;&apos; =&gt; 1</span><br><span class="line">                                                      &#125;</span><br><span class="line">                                             &#125;</span><br><span class="line">                                    &#125;,</span><br><span class="line">                             &apos;x&apos; =&gt; &#123;</span><br><span class="line">                                      &apos;a&apos; =&gt; &#123;</span><br><span class="line">                                               &apos;r&apos; =&gt; &#123;</span><br><span class="line">                                                        &apos;&apos; =&gt; 1</span><br><span class="line">                                                      &#125;</span><br><span class="line">                                             &#125;</span><br><span class="line">                                    &#125;,</span><br><span class="line">                             &apos;z&apos; =&gt; &#123;</span><br><span class="line">                                      &apos;a&apos; =&gt; &#123;</span><br><span class="line">                                               &apos;&apos; =&gt; 1,</span><br><span class="line">                                               &apos;p&apos; =&gt; &#123;</span><br><span class="line">                                                        &apos;&apos; =&gt; 1</span><br><span class="line">                                                      &#125;</span><br><span class="line">                                             &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这一个步骤的目的就是将 dict.txt 转换为一个 trie 结构的对象，方面之后的查询。在 Python 中，用这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_trie</span><span class="params">(f_name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> trie, lfreq,ltotal</span><br></pre></td></tr></table></figure>
<p>输入参数是 dict.txt 文件，输出一个 trie 对象，一个 lfreq记录每个词的词频，一个 ltotal 记录总共的词数。我们还要将 lfreq 转为 FREQ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FREQ = dict([(k,log(float(v)/total)) <span class="keyword">for</span> k,v <span class="keyword">in</span> FREQ.iteritems()]) <span class="comment">#normalize</span></span><br></pre></td></tr></table></figure>
<p>有两个好处：</p>
<ol>
<li>方便之后计算TF-IDF，以实现关键词提取的功能。</li>
<li>P(x)P(y) =&gt; logP(x) + logP(y)  #避免浮点下溢</li>
</ol>
<p>###文本预处理</p>
<p>就是用正则表达式，将输入的 text，根据标点符号等，切分为由中文、英文、数字和几个特殊符号组成的短语：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re_han = re.compile(<span class="string">ur"([\u4E00-\u9FA5a-zA-Z0-9+#&amp;\._]+)"</span>, re.U)</span><br></pre></td></tr></table></figure>
<p>例如 <code>“这是一个伸手不见五指的黑夜。我叫孙悟空，我爱北京，我爱Python和C++。”</code>经过这个步骤就切分为：<code>这是一个伸手不见五指的黑夜/我叫孙悟空/我爱北京/我爱Python和C++/</code>。</p>
<p>###短语的词图扫描</p>
<p>对于短语<code>我们都是中国人</code>，先从0依次编号为0-6.从左到右，依次查 trie，如「我」在 trie 中，则标记一下，「我们」也在 trie 中，再标记，「我们都」不在 trie 中，停止；得到0:[0,1]。然后从「们」开始，用同样的方式查询。最终得到的结果是：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1eby14xfnn7j20e1011wef.jpg" alt=""></p>
<p>这是一个图的邻接表表示形式，边的权重可以通过 FREQ 得到。只要我们求出图的最大概率路径，便得到了最佳切分方案。有两种方法：</p>
<ol>
<li>DAG的最短路径：Dijkstra算法。我们在大学时的数据结构中已经讲过。（注意我们要求的是最短路径，所以需要将原问题修改一下，w = -log W）</li>
<li>动态规划求最大概率路径。核心代码是这几行：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(sentence,DAG,idx,route)</span>:</span></span><br><span class="line">    N = len(sentence)</span><br><span class="line">    route[N] = (<span class="number">0.0</span>,<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> xrange(N<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        candidates = [ ( FREQ.get(sentence[idx:x+<span class="number">1</span>],min_freq) + route[x+<span class="number">1</span>][<span class="number">0</span>],x ) <span class="keyword">for</span> x <span class="keyword">in</span> DAG[idx] ]</span><br><span class="line">        route[idx] = max(candidates)</span><br></pre></td></tr></table></figure>
<p>这个要讲的话也颇费篇幅，简而言之就是从最右边（中文重心在句子尾部）开始，向左，依次计算到达每个节点（字）的最大局部概率，后者表示到达这个节点的最有路径的概率。</p>
<p>至此，基于 DAG 的中文分词算法就介绍完毕了。</p>
<p>预告：最后一篇介绍基于 HMM 的 Viterbi 算法做中文分词。        </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[中文分词（一）]]></title>
      <url>http://codeinterviews.com/chinese-segmentation/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="http://zipperary.com/2013/12/25/chinese-segmentation/" target="_blank" rel="external">《中文分词（一）》</a></li>
<li><a href="http://zipperary.com/2013/12/27/chinese-segmentation-2/" target="_blank" rel="external">《中文分词（二）》</a></li>
<li><a href="http://zipperary.com/2013/12/27/chinese-segmentation-3/" target="_blank" rel="external">《中文分词（三）》</a></li>
</ul>
<p>「中文分词」，要求是可以使用任何现有的资料，我们采用的是@TeapDB 的<strong>结巴分词</strong>，项目主页是：<a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">https://github.com/fxsjy/jieba</a> 。</p>
<p>今晚刚刚做完 presentation，不知不觉在台上扯了四十分钟，在空调吹暖气烤的屋里出了一身的汗。汗还没干，把内容整理一下：</p>
<p>###为什么要进行中文分词？</p>
<ul>
<li><p>词是最小的能够独立活动的有意义的语言成分。</p>
</li>
<li><p>汉语是以字为基本的书写单位，词语之间没有明显的区分标记。</p>
</li>
<li><p>正确分词是中文信息处理的基础与关键。</p>
</li>
</ul>
<p>###中文分词的难点</p>
<ol>
<li><p>交集型歧义：<br>结婚的和尚未结婚的   =&gt;<br>结婚／的／和／尚未／结婚／的<br>结婚／的／和尚／未／结婚／的  </p>
</li>
<li><p>OOV(Out of Vocabulary)识别：<br>云计算、创新办、好用</p>
</li>
</ol>
<a id="more"></a>
<p>###基于规则的分词：最大匹配</p>
<p>e.g. “南京市长江大桥”</p>
<p>词典的最大词长是5</p>
<p><strong>正向最大匹配：</strong>从左向右，依次扫描。比如”南”，扫描前5个，”南京市长江”，词典中并没有这个词；扫描前4个，”南京市长”，词典中有这个词，Okay。然后从”江”开始，后面一共就剩3个了，但词典中木有，那么缩短，”江大”，也木有，只能是”江”了。依次继续，可以得到”大桥”。最后我们就得到了按照正向最大匹配得到的词序：</p>
<p>南京市长/江/大桥</p>
<p><strong>逆向最大匹配：</strong>我们都知道，中文的重心一般在后面，所以按照从右向左的扫描方式，取得的效果会更好一些。分词的方式跟上面是一样的，除了扫描顺序。最后得到的词序是：</p>
<p>南京市/长江大桥</p>
<p>###基于统计的分词</p>
<ol>
<li>基于 DAG(有向无环图)和 Dict(词典)的中文分词。</li>
<li>基于HMM的 Viterbi 算法</li>
</ol>
<p>结巴分词正是使用这种思想。该分词程序的<strong>主要功能</strong>有：</p>
<ul>
<li><strong>分词</strong></li>
<li>关键词提取：TF/IDF</li>
<li>词性标注（pos）</li>
<li>Tokenize：返回词语在原文的起始位置</li>
</ul>
<p><strong>代码</strong>有：</p>
<ul>
<li>Python 版，作者所写</li>
<li>C++</li>
<li>Java</li>
</ul>
<p>后两种为其他人做的 commit。</p>
<p>程序的<strong>性能</strong>：</p>
<ul>
<li>1.5 MB / Second in Full Mode</li>
<li>400 KB / Second in Default Mode</li>
<li>Test Env: Intel(R) Core(TM) i7-2600 CPU @ 3.4GHz；《围城》.txt</li>
</ul>
<p>###演示</p>
<p>输入文本： “这是一个伸手不见五指的黑夜。我叫孙悟空，我爱北京，我爱Python和C++。”</p>
<p>程序执行结果：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1ebw9jdi6mjj20k00egwg1.jpg" alt=""></p>
<p>###基于 DAG 和 Dict 的中文分词</p>
<p>分词步骤：</p>
<ol>
<li>根据 dict 生成 trie，提高词典查询速度</li>
<li>文本预处理，生成中文短语</li>
<li>生成词图（DAG），并求最大概率路径</li>
</ol>
<p><em>附我 Presentation 的 ppt： <a href="http://pan.baidu.com/s/1jG1DcFk" target="_blank" rel="external">点我下载</a></em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bag of Words]]></title>
      <url>http://codeinterviews.com/bow/</url>
      <content type="html"><![CDATA[<p>Bag of Words，即词袋模型，是对样本数据的一种表示方法，主要应用在 NLP(自然语言处理)和 IR(信息检索)领域，近年也开始在 CV（计算机视觉）发挥作用。</p>
<p>###模型假设</p>
<p>该模型在表示样本数据时，通过如下假设对模型进行简化：一个文本或文档可以看作一袋子的单词，而不考虑其语法和词序关系，每个词都是独立的（有点 unigram 的赶脚）。</p>
<p>###示例</p>
<p>有这样两个简单的文本文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">John likes to watch movies. Mary likes too.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">John also likes to watch football games.</span><br></pre></td></tr></table></figure>
<p>对上述两个文档构造词典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;John&quot;: 1,</span><br><span class="line">    &quot;likes&quot;: 2,</span><br><span class="line">    &quot;to&quot;: 3,</span><br><span class="line">    &quot;watch&quot;: 4,</span><br><span class="line">    &quot;movies&quot;: 5,</span><br><span class="line">    &quot;also&quot;: 6,</span><br><span class="line">    &quot;football&quot;: 7,</span><br><span class="line">    &quot;games&quot;: 8,</span><br><span class="line">    &quot;Mary&quot;: 9,</span><br><span class="line">    &quot;too&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>词典中共有10个词项，每个词项后面是序号。那么，我们可以用一个向量表示一个文本文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 1, 1, 1, 0, 0, 0, 1, 1]</span><br><span class="line">[1, 1, 1, 1, 0, 1, 1, 1, 0, 0]</span><br></pre></td></tr></table></figure>
<p>上面的这个矩阵图形式的表示，就是词袋模型了，其中每个分量表示该词项在该文档中的出现次数。可以看到，词序的信息已经丢失，每个文档只看做一些单独词项的集合。</p>
<p>顺便说一下，矩阵图中的每一项，不仅可以用词典频数表示，一个更常用的方法是用<a href="http://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank" rel="external">tf-idf</a>表示词项的权重。</p>
<a id="more"></a>
<p>###应用举例</p>
<p>一个常见的应用是基于此模型做邮件过滤，也就是对邮件分类为 Spam(垃圾邮件)和 Ham(保留邮件)。我们知道垃圾邮件中经常会出现的一些词，比如”stock”, “Viagra”,  “buy”，那么就可以利用这个特点进行分类了。具体的分类方法是使用<a href="http://en.wikipedia.org/wiki/Bayesian_probability" target="_blank" rel="external">贝叶斯规则</a>。</p>
<p>另外，还可以用于图片的分类：</p>
<p>一个图片由若干个 local features（或叫做 patchs）表示，用 Kmeans 方法把相似的 patchs 聚类，每个聚类找出一个代表性的 patch，叫做 codeword，类比于 NLP 中的 word；同样的，图片就类比文本文档。用每个图片得到的 codeword 构建词典，叫做 codebook，类比 NLP 中的词典。这样，每个图片就可以用视觉词袋模型，以同维向量的形式表示出来。之后便可以使用 svm 等方法进行分类。</p>
<p>###后记</p>
<p>BOW 是一个非常常见的概念，名字略古怪，实际上很贴切，也很简单。上面我大概翻译了一下Wikipedia中的解释，有兴趣的同学可以点击原文查看，英文的表达似乎更容易理解。对 CV 中 BOW 感兴趣的同学，可以点击后面的那个链接。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Bag-of-words_model" target="_blank" rel="external">Bag-of-words model - Wikipedia, the free encyclopedia</a></li>
<li><a href="http://en.wikipedia.org/wiki/Bag-of-words_model_in_computer_vision" target="_blank" rel="external">Bag-of-words model in computer vision - Wikipedia, the free encyclopedia</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Learn Git]]></title>
      <url>http://codeinterviews.com/learn-git/</url>
      <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1eazklpf90uj20l80fbgoc.jpg" alt=""></p>
<p>Git 几乎是程序员的标配和必备技能，但繁复的命令让人头疼，也吓跑了不少希望学习的小孩。今天看到一个很不错的教程，来自于鼎鼎有名的 CodeSchool，让用户在线跟着教程一步一步边学习边练习。</p>
<p>教程的地址在<a href="http://try.github.io/levels/1/challenges/1" target="_blank" rel="external">这里</a>。虽然是全英文的，但几乎可以无障碍理解。</p>
<a id="more"></a>
<p>下面是我的学习总结：</p>
<p>一、基本流程</p>
<ol>
<li><code>git init</code>在本地文件夹建立一个 repo，并做一些初始化配置。</li>
<li><p><code>git add [file1]</code>or<code>git add .</code>or<code>git rm [file2]</code>在本地文件夹加入或删除文件后，需要用这些命令更新 staged area。后者临时保存用户所提交的更改（如 add/rm），以备下一步的 commit。  </p>
<p>Advice:</p>
<p><code>git reset [file1]</code>可以把 staged area 中所保存的 file1的更新信息删除，恢复之前的样子。</p>
</li>
<li><p><code>git commit -m &#39;added file1&#39;</code>把上一步 staged area 中所保存的更改进行整理，更新本地的 repo（准确的说，是本地 repo 的 master 分支），以备后面的 push。</p>
<p>Advice:</p>
<p><code>git checkout --[file1]</code>可以把本地 repo 中 file1的更新还原到之前的状态。</p>
</li>
<li><p><code>git remote add origin https://[服务器端 repo 地址]</code>添加服务器端的 repo 地址，取名为 origin（可以随便起名），以备稍后提交本地的 repo 到这个服务器端的 repo。</p>
</li>
<li><code>git push -u origin master</code>把本地 repo 的 master 分支提交到刚才添加的那个服务器端分支 origin。<code>-u</code>表示记住后面的参数，以后 push 的时候直接用<code>git push</code>命令即可。</li>
</ol>
<p>至此，本地的 repo 已提交到服务器端。</p>
<p>二、分支</p>
<ol>
<li><code>git branch [newbranch]</code>上面说过，repo 里面默认的是 master 分支，这个命令可以创建其他分支。 <code>-d</code>可以用来删除某个分支。 这个分支可以用来修复 master 分支中代码的 bug，然后在 merge 到 master。</li>
<li><code>git checkout [newbranch]</code>切换到这个新的分支，然后就可以在这个分支下写代码改代码了。</li>
<li><code>git checkout master</code><br><code>git merge [newbranch]</code>切换回 master 分支，然后把刚才新分支对代码所做的更改 merge 进来。</li>
</ol>
<p>上述操作流程是多人合作写代码要使用的。各自先在小分支中修改，然后 merge 到主分支。 </p>
<p>三、 状态跟踪</p>
<ol>
<li><code>git status</code> 查看当前状态。</li>
<li><code>git log</code>查看更改记录。</li>
<li><code>git diff</code>查看更改前后的对比。</li>
</ol>
<p>上述三个可以随时用来查看状态，三个的区别，我还不是太懂。</p>
<p>四、资料推荐</p>
<ol>
<li><code>git</code>在命令行中使用这个命令可以获取相关的说明和帮助。</li>
<li><a href="http://git-scm.com/docs" target="_blank" rel="external">Git - Reference</a>参考手册性质的，可以随时用来查阅；还有CheatSheet可供下载，福利啊。</li>
<li><a href="http://git-scm.com/book" target="_blank" rel="external">Pro Git</a> 教程，全英文。想阅读中文版本，Come <a href="http://git-scm.com/book/zh" target="_blank" rel="external">here</a>。</li>
<li><a href="https://help.github.com/" target="_blank" rel="external">GitHub Help</a>Github提供，相当于一个 FAQs。</li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="external">图解Git</a>帮助你深刻理解这些命令，有图有真相。</li>
<li><a href="http://blog.xdite.net/posts/2013/11/22/opensource-cheatsheets?utm_campaign=Manong_Weekly_Issue_11&amp;utm_medium=EDM&amp;utm_source=Manong_Weekly" target="_blank" rel="external">寫給大學生的程式技能</a>今天看到的，一步步指导学习使用 github，非常 practical，via this, you can learn git &amp;&amp; github together.</li>
<li>If you are eager to learn more,click <a href="https://www.google.com/cse/publicurl?cx=014607101523563003145:y4ccw7deyqg" target="_blank" rel="external">here</a>.Besides,you can google other topics such as <code>Python</code> in my customized Google.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[托管博客到gitcafe]]></title>
      <url>http://codeinterviews.com/hexo-to-gitcafe/</url>
      <content type="html"><![CDATA[<p>前几天帮同学弄 hexo 博客，她的电脑是 windows，不支持 rsync 功能，只能托管到 github。但是代码提交上去之后，访问网址时总不显示最新更新的内容，尝试了所有能够想到的办法，狠命折腾了一番，仍无果（在论坛看到消息，github 最近被黑了）。昨日得朋友指点，gitcafe 好像也可以免费托管静态博客。今日 google 了一下，果然可以用。另外，刚刚知道这家网站是国内的，访问速度刷刷刷，比 github 快多了。</p>
<p>首先，在<a href="http://gitcafe.com/signup?invited_by=zippera" target="_blank" rel="external">gitcafe</a>注册并创建项目。与 github 类似，项目名和用户名要一致。(注意：要创建「公开项目」而不是「私有项目」)</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1eauweqii0lj209k03z3yl.jpg" alt=""></p>
<a id="more"></a>
<p>在<a href="https://gitcafe.com/account/public_keys" target="_blank" rel="external">SSH公钥管理</a>中，填写电脑上保存的公钥。从未设置过 SSH 的用户，可参考<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="external">这里</a>。</p>
<p>去<code>hexo\_config.yml</code>添加如下代码（用户名和项目名替换为自己的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: git@gitcafe.com:zippera/zippera.git</span><br><span class="line">  branch: gitcafe-pages</span><br></pre></td></tr></table></figure>
<p>保存之后，用<code>hexo d</code>上传到 gitcafe 即可。现在就可以通过<a href="http://zippera.gitcafe.com/" target="_blank" rel="external">http://zippera.gitcafe.com/</a>进行访问了。</p>
<p>如果需要绑定私有域名，可以参考<a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9" target="_blank" rel="external">这里</a>的说明。</p>
<p>比较推荐 windows 用户使用 gitcafe，速度很不错。</p>
<hr>
<p>###Mac tricks:更改文件的默认打开方式</p>
<p>在 Finder 中选中某文件，使用快捷键<code>⌘ + i</code>打开文件简介，在「打开方式」中选择相应的程序，然后选择「全部更改」即可。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[High 一下]]></title>
      <url>http://codeinterviews.com/give-it-a-high/</url>
      <content type="html"><![CDATA[<p>今天看酷壳耗子叔的文章时，不经意间又注意到页面右上角的「High一下」功能，玩心顿起，便连High 了好几下。想起中午曾得罪某伙伴，于是想在我的博客放上这个功能，给小伙伴 high 一下作为一个小小的道歉。Google 了一下，介绍此项的网页很少，但在有限的三两个页面里却可以看到其源码，实现起来还是很简单的。</p>
<p>对于 Hexo 用户，可以这样做：</p>
<p>在<code>Hexo/themes/light/layout/_partial/header.ejs</code>中的<code>&lt;ul&gt;</code>标签内部，增加一对<code>&lt;li&gt;</code>标签，并把如下内容拷贝进去：</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">title</span>=<span class="string">"把这个链接拖到你的Chrome收藏夹工具栏中"</span> <span class="attr">href</span>=<span class="string">'javascript:(function() &#123;</span><br><span class="line">	function c() &#123;</span><br><span class="line">		var e = document.createElement("link");</span><br><span class="line">		e.setAttribute("type", "text/css");</span><br><span class="line">		e.setAttribute("rel", "stylesheet");</span><br><span class="line">		e.setAttribute("href", f);</span><br><span class="line">		e.setAttribute("class", l);</span><br><span class="line">		document.body.appendChild(e)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function h() &#123;</span><br><span class="line">		var e = document.getElementsByClassName(l);</span><br><span class="line">		for (var t = 0; t &lt; e.length; t++) &#123;</span><br><span class="line">			document.body.removeChild(e[t])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function p() &#123;</span><br><span class="line">		var e = document.createElement("div");</span><br><span class="line">		e.setAttribute("class", a);</span><br><span class="line">		document.body.appendChild(e);</span><br><span class="line">		setTimeout(function() &#123;</span><br><span class="line">			document.body.removeChild(e)</span><br><span class="line">		&#125;, 100)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function d(e) &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			height : e.offsetHeight,</span><br><span class="line">			width : e.offsetWidth</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function v(i) &#123;</span><br><span class="line">		var s = d(i);</span><br><span class="line">		return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function m(e) &#123;</span><br><span class="line">		var t = e;</span><br><span class="line">		var n = 0;</span><br><span class="line">		while (!!t) &#123;</span><br><span class="line">			n += t.offsetTop;</span><br><span class="line">			t = t.offsetParent</span><br><span class="line">		&#125;</span><br><span class="line">		return n</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function g() &#123;</span><br><span class="line">		var e = document.documentElement;</span><br><span class="line">		if (!!window.innerWidth) &#123;</span><br><span class="line">			return window.innerHeight</span><br><span class="line">		&#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123;</span><br><span class="line">			return e.clientHeight</span><br><span class="line">		&#125;</span><br><span class="line">		return 0</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function y() &#123;</span><br><span class="line">		if (window.pageYOffset) &#123;</span><br><span class="line">			return window.pageYOffset</span><br><span class="line">		&#125;</span><br><span class="line">		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function E(e) &#123;</span><br><span class="line">		var t = m(e);</span><br><span class="line">		return t &gt;= w &amp;&amp; t &lt;= b + w</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function S() &#123;</span><br><span class="line">		var e = document.createElement("audio");</span><br><span class="line">		e.setAttribute("class", l);</span><br><span class="line">		e.src = i;</span><br><span class="line">		e.loop = false;</span><br><span class="line">		e.addEventListener("canplay", function() &#123;</span><br><span class="line">			setTimeout(function() &#123;</span><br><span class="line">				x(k)</span><br><span class="line">			&#125;, 500);</span><br><span class="line">			setTimeout(function() &#123;</span><br><span class="line">				N();</span><br><span class="line">				p();</span><br><span class="line">				for (var e = 0; e &lt; O.length; e++) &#123;</span><br><span class="line">					T(O[e])</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, 15500)</span><br><span class="line">		&#125;, true);</span><br><span class="line">		e.addEventListener("ended", function() &#123;</span><br><span class="line">			N();</span><br><span class="line">			h()</span><br><span class="line">		&#125;, true);</span><br><span class="line">		e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;";</span><br><span class="line">		document.body.appendChild(e);</span><br><span class="line">		e.play()</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function x(e) &#123;</span><br><span class="line">		e.className += " " + s + " " + o</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function T(e) &#123;</span><br><span class="line">		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	function N() &#123;</span><br><span class="line">		var e = document.getElementsByClassName(s);</span><br><span class="line">		var t = new RegExp("\\b" + s + "\\b");</span><br><span class="line">		for (var n = 0; n &lt; e.length; ) &#123;</span><br><span class="line">			e[n].className = e[n].className.replace(t, "")</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	var e = 30;</span><br><span class="line">	var t = 30;</span><br><span class="line">	var n = 350;</span><br><span class="line">	var r = 350;</span><br><span class="line">	var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";</span><br><span class="line">	var s = "mw-harlem_shake_me";</span><br><span class="line">	var o = "im_first";</span><br><span class="line">	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];</span><br><span class="line">	var a = "mw-strobe_light";</span><br><span class="line">	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";</span><br><span class="line">	var l = "mw_added_css";</span><br><span class="line">	var b = g();</span><br><span class="line">	var w = y();</span><br><span class="line">	var C = document.getElementsByTagName("*");</span><br><span class="line">	var k = null;</span><br><span class="line">	for (var L = 0; L &lt; C.length; L++) &#123;</span><br><span class="line">		var A = C[L];</span><br><span class="line">		if (v(A)) &#123;</span><br><span class="line">			if (E(A)) &#123;</span><br><span class="line">				k = A;</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (A === null) &#123;</span><br><span class="line">		console.warn("Could not find a node of the right size. Please try a different page.");</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	c();</span><br><span class="line">	S();</span><br><span class="line">	var O = [];</span><br><span class="line">	for (var L = 0; L &lt; C.length; L++) &#123;</span><br><span class="line">		var A = C[L];</span><br><span class="line">		if (v(A)) &#123;</span><br><span class="line">			O.push(A)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()    '</span>&gt;</span>High一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码块的内容不需要再做任何修改。</p>
<p>为了便于直观理解，截图如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1eapjmnclddj20ky0h440w.jpg" alt=""></p>
<p>可以点击我博客右上角的「High一下」玩一玩。</p>
<p>你也试试吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[托管博客到STDYUN]]></title>
      <url>http://codeinterviews.com/blog-to-stdyun/</url>
      <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1eajpvdib6hj20t70bcdha.jpg" alt=""></p>
<p>晚上在<a href="http://yuche.me/" target="_blank" rel="external">@Ronaldo</a>的指导下，把博客从<em>github</em>迁移到了<em>stdyun</em>。前者不必解释，大家都知道。stdyun 是一家国内的云主机服务提供商，对静态网站提供免费的托管服务（限容量，但可申请扩容）。转而使用 stdyun 主要是考虑到这几点：</p>
<ul>
<li>国内主机，速度比 github 快多了。</li>
<li>配置很简单，注册到搞定比 github 简单。</li>
<li>多人推荐，比较靠谱。</li>
<li>虽然只有300M 流量，但对于个人的静态博客够用了，实在不够用的话可以申请免费扩容。</li>
</ul>
<p><strong>注意：只能用在mac或linux下！</strong></p>
<a id="more"></a>
<p>配置也非常简单：</p>
<ol>
<li>去<a href="https://stdyun.com/" target="_blank" rel="external">https://stdyun.com/</a>注册帐号，记住用户名和密码；在<a href="https://stdyun.com/octopress" target="_blank" rel="external">https://stdyun.com/octopress</a>「我的octopress」查看自己的账户和密码。</li>
<li><p>去博客的<code>hexo/_config.yml</code>修改 deploy 配置项，如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: rsync</span><br><span class="line"> host: o.stdyun.net</span><br><span class="line"> user: yourname</span><br><span class="line"> root: ~/www.yourdomain.com/</span><br><span class="line"> port: 22</span><br><span class="line"> delete: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在可以把博客 deploy 到 stdyun 了，使用的命令跟在 github 时是一样的。</p>
</li>
<li>修改dns映射。如果要使用二级域名(比如www.domain.com或者blog.domain.com)，添加cname指向cname.stdyun.net<br>如果要使用顶级域名(比如domain.com)，请添加a记录到218.245.3.110。注意要把原有的映射删掉。</li>
</ol>
<p>经过这四个步骤，就可以把博客托管到 stdyun 了，非常的方便。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于 KNN 算法的贝叶斯分类器]]></title>
      <url>http://codeinterviews.com/knn-as-bayes-classifier/</url>
      <content type="html"><![CDATA[<p>在《模式识别》这门课的最初部分，我们学习了设计分类器进行分类决策的理论基础——<strong>贝叶斯决策理论</strong>：</p>
<p>比较P(ωi|x)。其中ωi为第 i 类，x 为观测到并要分类的一个数据，P(ωi|x)表示在已知这个数据的特征向量的情况下，判断它属于第 i 类的概率是多少，这项也成为后验概率。根据<strong>贝叶斯公式</strong>，可以将其表示为：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1ea1uqqglqyj2089018745.jpg" alt=""></p>
<p>其中，P(x|ωi)称为似然概率或者类条件概率；P(ωi)称为先验概率，因为是与试验无关的，先于试验之前就可以知道的。</p>
<p>在分类时，给定 x，选择使得后验概率P(ωi|x)最大的那个类别即可。在比较每个类别下P(ωi|x)大小时，ωi是变元，而 x 是固定的；所以可以把 P(x)剔除掉，不加以考虑。</p>
<p>所以最终归结为计算<code>P(x|ωi)*P(ωi)</code>的问题。</p>
<p>先验概率 P(ωi)好求，只要统计训练集中每个分类下出现的数据的比例就可以了。</p>
<p>似然概率P(x|ωi)的计算就要破费周折了，因为这个 x是测试集中的数据，根据训练集没法直接得出。那么我们就需要找出训练集数据的分布规律，然后就可以得到P(x|ωi)。</p>
<a id="more"></a>
<p>好，复习了贝叶斯分类器，下面介绍 k 近邻算法，英文是 KNN。</p>
<p>我们要根据训练集中的数据 x1,x2…xn （其中每个数据是 m 维），在类别ωi下，拟合这些数据的分布。设 x 为 m 维空间中的任意一点，怎样计算P(x|ωi)？</p>
<p>我们知道，当数据量足够大时，可以用比例近似概率。利用这个原理，在点 x 的周围，找出距离 点x 最近的 k 个样本点，其中属于类别 i 的有 ki 个。计算出这 k 个样本点包围的最小超球的体积V；另求出所有样本数据中属于ωi类的个数 Ni。则：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1ea1vwsgyoqj203w013a9u.jpg" alt=""></p>
<p>可以看到，我们计算出来的实际上是 点 x 处的类条件概率密度。</p>
<p>P(ωi)怎么算呢？</p>
<p>根据上面的方法，P(ωi)=Ni/N 。其中 N 是样本总数。</p>
<p>另外，P(x)=k/(N*V)，其中 k为这个超球体包围的所有样本点的个数；N 为样本总数。</p>
<p>那么<code>P(ωi|x)</code>就可以计算了：带入公式，很容易得出：</p>
<p>P(ωi|x)=ki/k</p>
<p>怎么样，是不是非常清爽！</p>
<p>再解释一下上式，在一个 V 大小的超球体内，包围了 k个样本，其中属于 i 类的有 ki 个。这样，包围的哪类样本最多，我们就判定这里的 x 应该属于哪一类。 这就是用 k 近邻算法设计的分类器。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac神器之 Alfred Workflow]]></title>
      <url>http://codeinterviews.com/alfred-workflow/</url>
      <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e9zrfp5olcj20l60hkgn3.jpg" alt=""></p>
<p>今天通过一个网友哥们了解到 workflow 这个东西，准确的说是 Alfred 中的 workflow，当即决定要武断地封它为神奇的神器。</p>
<p>那么什么是。。Alfred 呢？</p>
<p>首先要从 Mac 上的 Spotlight 说起。这是 Mac OS X 上自带的全局搜索工具，用<code>control + space</code>呼出，输入关键字，即时显示不同域里的搜索结果。无图无真相，一图见分晓。</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e9zrbloknkj20cq0kk40h.jpg" alt=""></p>
<p>可以看到，Spotlight 已经是个非常好用的神器了。接下来介绍 Alfred。</p>
<a id="more"></a>
<p>官方的说明是：</p>
<blockquote>
<p>Alfred is an award-winning productivity application for Mac OS X<br>Alfred saves you time when you search for files online or on your Mac. Be more productive with hotkeys, keywords and file actions at your fingertips.</p>
</blockquote>
<p>自然，Spotlight 提供的功能，它都能实现。Plus and Besides，它还能提供运算、终端命令等操作；得益于强大的 workflow，你几乎可以在这里实现所有用别的方式可是实现的功能，but efficiently。</p>
<p>比如，有网友写了一个转换阿拉伯数字到中文繁体数字的 workflow，直观展示一下：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e9zrc8v40zj20go04xmxs.jpg" alt=""></p>
<p>回车后还可以放大：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e9zrcuckcaj20go070q45.jpg" alt=""></p>
<p>类似地，你可以写一个查询天气的 workflow。实际上，你需要的，大多数都已经有人写出来了，google 即可。</p>
<p><strong>怎样安装 Alfred？</strong></p>
<p>当然是去官网喽：<a href="http://www.alfredapp.com" target="_blank" rel="external">http://www.alfredapp.com</a></p>
<p>需要说明的是，这是一个收费软件；免费的话，只能使用搜索和计算等一些基本功能，购买之后可以使用全部功能；比较贵，个人版是17欧元。</p>
<p>首先，我极力推荐正版；然后，呃，对于我等无产阶级草民，只能通过天朝孕育出来的独门秘籍了——破解版。破解方式不宜公开，有需要者可以私联。</p>
<p>安装好之后，呼出的方式是<code>option + space</code>；跟 spotlight 有 slightly different。</p>
<p>上面已经提到了 workflow；既然这么好，那我也做一个吧。想想我平时遇到过什么麻烦的操作。。想到一个，写博客的时候，需要打开终端，又是 cd 啊，又是 hexo 啊，又是 open 的，很麻烦，那么我就用 workflow 来流程化一下下。</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e9zrdm42tej20xq0n4mzv.jpg" alt=""></p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e9zrekozeej20di07k3z8.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e9zrew130qj20jg0c8dgm.jpg" alt=""></p>
<p>Bingo！现在，只要呼出 Alfred，输入<code>hexo n blabla</code>，就会自动完成「切换目录，创建文件，打开目录，打开终端」等一系列操作，nice and neat。</p>
<p>Okay，介绍完了，了解更多，Please Google It。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用LaTeX编辑数学公式]]></title>
      <url>http://codeinterviews.com/latex-for-math/</url>
      <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e9yepw30o2j20m809k0t8.jpg" alt=""></p>
<p>LaTeX 归根到底也是一门用来排版的标记语言，像 Markdown 一样，通过一些符号定义文本的格式。LaTeX 被广泛地使用在图书、论文等文本排版中，功能强大，尤其是在对<strong>复杂表格和数学公式</strong>的支持方面，Markdown 是无法与之比拟的。至于文字排版，我还是喜欢使用比较整洁、简单的 Markdown。对于我们这些需要经常使用数学工具的人，学会在电脑上编辑数学功能几乎是必备的技能，有人说 Word 就可以做到，但它真的没有 LaTeX 强大。那么我们就学一学怎样用 LateX 编辑数学公式。</p>
<a id="more"></a>
<p>相关的教程随便一 Google 满屏都是，我就不重复造轮子了。仅给出建议的学习路线和推荐的工具、资料。</p>
<ol>
<li>LaTeX 在线编辑工具<a href="http://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="external">eqneditor</a>。功能十分强大，不仅可以实时可视化生成的结果，对于初学者，还可以通过上方的面板直接选取想要编辑的数学符号。这个工具先熟悉一下，随便玩玩，直观感受一下，一会再开始正式学习。另外，不建议下载安装 Win 版或 Mac 版的 LaTeX 编辑系统，Mac 上的 MacTex 有2G+，受不了。</li>
<li>简单的入门教程<a href="http://wiki.gwrite.googlecode.com/hg/misc/LaTex-EquRef.html?r=1de19067fce5484bb5c39cbd049f6a47f7d8a2e9" target="_blank" rel="external">《LaTex 参考》</a>。只介绍编辑数学公式的基本用法，简单、实用、清晰明了。建议一边学习一边在eqneditor实践。通过这一步的学习，我们就能基本掌握用 LaTeX 编辑数学公式的语法格式了。捎带说一下符号<code>$$</code>，它的意思是两个这样的符号包裹起来的部分是单独成行的；而两个<code>$</code>表示在行内插入数学公式。教程里会有，看到的时候知道就行，在编辑器里面可以体会到两者的不同。上述编辑器默认是<code>$$</code>。</li>
<li>数学函数参考手册<a href="http://mohu.org/info/symbols/symbols.htm" target="_blank" rel="external">《常用数学符号的 LaTeX 表示方法》</a>。上一步走完后，我们了解了基本语法，入门已经完毕，在实际使用中，遇到不清楚的函数，可以到这里查阅参考。</li>
<li>LaTeX 进阶<a href="http://pan.baidu.com/s/1zMIOj" target="_blank" rel="external">lshort 和 lnotes</a>。想要进一步了解 LaTeX 更强大更复杂更全面的功能，这两个教程是经典的金典大作。我就不看了，文本排版控制，我还是喜欢 Markdown。</li>
</ol>
<p>希望能对大家有些帮助。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[隐马尔可夫模型三个问题的求解(一)]]></title>
      <url>http://codeinterviews.com/3-problems-in-hmm/</url>
      <content type="html"><![CDATA[<p>上一篇<a href="http://zipperary.com/2013/10/15/an-introduction-to-hmm/" target="_blank" rel="external">《隐马尔可夫模型介绍》</a>中讲解了马尔可夫假设和隐马尔可夫模型 HMM，并提到了 HMM 中的三个基本问题，但没有展开讨论其求解。本篇就此做出解答。</p>
<p>本文主要参考<a href="http://www.52nlp.cn/category/hidden-markov-model/page/4" target="_blank" rel="external">《HMM 学习最佳范例》</a>。</p>
<p>先回顾一下，上节我们就硬币的例子提出了三个问题：</p>
<ol>
<li>给定上述模型，观察到的结果（硬币的正反面）为O={H，T，H}的概率是多少？</li>
<li>若给定上述的观察结果，那么最可能的状态序列（硬币序号）是什么？</li>
<li>A、B、π未知的情况下，如何根据 O 得到它们？</li>
</ol>
<p>问题一是个估算问题，P（O|λ），可用向前算法和向后算法解决；</p>
<p>问题二是根据观察序列反向找出最可能的状态序列，是个解码问题，P（O,q|λ），q 是某状态，最常用的是 Viterbi算法；</p>
<p>问题三实际上是个参数估计或求解的问题，或者说是个学习问题，通过训练一步步优化参数，找到使得P（O|λ）最大的那个参数，最常用的是 Baum-Welch算法。</p>
<hr>
<p>###例子</p>
<p>这里，我们提出一个更加恰当的例子：</p>
<p>有一个宅男，不爱出门，也不愿看看窗户外面的世界。但他有个特殊的习惯，通过观察海藻来推测外面的天气情况。天气一共有3种情况 S：（晴天、多云、雨天）；海藻一共有4种情况V：（干、稍干、潮湿、湿润）。海藻的情况是宅男直接观察到的，而天气的情况并没有直接观察到，而是隐藏状态，是他推测出来的。其关系如图所示：</p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e9nxfm6fm5j20bu07dq3k.jpg" alt=""></p>
<a id="more"></a>
<p>另外，我们给出其他三个条件：</p>
<p>天气的状态转移矩阵A：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e9nxie43xtj20bw046gls.jpg" alt=""></p>
<p>天气的初始概率向量π：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e9nxjfricdj205d01swea.jpg" alt=""></p>
<p>天气状态和海藻观察情况的混淆矩阵 B：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e9nxk60arrj20af03o3yj.jpg" alt=""></p>
<p>现在，这个 HMM 已经构建好了，如上一节所说，是一个五元组λ=（S，V，A，B，π）。</p>
<p>我们使用一个隐马尔科夫模型（HMM）对这个例子建模。这个模型包含两组状态集合和三组概率集合：</p>
<ul>
<li>隐藏状态：一个系统的（真实）状态，可以由一个马尔科夫过程进行描述（例如，天气）。</li>
<li>观察状态：在这个过程中‘可视’的状态（例如，海藻的湿度）。</li>
<li>pi向量：包含了（隐）模型在时间t=1时一个特殊的隐藏状态的概率（初始概率）。</li>
<li>状态转移矩阵：包含了一个隐藏状态到另一个隐藏状态的概率</li>
<li>混淆矩阵：包含了给定隐马尔科夫模型的某一个特殊的隐藏状态，观察到的某个观察状态的概率。</li>
</ul>
<p>###评估问题：前向算法</p>
<p>给定λ，要计算某个观察序列 O的概率，最不费脑子的办法就是<strong>穷举法</strong>。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e9nxtk7wpkj20be05cjro.jpg" alt=""></p>
<p>如图，若求序列（dry,damp,soggy）的概率，只要把每种可能的状态序列都算一下概率，最后相加即可。一共有3**3=27种。</p>
<p>总的概率是：Pr(dry,damp,soggy | HMM) = Pr(dry,damp,soggy | sunny,sunny,sunny) + Pr(dry,damp,soggy | sunny,sunny ,cloudy) + Pr(dry,damp,soggy | sunny,sunny ,rainy) + . . . . Pr(dry,damp,soggy | rainy,rainy ,rainy)</p>
<p>其中每项的求解很简单，利用初始状态向量π、状态转移矩阵 A 和混淆矩阵 B，通过相乘就能得到。</p>
<p>可以看到，这种做法的代价是比较昂贵的，省了脑力就会相应的耗费体力，上帝是公平的。</p>
<p>下面提出一种颇费脑细胞，但代价比较小的算法：<strong>前向算法</strong>。</p>
<p>首先，定义<strong>局部概率</strong>这个概念：它是到达上图网格中间某个状态的概率，它是所有到达这个状态的可能路径的概率求和的结果。</p>
<p>例如，对于 t=2时Cloudy的局部概率：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e9ny3n70dyj2098053glq.jpg" alt=""></p>
<p>有三个路径，分别计算每条路径的概率，再求和即可。相信聪明的你已经想到，我们正是利用<strong>递推</strong>的方式来求解最后结果：</p>
<p>首先计算 t=1的情况，然后就算 t=i 的情况（利用 t=i-1），最后得出最末时刻的概率。</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e9ny8rzqfkj204x00x743.jpg" alt=""></p>
<p>其中，j 表示三个天气状态中的某一种；α1(j)表示 t=1时，天气状态为 j 时，得到观察为 k1的概率；等式的右边，表示初始状态下某天气的概率乘以该天气下得到 k1观察的概率。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e9ny9fibxsj207d01g745.jpg" alt=""></p>
<p>这个式子中加入了状态转移矩阵的元素，就是 aij，用来递推计算，总的形式和上式一致。</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e9nyb4eyafj205p01jglg.jpg" alt=""></p>
<p>最后所求概率，是一个加和，由于递推结束，不需要状态转移矩阵了。</p>
<p><a href="http://www.52nlp.cn/hmm-learn-best-practices-five-forward-algorithm-5" target="_blank" rel="external">这里</a>有一个实际的计算过程可供参考。</p>
<p>为什么叫「前向算法」呢？从上面可以看出，这个算法的本质，是根据前t时的情况计算t+1时的情况，是一个逐渐向前推进的过程。</p>
<p>时间有限，今天先写这些，预告：</p>
<p>解码问题：Viterbi 算法</p>
<p>学习问题：Baum-Welch 算法</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac升级Lion到Mavericks]]></title>
      <url>http://codeinterviews.com/osx-update-and-ipv6-configure/</url>
      <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e9bezvg5kij217y0na119.jpg" alt=""></p>
<p>最近苹果放出了 Mavericks GM，也就是正式版之前的最后一个版本。有开发者提取了系统安装文件，并放在网上分享。目前用的比较多的有两个版本：</p>
<p> 一个是<a href="http://kuai.xunlei.com/d/IMQfAAIjVgC5UU5Sfc0" target="_blank" rel="external">全新安装版</a>（迅雷快传）</p>
<p> 另一个是<a href="http://pan.baidu.com/share/link?shareid=2750006&amp;uk=3658275525" target="_blank" rel="external">升级安装版</a>（百度网盘）</p>
<p>我是从10.8.5升级到 Mavericks GM(10.9)，为了升级的方便以及保留所有的数据和程序，我使用了<strong>第二个方案</strong>。</p>
<p><em>升级之前，请使用 Time machine 进行备份！</em></p>
<p><em>我没有多少太重要的数据、程序，也怕备份麻烦，所以没有做备份。</em></p>
<a id="more"></a>
<p>升级的过程相当简单：</p>
<ol>
<li><p>首先点击上面的连接下载升级安装文件。推荐在 win 上安装<strong>百度云管家</strong>，速度非常快。</p>
</li>
<li><p>下载完成之后，在 Mac 上双击打开，并把里面的 拖放到桌面，方便使用。再双击 ，一路默认，之后会重启安装。</p>
</li>
<li><p>安装的过程大概需要40分钟，期间可以洗洗衣服什么的。之后还会重启一次。会提示你设置一些东西，按照要求填写即可。</p>
</li>
</ol>
<p>进入升级好之后的系统，发现变化真心不大。比较明显的，一是 iBooks，二是地图。所有的数据、程序、状态都完美保存着，很不错。具体的变化，请参考这个页面：<a href="http://www.apple.com/cn/osx/preview" target="_blank" rel="external">http://www.apple.com/cn/osx/preview</a> 。</p>
<hr>
<p>Macboos Air没有网线插口，上网只能连接无线。而一般的无线路由器都不支持 IPV6，这么好的资源就白白浪费了。目前求得一法，亲测好用。</p>
<ol>
<li>访问<code>192.168.0.1</code>或<code>192.168.1.1</code>，登录路由器。（网址和登录名、密码都写在路由器的底部）</li>
<li>进入<code>DHCP 设置</code>，关掉 DHCP。</li>
<li>把网口伸出来的网线插入无线路由器的任意一个 LAN 口，而不是 WAN 口。</li>
<li>连接无线，访问<a href="http://ipv6.google.com.hk，如果能打开，说明已经搞定。" target="_blank" rel="external">http://ipv6.google.com.hk，如果能打开，说明已经搞定。</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[QQ for Mac无法视频通话的解决办法]]></title>
      <url>http://codeinterviews.com/qq-for-mac-video/</url>
      <content type="html"><![CDATA[<p>###问题描述</p>
<p>OSX 升级到10.8.5之后，QQ 进行视频通话时，总提示「检测不到摄像头…」，自己电脑的摄像头无法打开，但可以看到对方的视频；而 facetime 和 Photobooth 都可以正常使用。</p>
<p>###腾讯提供的解决方法</p>
<p>根据腾讯的解释，这是由于新的 OSX 系统里面，摄像头不允许第三方的应用随意调用，所以需要替换一个相关的文件才行。</p>
<p>以下引用腾讯提供的解决方法：</p>
<blockquote>
<p>关于2013款air升级至10.8.5后无法使用摄像头的临时解决办法：1.前往路径 /Library/CoreMediaIO/Plug-Ins/DAL/ ，备份文件AppleCamera.plugin；2.下载并解压链接中文件<a href="http://t.cn/z88nzZt" target="_blank" rel="external">http://t.cn/z88nzZt</a> ；3.复制该文件到1路径，并覆盖原文件；4.重启电脑。</p>
</blockquote>
<p>我按照这个办法设置，然后各种鼓捣始终不行，直接导致我感觉自己「被上帝眷顾了」。今天又换了个方法设置了下，搞定了。下面提供自己的方法（跟上述方法如出一辙）。</p>
<a id="more"></a>
<p>###我的解决步骤</p>
<ol>
<li>打开 Finder，快捷键<code>command + shift + g</code>，填写<code>/Library/CoreMediaIO/Plug-Ins/DAL/</code>，回车。</li>
<li>把<code>AppleCamera.plugin</code>复制粘贴到桌面上。</li>
<li>下载连接<code>http://t.cn/z88nzZt</code>中提供的文件。注意，后缀为<code>.zip</code>，不可以下载成<code>.plugin</code>。</li>
<li>用系统自带的解压方式「用默认的方式归档」解压文件，并复制到刚才第一步打开的那个路径，粘贴时选择「替换」。</li>
<li>「注销」并重新登录。好了，已经 okay了。</li>
</ol>
<p>这个问题按照腾讯的方法，本来很容易解决的，为什么我鼓捣这么久才搞定？因为这个过程中各种坑：</p>
<ul>
<li><p>用 chrome 下载时，提示我下载成「.zip」还是「.plugin」，我选了后者。</p>
</li>
<li><p>文件的权限问题，还有命名问题，因为它可能隐藏了名称中的部分后缀。</p>
</li>
<li><p>不必重启，注销即可。</p>
</li>
<li><p>备份的时候直接备份到了它旁边。</p>
</li>
</ul>
<hr>
<p>今日彩蛋：</p>
<p>在图片文件上呼出右键菜单，共享里面有一个「新浪微博」，可以分享到新浪微博，界面很漂亮，发送后，微博尾巴是「来自 osx」。</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e9910cwt6rj20bu06i3yt.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello,Mac!]]></title>
      <url>http://codeinterviews.com/hello,mac/</url>
      <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e93mmysx9mj21400p0n7d.jpg" alt=""></p>
<p>26号在苹果团支付、下单购买了 Macbook Air 13存2013年中标配版，顺丰还算给力，28号的中午就到了学校。要的是香港原封产品，所有费用包括 MBA（6600）、苹果团提利润（180）、顺丰运费（50），共计6830软妹币，比官方的「7988」便宜了大概1000，而且由于苹果是全球联保，所以港货大陆货都无所谓。</p>
<a id="more"></a>
<p>本子拿出来的第一感觉就是薄，至今都感觉 incredibly thin。外观无可挑剔的漂亮，跟我的三星本放在一起，顿感两个星球般的距离。昨天下午开始，一直到现在，我都在学习使用 Mac。大部分时间其实在安装各种软件，鼓捣各种设置。说一说感受吧。</p>
<ol>
<li>分辨率。相对于我的三星本14存大小1366的分辨率，小 Air13.3寸1440分辨率，颗粒感却比三星本还强，应该是字体太小的缘故。在图像显示上不会有太大差别。反正，看过了 RMBP，再看其他屏都是渣。</li>
<li>键盘。Air 的键盘相对有点小，悬浮感也不够，使用起来不如三星本爽。键盘布局和 PC 也不太一样，比如没有 Home键，这些需要适应。</li>
<li>触摸板。强大的触摸板，从此抛弃鼠标。这是我感觉 Mac 最物超所值的地方。「系统偏好设置」里面有详细的动画演示教程。</li>
<li>软件。Mac 另外一个物超所值的地方是，有了 OSX，你就可以使用大量的优秀软件了。虽然很大一部分是收费的，但庆幸的是我们身在天朝，前辈们已经铺好了免费的路。</li>
<li>电池。12小时续航可不是吹的。我今天上午十点半开始使用，到现在（19点半）还剩余有20%的电量，而且我一直在高密度使用，各种下载各种鼓捣软件。Air 不仅续航牛 X，充电的速度也比三星本快不少。</li>
<li>Windows 迁移成本。很多用户会考虑从 windows 迁移到 Mac 的成本，除了学习成本，最大的一块就是软件的替代性了。以往大家都是装个 windows 虚拟机或者双系统来解决，现在，随着开发厂商的推进，大多数常用软件已经有了 Mac 的版本，而且一直在迭代升级。比如迅雷、QQ、支付宝、Office。最令人头疼的支付问题已经得到了一些解决，比如招行、支付宝都支持 Mac。局域网代理软件 Proxifier、翻墙软件 GoagentX 都是非常好用的 Mac 版本。</li>
<li>网络。由于 Air 的一个使命是做轻做薄，所以没有空间做网络插口。是的，Air 只能连接无线上网。实际上这也是一个趋势。Air 的各种外设都可以通过 wifi 或者蓝牙连接，网络使用 wifi 也更加方便和优雅。至于非要使用有线网的用户，只要买一个转换器就可以了。</li>
<li>硬盘。Air 只有128G 的硬盘，但人家是固态硬盘，速度和稳定性上都远非一般硬盘可比。为了弥补空间的不足，我还购买了一个1T 的西数移动硬盘，配送中…</li>
</ol>
<p>下面说说软件和服务。</p>
<ol>
<li>翻墙用 GoagentX，不用重复部署，添加几个必备的选项就可以用。用这个客户端还可以使用 Shadowsocks、西厢、SSH 等方式。</li>
<li>输入法用百度。当我从搜狗换成百度时，我感动了，这才是人性的输入法。支持自定义短语，方便的中文引号使用，与盖世同步词库，以及更多的个性化设置。</li>
<li>iLife 娱乐套件和 iWork 工作套件，据说都是神器，暂时还没体验。iLife 是自带的，iWork 需要购买，不过有破解版可以安装。</li>
<li>邮件、日历，可以使用 Google 的，非常好用，消息实时推送，再也不用担心 Gmail 闹情绪了。</li>
<li>App Store 和 iTunes 慢如蜗牛，V2EX 提供了 DNS 服务器，不过暂没办法跟 Proxifier 和平共处。</li>
<li>自带的截图功能太赞了；Finder 里面的预览功能也很强大（空格键）；连按两下 Fn 还可以听写哦。</li>
<li>微软的 Office 套件，必装吧，有破解版。</li>
<li>为知笔记 Mac 版太水了，只有核心功能，很不方便，我怀念 Evernote 了。</li>
<li>代理还是使用 Proxifier，同样好用，可能由于 win 和 osx 平台的不同，在 mac 上这个软件更加稳定。</li>
<li>浏览器用 chrome。虽然 Safari 已经相当好了，但为了各种同步和使用习惯的考虑，我还是选择 chrome。</li>
<li>下载用迅雷和 utorrent。</li>
<li>视频播放用 MplayerX。</li>
<li>markdown 当然是用 Mou 了，我垂涎已久的神器！BTW，我这篇文章就是在 Mou 上写出来的。</li>
</ol>
<p>先写这些，更多的功能还待探索。</p>
<p>初体验的整体感受，Mac 超长续航、超轻超薄、巨量的优秀软件、强大的触摸板、主流的配置（4G 内存+128G 固态硬盘）、漂亮的设计、六千多的价格，应该是物超所值了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[教你设置二级代理]]></title>
      <url>http://codeinterviews.com/secondary-proxy/</url>
      <content type="html"><![CDATA[<p>之前在<a href="http://zipperary.com/2013/09/10/qiao-qiao-gao-su-ni/" target="_blank" rel="external">《悄悄告诉你》</a>一文中提到过校园中用代理绕过计费系统上网的方法。这个trick让我窃喜了一阵子，但实际上有个问题没有解决：无法再使用vpn或Goagent代理翻墙。于是这些天我在使用Google时不时地抹眼泪，不翻墙的日子太憋屈了！</p>
<p>痛定思痛，既然已经尝试过各种可以想到的办法仍旧未果，那么接下来唯一可做的就是请教大神了。大神在哪里？在V2！我便聪明果敢地在这里抛出了<a href="http://www.v2ex.com/t/83331#reply16" target="_blank" rel="external">这个难题</a>，等待大神赐教。陆续收到了一些回答，了解到我需要设置二级代理，但这个概念本身我都是第一次听说，更不会设置了，网上也搜索不出教程，很是苦恼。直到！直到今天下午，@xujialiang图文并茂的回答才给了我生机。虽然他用的是mac，虽然界面跟Proxifier不一样，虽然他用的是shadowsocks，但「添加规则」的方式都是类似的。比照他的设置，我在Proxifier设置了Goagent的过滤规则。然后打开软件，打开浏览器，输入<a href="http://www.youtube.com/" target="_blank" rel="external">http://www.youtube.com/</a>，Bingo！久违的界面映入眼帘！</p>
<p>废话一箩筐，无图无真相！</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e8yvafwr5lj20sd0er77b.jpg" alt=""></p>
<p>需要设置的地方已经用红框标示，代理服务器地址就不方便透露了。</p>
<p>从原理上讲，就是让翻墙软件（如Goagent、Shadowsocks）也走代理。我原来一直以为翻墙软件默认是走代理的，所以没有尝试这个设置，看来这就是问题的症结所在。推广开来，任何用代理时无法联网的应用，都可以通过设置代理规则搞定。</p>
<p>现在呢，有了伟光正的代理服务器，有了彪悍霸气神威的Proxifier，有了自由召唤者Goagent，生活将是另一个面貌！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓应用推荐]]></title>
      <url>http://codeinterviews.com/android-apps/</url>
      <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e8r0zttw6pj20nl0icdgo.jpg" alt=""></p>
<p>安卓手机刚刚走进中国市场的时候，我和周围的同学就开始使用，一直到现在，陪伴安卓从2.3走到4.3，看到安卓自身的变化以及给世界带来的巨变，衷心感激安卓拓展了我的认知范围，给我的生活带来了许许多多的便利。这里就推荐（或曰列举）一下我手机里使用的APP。由于大脑容量和质量有限，几乎不会玩游戏，也不装游戏，所以本文只涉及应用，不涉及游戏。</p>
<a id="more"></a>
<p>###Before Everything</p>
<p>写在最前面的这些，可以拓展安卓手机的能力。</p>
<ol>
<li><p>Root。<br>Root是一种操作，目的是获取手机的超级权限。建议喜欢玩机的都root一下，否则很多应用没法使用，系统文件也无法修改。</p>
<p>Root的方法依手机而定。一般情况下，去「安卓论坛」相应手机的板块下，都会有教程。</p>
</li>
<li><p>Google服务框架。</p>
<p>中国卖的行货手机普遍把Google服务阉割掉了，十分坑爹十分想让人骂娘。没有这个东西，就无法使用Google提供的各项服务和应用，如：云同步、Gmail、Google Play。</p>
<p>安装Google服务框架的方法是：到<a href="http://goo.im/gapps" target="_blank" rel="external">这里</a>下载对应安卓版本的gapps，然后用Recovery将其刷入（不需要双清）。</p>
</li>
<li><p>刷机。</p>
<p>如果对自己的系统很满意，完全可以不走这一步。如果想刷系统的话，可以到论坛里面对应版块找喜欢的系统，按照论坛里的教程刷机。</p>
</li>
</ol>
<p>###社交</p>
<ol>
<li><p>微博。</p>
<p>这里值得一提的是，微博客户端会有个小尾巴，显示「来自Android客户端」、「来自三星Galaxy S3」云云。如果你的微博小尾巴是第一种，可能需要到厂商自带的市场（如三星应用商店）下载新浪微博客户端才行，下载好之后记得升级到最新版本。</p>
</li>
</ol>
<ol>
<li><p>Fuubo。</p>
<p>第三方的新浪微博客户端，完全遵守安卓的设计规范，轻盈、简洁、漂亮、易用。</p>
</li>
<li><p>微信。</p>
<p>这个不用说了吧。</p>
</li>
<li><p>QQHD mini。</p>
<p>QQ客户端，对于大屏手机推荐使用这个版本，布局合理、干净，好用。</p>
</li>
<li><p>Twitter &amp;&amp; Facebook。</p>
<p>我使用的全是官方版本，非常漂亮易用。但由于GFW的存在，这两个应用都需要翻墙，稍后会提到翻墙使用的APP。</p>
</li>
<li><p>Google+。</p>
<p>Google的社交产品，上面有很多各界的大牛。应用本身做的特别出色，操作和界面都令人叹为观止。我平时用这个看些新闻和图片。</p>
</li>
</ol>
<p>###阅读</p>
<p>这里面包括电子书、信息、RSS和新闻的阅读。</p>
<ol>
<li><p>多看。</p>
<p>安卓上的王者，应用做的很完美，电子书的质量很高，价格不贵。每天都会推出一本限免书，排版非常精美。支持笔记、批注、标签等功能，还可以轻松将笔记、标注导出到Evernote等应用。</p>
<p>支持的电子书格式有epub、pdf、txt等。</p>
</li>
<li><p>Kindle。</p>
<p>Kindle的安卓版。基本功能都有，阅读体验也不错，最重要的是，mobi格式的电子书数量巨大、排版精良，随处可以下载到。遗憾的是导出功能缺失，害得我有一次把一本书的笔记批注手打到电脑上。</p>
</li>
<li><p>Startup News。</p>
<p>Fenng创办的，Hacker News的中国版，网友们把在网上看到的好的内容推荐到这里。聚集了很高人气，推荐的文章质量很不错。我每天必看，学到很多。</p>
</li>
<li><p>知乎。</p>
<p>一个高质量的问答社区，客户端做的也不错。如果你不拒绝知识，一定要看看。</p>
</li>
<li><p>Quora。</p>
<p>知乎的鼻祖。内容的质量比知乎高、态度也更严肃一点。如果英文不错，或者想学英文，强烈推荐每天阅读。</p>
</li>
<li><p>Gmail。</p>
<p>我的神器。邮件即时推送。对垃圾邮件的过滤十分强大。由于the Fuck GFW，网页版的Gmail经常掉链子，但安卓客户端好像一直很稳定。强烈推荐！</p>
</li>
<li><p>鲜果联播。</p>
<p>订阅感兴趣的信息源。尽管新版本的呈现样式我很不喜欢，而且把RSS功能阉割掉了，但仍然是一款优秀的应用。</p>
</li>
<li><p>糗事百科。</p>
<p>谁能拒绝娱乐呢，快点安装吧，笑抽了。</p>
</li>
<li><p>Pocket。</p>
<p>又一个神器。看到喜欢的文章，又来不及阅读，怎么办？Add to Pocket！有浏览器插件、网页版、各种移动客户端。支持离线阅读。</p>
</li>
<li><p>今日头条。</p>
<p>个性化看新闻，我最近开始使用，感觉不错。</p>
</li>
</ol>
<p>###应用市场</p>
<ol>
<li><p>Google Play.</p>
<p>最官方最正宗的应用市场，数量大、质量高，但有些不能在国内下载。</p>
</li>
<li><p>豌豆荚。</p>
<p>很全，基本上都能在这里找到，通过各种机制，也提高了应用的总体质量。这两个配合使用，天下无敌。</p>
</li>
</ol>
<p>###视频</p>
<ol>
<li><p>快播。</p>
<p>无论是对格式的支持，还是人性化的操作方式，亦或是丰富的在线视频、雷达功能，注定它要在这个领域占有一席之地。</p>
</li>
<li><p>百度视频。</p>
<p>直播和视频栏目不错，视频资源也比较丰富。</p>
</li>
<li><p>TED &amp;&amp; 网易公开课。</p>
<p>Moocer必备。</p>
</li>
<li><p>Youtube。</p>
<p>观看订阅的视频。需要翻墙。</p>
</li>
</ol>
<p>###翻墙</p>
<ol>
<li><p>fqrouter2.</p>
<p>无需设置，无需root，一键翻墙，很好很强大，强烈推荐。</p>
</li>
<li><p>vpn。</p>
<p>如果有账号，可以使用安卓自带的vpn服务，全局翻墙，很好用。</p>
</li>
<li><p>ProxyDroid。</p>
<p>这个应用是用来设置全局代理的，跟PC端的Proxifier很类似。我就是用这个应用突破校园网流量限制的。</p>
</li>
</ol>
<p>###团购</p>
<ol>
<li>美团。</li>
<li>糯米。</li>
</ol>
<p>###生活工具</p>
<ol>
<li><p>雅虎天气 &amp;&amp; 中华万年历。</p>
<p>前者非常漂亮优美，后者特别适合中国用户的使用习惯。我刚刚从后者转到前者。</p>
</li>
<li><p>Holo Compass。</p>
<p>指南针，遵从安卓设计标准，简洁好用。</p>
</li>
<li><p>百度地图。</p>
<p>虽然各种广告很烦人，但的确很强大很有用，尤其是公交和周边信息。</p>
</li>
<li><p>soso地图。</p>
<p>中国做的最好的街景地图。</p>
</li>
</ol>
<p>###效率工具</p>
<ol>
<li><p>为知笔记。</p>
<p>相对于Evernote，只会更智慧、更好用，我目前最宝贵的财富之一。</p>
</li>
<li><p>Wunderlist。</p>
<p>GTD应用。打通各种客户端，同步很棒。界面非常漂亮。最近开始使用，推荐。</p>
</li>
<li><p>谷歌日历。</p>
<p>做计划、做提醒神马的，神器，同步强大。</p>
</li>
</ol>
<p>###图片</p>
<ol>
<li><p>flickr。</p>
<p>注册即送1T容量，所有图片无损无压缩，展示方式很漂亮，可以发现无数的优美图片，也可以关注朋友。雅虎出品。</p>
</li>
<li><p>Instagram。</p>
<p>图片社交应用，类似flickr，同样很好很强大。可以关注苍井空，也可以关注习近平。前段时间推出了短视频，更加强大了。</p>
</li>
</ol>
<p>###音乐</p>
<ol>
<li><p>网易云音乐。</p>
<p>音乐应用的后起之秀，网易发力在做，迭代更新的很快，进步迅速。界面优美，乐库很全，音质也好，社交功能也很到位。很nice的一点，支持耳机线控操作。强烈推荐。</p>
</li>
<li><p>豆瓣FM。</p>
<p>虽然我现在都是用网易云音乐，但还是推荐一下豆瓣FM，随机听音乐，匹配用户爱好，现在还加入了歌词，很赞。</p>
</li>
<li><p>酷狗音乐。</p>
<p>感觉酷狗音乐很像当年的百度音乐，乐库最全但质量参差不齐。我听相声一般在这里找。</p>
</li>
</ol>
<p>###其他</p>
<ol>
<li><p>百度输入法。</p>
<p>自认为是安卓上最好用的中文输入法，强大、轻盈、漂亮。美中不足的是用户个性词汇无法云备份，只能导出到手机内。</p>
</li>
<li><p>百度云。</p>
<p>3T的容量，噢耶。文件、相册、短信、联系人同步，一直在用。还有很棒的手机找回功能。</p>
</li>
<li><p>支付宝。</p>
<p>开通快捷支付，在手机上可以非常方便的购物、充值、买彩票。</p>
</li>
<li><p>下厨房。</p>
<p>Cooking必备。</p>
</li>
<li><p>chrome。</p>
<p>最好的浏览器，没有之一。斯认为最牛的地方是同步。</p>
</li>
<li><p>calculator。</p>
<p>好多数学符号很难打出来？试试这个吧，手写输入。</p>
</li>
<li><p>WPS。</p>
<p>我PC和安卓都用的WPS，免费、好用。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux下常用命令]]></title>
      <url>http://codeinterviews.com/linux-commands/</url>
      <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e8bd5xw20jj20mm0gwgmy.jpg" alt=""></p>
<p>linux的强大之处，很大程度上在于其丰富灵活的shell命令，但这一点恰恰也是阻碍初学者的老大难问题。这里是我学习linux命令时的笔记，不求全面，但求有用。先学会最基本最常用的命令，在使用中再逐渐积累。</p>
<p>###shell命令行格式</p>
<p><code>命令 -l(选项) 参数</code>   </p>
<p>没有参数的选项可以合并；命令之间用<code>;</code>隔开，依次执行；长选项用<code>--</code>;管道<code>|</code>可以串联执行。</p>
<a id="more"></a>
<p>###系统</p>
<p>md5sum+文件：    检验签名</p>
<p>uname：    机器名    -a详细</p>
<p>history：    命令历史 ；   +10执行第十个</p>
<p>sudo+命令： 超级权限</p>
<p>su moxie： 进入超级用户moxie</p>
<p>passwd：    改密码</p>
<p>alias l=’ls -l’：    命令别名  ；  unalias l可以取消</p>
<p>man bla：    帮助</p>
<p>bla –help</p>
<p>whereis ls：   ls 二进制文件的路径</p>
<p>ps：    列出进程</p>
<p>top：    显示cpu信息</p>
<p>free ：   跟踪内存的使用信息    b以B显示    k以KB显示    h易读的格式</p>
<p>kill 5721 ：   杀掉该进程</p>
<p>service bla start：    启动服务    restart、stop</p>
<p>apt-get install bla：    包管理类似pip    update升级</p>
<p>mkpasswd  20：    生成随机密码，长度为20 ???</p>
<p>cal：    日历    02 2000</p>
<p>date：    日期    –set设置</p>
<p>###文件</p>
<p>ls：    列出文件夹、文件    -l  -a</p>
<p>lsof：    显示打开的文件</p>
<p>lsblk：    列出块设备  -l列表形式</p>
<p>df：    磁盘使用情况</p>
<p>mount 分配名 目录 ：   将设备挂在到指定目录</p>
<p>pwd：    print working directory</p>
<p>cd /foo：    改变当前路径    ~    .. . -</p>
<p>mkdir bla：    文件夹</p>
<p>touch bla：    更新时间戳，如果没有，创建</p>
<p>cat a b &gt;&gt;c：    连接ab成c，如果没有c会创建。如果只有a，则显示。    -n行号    cat &gt;&gt;c然后可以输入内容</p>
<p>paste a b &gt;&gt;c：    另一种方式连接</p>
<p>cp bla /foo：    复制</p>
<p>mv……………：    移动，也可以单文件重命名</p>
<p>rm bla foo：    删除    -rf删除目录</p>
<p>rename a b *sh：    多文件重命名，所有sh后缀的文件中的a换成b</p>
<p>cmp foo bar：    比较两个文件</p>
<p>chmod 777 bla：    改权限</p>
<p>chown a:b bla：    改用户和组</p>
<p>find -iname *.sh：    搜索目录和子目录下的文件，i为忽略大小写</p>
<p>grep bla /foobar：    搜索文件中包含bla的行    i忽略大小写    r递归搜索    c统计    color着色</p>
<p>###网络</p>
<p>wget url：    下载</p>
<p>ifconfig：    检查活动路由器    a所有    eth0 down停用    up启用  </p>
<p>netstat：    各种网络相关信息    a所有    t为tcp    s为连接的    c动态输出</p>
<p>dig 某域名：    查询。。。</p>
<p>uptime：    服务器无人值守时发生了什么</p>
<p>w：    uptime和who的组合命令</p>
<p>wall “bla”：    发送一条消息到登录端    类似的还有mesg write talk</p>
<p>###源代码安装</p>
<ol>
<li><p>tar文件解压</p>
</li>
<li><p><code>./configure --prefix=/usr</code>    设置安装到bla，生成makefile</p>
</li>
<li><p><code>make</code>    编译</p>
</li>
<li><p><code>make install</code>    安装</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VIM常用命令]]></title>
      <url>http://codeinterviews.com/vim-commands/</url>
      <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e8bd921gscj20j40j4wfy.jpg" alt=""></p>
<p>之前写过<a href="http://zipperary.com/2013/08/24/vim-tips/" target="_blank" rel="external">《vim使用中的几个问题》</a>这篇文章，介绍了vim使用中几个疑难杂症和一些tips。现在把我收藏的经常使用的VIM命令在这里列举一下。</p>
<a id="more"></a>
<p>###移动光标（普通模式下）</p>
<p>括号匹配：%</p>
<p>同词： #和*    （整个单词，不是字符）</p>
<p>词组： w b  e（词尾）</p>
<p>行内：0 $      ^ g_       (f t下一个bla)</p>
<p>跳行： :22</p>
<p>翻页： ctrl + （fb ud）</p>
<p>首尾： gg G</p>
<p>查找： /word  （n查找下一个）</p>
<p>block： [[和]]</p>
<p>###修改</p>
<p>插入：o O（新行） ；   a（光标后）；i（光标前） ；r（光标处） ； (cw 到词尾)</p>
<p>删除： x X  ； d（删除行） ；   ggdG全部删除</p>
<p>撤销： u 或 ctrl+r</p>
<p>复制：y ；    y$到最后</p>
<p>粘贴：p</p>
<p>大写：gU大写；   gu小写    (选中之后)</p>
<p>替换： :%s/foo/bar</p>
<p>###文件 （命令模式）</p>
<p>退出： w q ！；  ZZ ； :w文件 ； :x（后面加a表示所有文件）</p>
<p>打开： e    （有参数，也可以创建新的）o也可以</p>
<p>另存： saveas</p>
<p>新建： enew    （无参数）</p>
<hr>
<p>爱打卡-100days-第98天-0001</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓4.2那些事]]></title>
      <url>http://codeinterviews.com/android-422/</url>
      <content type="html"><![CDATA[<p>前几天的博文<a href="http://zipperary.com/2013/08/26/smartisan-share/" target="_blank" rel="external">《锤子ROM图鉴》</a>和<a href="http://zipperary.com/2013/08/27/gai-shi-san-shua-ji-shou-ji/" target="_blank" rel="external">《安卓4.3，我来啦！》</a>都提到了最近刷机的事。刷完4.3之后在使用过程中，发现了一个极其严重的问题：ActionBar变黑。这个问题会出现在很多应用中，比如微博、SN、Pocket。去xda-developers求解，发现了CM官方对这个问题的解答。「这东西有版权问题，刚刚着手开发的CM10.2还没有把版权搞定」。看来我的尝鲜有点早了，CM10.2（Android4.3）第一个公开发行的Nightly版本诞生还不足半个月，注定有很多很多的bug，我不知不觉做了一次小白鼠。</p>
<p>在OTA更新过程中，发现了前天刚刚发布的CM10.1RC。看了下新闻才知道，CM准备停止CM10.1（Android4.2）的开发工作，全面投入到10.3当中去。这个版本是10.1的Candidate Release版本，也就是最终版之前的一个版本，基本稳定，用户可以使用。看到消息后我十分欣喜，决定把ROM刷成这个。首先这个版本非常稳定，其次，安卓4.3和4.2之间的变化微乎其微，上述这个版本甚至把4.3中的一些东西也迁移过来，更佳了。</p>
<p>于是我就用OTA下载并升级。重启并升级之后，竟然卡在开机界面不动了，卡顿了十来分钟，已经能确定手机变砖了。一身冷汗，我的数据咋办，还没备份。没办法，再刷回4.3吧。回来之后惊喜地发现，所有数据都还保留着。感谢苍天和大地！</p>
<p>google一下才发现，CM警告过，不要用OTA刷回到4.2。</p>
<p>只有一个办法了：备份数据、刷4.2。</p>
<p>我愚蠢地再次使用了钛备份。双清刷4.2很快。开机之后要恢复数据傻眼了，钛备份根本不能识别它备份过的数据！欲哭无泪。几十个应用，重新安装吧。顺便把账号和密码都复习一遍。</p>
<p>在各种应用各种设置中进行测试，几乎没有什么bug了，不愧是稳定版。Except one:链接wifi后打开QQ，总是需要延迟好长时间才能登录，用GPRS就没有这个问题。在网上搜了一下，发现好多人遇到过这种问题，而且问题所在应该是QQ使用特殊的网络协议造成的。</p>
<p>CM对原生安卓所做的改变主要是功能上的增强和人性化上的提升，UI很好的保留了原生安卓的样式。对于这个ROM我的感受是：轻、快、灵活、简洁、漂亮。（谷歌风格的漂亮，而不是小米风格的华丽丽）</p>
<p>还有一个优点是省电。前提是不要开启「自动同步」和「Google服务框架」。否则最耗电的不是屏幕了，而是google服务。</p>
<p>分享几个截图，用微博图床，不会挂了:)</p>
<a id="more"></a>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e85w6tmsy5j214u104tga.jpg" alt="锁屏与桌面"></p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e85w8o6e2hj214u1040yo.jpg" alt="应用抽屉与下拉菜单"></p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e85w9tqojoj214u104qa9.jpg" alt="Google+与Youtube"></p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e85wak10zhj214u104jzj.jpg" alt="Twitter与Jelly Bean"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[轻松搞定Markdown]]></title>
      <url>http://codeinterviews.com/easy-markdown/</url>
      <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e85r40u55hj20b40b4q2x.jpg" alt=""></p>
<p>之前写过<a href="http://localhost:4000/2013/05/22/introduction-to-markdown/" target="_blank" rel="external">《Markdown指南》</a>和<a href="http://localhost:4000/2013/06/06/markdown-extras/" target="_blank" rel="external">《markdown 番外篇》</a>用来介绍Markdown，前者是入门资料索引，后者是几个稍微高级的用法，都只是介绍了片面，不太好。</p>
<p>使用Markdown写博客已经三个月了，对这个标记语言很是喜欢。现在流行的教程，要么就是太复杂太难以理解，要么就是太简单太肤浅，稍微高级点的用法没有提及。本文的初衷就是用最容易理解的方式，把Markdown入门到高级用法一一介绍给读者。看完之后，你不仅可以开始使用Markdown写东西，在日常使用中也随时可以打开这篇博客参考各种用法。</p>
<a id="more"></a>
<p><strong>为什么学习Markdown？</strong>别问为什么，尽管学习就好了。这么简单的东西，一会就能学会，受益可能终生，太值了。</p>
<p><strong>怎么学习Markdown？</strong>我认为最好的方法是通过示例，本文正式采用这样的方法。</p>
<p><strong>在哪可以使用Markdown？</strong> 你可以在<a href="http://jianshu.io/" target="_blank" rel="external">简书</a>、<a href="http://logdown.com/" target="_blank" rel="external">Logdown</a>这样的免费平台用Markdown写博客。如果你愿意折腾，也可以像我一样，使用hexo搭建自己的博客，并用Markdown书写博客，请参考拙作<a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">《hexo系列教程》</a>。另外，现在写论文也流行使用Markdown，不学你就out了！</p>
<p><strong>怎样开始？</strong>打开<a href="http://ghosertblog.github.io/mdeditor/" target="_blank" rel="external">这个网址</a>，把下面学到的东西在这个里面练习。左侧是Markdown，右侧是实时的显示。</p>
<p><strong>还要注意什么？</strong>一个效果，有时候可以通过不同的方式生成，比如无序列表可以用<code>- + *</code>。本文从实践出发，只列举最好用的一种。读者也只需要学习一种。</p>
<p>以下是Markdown代码：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#这里是一级标题</span></span><br><span class="line"><span class="section">###这里是三级标题</span></span><br><span class="line"><span class="section">######这里是六级标题，就到这里了，木有七级！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">段落前面没有缩进，看到了吧。</span><br><span class="line"></span><br><span class="line">　　要想使用缩进，在中文输入法中改成「全角」输入，再按两个空格</span><br><span class="line"></span><br><span class="line">行尾一个回车换行，显示效果依然是是一行。</span><br><span class="line">我说的对吧~</span><br><span class="line"></span><br><span class="line">想要分成两行，需要在行尾输入两个空格。  </span><br><span class="line">我说的对吧~</span><br><span class="line"></span><br><span class="line">想要开始一个新的段落，乖乖的按两下回车吧</span><br><span class="line"></span><br><span class="line">我说的对吧~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="strong">**两个星号包围的是粗体**</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*一个星号包围的是斜体*</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 引用内容，多行的话，用两个空格结尾吧  </span></span><br><span class="line">是吧~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="code">`反引号包围的是行内代码`</span>，这个按键在「Tab」上边</span><br><span class="line"></span><br><span class="line"><span class="code">``嵌套的话，可以使用`</span>两个双引号<span class="code">`嵌套在外面`</span>`</span><br><span class="line"></span><br><span class="line"><span class="code">```python</span><br><span class="line">#三个反引号包围的是代码块。</span><br><span class="line">#会显示行号。</span><br><span class="line">#也有高亮显示</span><br><span class="line">#我上面加了python，你也可以不加。如果不能高亮，那么还是加上吧。。另外，如果你的代码块包围的是html，那你应该写html而不是python</span><br><span class="line">import os</span><br><span class="line">print os.sep</span><br><span class="line">```</span></span><br><span class="line">嵌套的话，可以使用六个反引号嵌套在外面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>有序列表1，注意点之后的空格。</span><br><span class="line"><span class="bullet">2. </span>有序列表2.</span><br><span class="line"><span class="bullet">1. </span>我这里写成1，在显示时还是3，厉害不。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>有序列表1</span><br><span class="line"> 详细内容，注意前面有一个空格</span><br><span class="line"><span class="bullet">2. </span>有序列表2</span><br><span class="line"> 详细内容</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>无序列表1</span><br><span class="line"><span class="bullet">- </span>无序列表2</span><br><span class="line"><span class="bullet">- </span>无序列表3</span><br><span class="line"> - 小1，注意前面有一个空格</span><br><span class="line"> - 小2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">超级链接：[<span class="string">我的博客</span>](<span class="link">http://zipperary.com</span>)</span><br><span class="line"></span><br><span class="line">插入图片：![<span class="string">好看不</span>](<span class="link">http://ww2.sinaimg.cn/large/5e8cb366jw1e62o63tkv3j20dh078q5a.jpg</span>)</span><br><span class="line"></span><br><span class="line">另外，markdown完全兼容html，你可以用html插入这些东西，例如：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">498</span> <span class="attr">width</span>=<span class="string">510</span> <span class="attr">src</span>=<span class="string">"http://player.youku.com/embed/XMjI2MjU3MDMy"</span> <span class="attr">frameborder</span>=<span class="string">0</span> <span class="attr">allowfullscreen</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~删除线~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分割线用<span class="code">`---`</span>，注意单独一样，上面必须是一个空行</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">更多高级的格式，请果断插入html标签</span><br></pre></td></tr></table></figure>
<p>以下到结尾处是效果：</p>
<p>#这里是一级标题</p>
<p>###这里是三级标题</p>
<p>######这里是六级标题，就到这里了，木有七级！</p>
<p>段落前面没有缩进，看到了吧。</p>
<p>　　要想使用缩进，在中文输入法中改成「全角」输入，再按两个空格</p>
<p>行尾一个回车换行，显示效果依然是是一行。<br>我说的对吧~</p>
<p>想要分成两行，需要在行尾输入两个空格。<br>我说的对吧~</p>
<p>想要开始一个新的段落，乖乖的按两下回车吧</p>
<p>我说的对吧~</p>
<p><strong>两个星号包围的是粗体</strong></p>
<p><em>一个星号包围的是斜体</em></p>
<blockquote>
<p>引用内容，多行的话，用两个空格结尾吧<br>是吧~</p>
</blockquote>
<p><code>反引号包围的是行内代码</code>，这个按键在「Tab」上边</p>
<p><code>嵌套的话，可以使用`两个双引号`嵌套在外面</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#三个反引号包围的是代码块。</span></span><br><span class="line"><span class="comment">#会显示行号。</span></span><br><span class="line"><span class="comment">#也有高亮显示</span></span><br><span class="line"><span class="comment">#我上面加了python，你也可以不加。如果不能高亮，那么还是加上吧。。另外，如果你的代码块包围的是html，那你应该写html而不是python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">print</span> os.sep</span><br></pre></td></tr></table></figure>
<p>嵌套的话，可以使用六个反引号嵌套在外面。</p>
<ol>
<li>有序列表1，注意点之后的空格。</li>
<li>有序列表2。</li>
<li>我这里写成1，在显示时还是3，厉害不。</li>
</ol>
<ol>
<li><p>有序列表1</p>
<p>详细内容，注意该行和上面一行，前面有一个空格</p>
</li>
<li><p>有序列表2</p>
<p>详细内容</p>
</li>
</ol>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
<li>无序列表3<ul>
<li>小1，注意前面有一个空格</li>
<li>小2</li>
</ul>
</li>
</ul>
<p>超级链接：<a href="http://zipperary.com" target="_blank" rel="external">我的博客</a></p>
<p>插入图片：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e62o63tkv3j20dh078q5a.jpg" alt="好看不"></p>
<p>另外，markdown完全兼容html，你可以用html插入这些东西，例如：</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XMjI2MjU3MDMy" frameborder="0" allowfullscreen></iframe>



<p><del>删除线</del></p>
<p>分割线用<code>---</code>，注意单独一行，上面必须是一个空行</p>
<hr>
<p>更多高级的格式，请果断插入html标签</p>
<hr>
<p>爱打卡-100days-第95天-0011</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[强大的rails]]></title>
      <url>http://codeinterviews.com/qiang-da-de-rails/</url>
      <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e85o6gmq6cj211y0kq0wa.jpg" alt=""></p>
<p>Ruby的入门，在<a href="http://zipperary.com/2013/08/28/ruby-on/" target="_blank" rel="external">Ruby走起</a>一文之前就结束了。这两天各种闲杂之事，断断续续的学习了一些rails的知识。主要参考了地瓜哥的<a href="http://www.diguage.com/archives/tag/ruby" target="_blank" rel="external">《Agile Web Development with Rails》抄书笔记</a>系列文章。rails的入门教程，首推《Agile Web Development with Rails》这本书。这个系列的博客，是地瓜哥学习这本书的过程，不仅把书中的内容清晰的展示在博客中，同时把他自己遇到过的问题、解决的办法和发现的好资料都分享在这里，干货值非常高。rails的强大之处在于，只需要几个简单的命令，一个网站所需要的结构和文件都会自动创建，立即可以使用。如果需要，仅需修改默认值即可。这里概括一下基本的流程。</p>
<a id="more"></a>
<p>###安装</p>
<p>尽管前辈们都列出了<code>mac &gt; linux &gt;&gt; windows</code>，对于我来说，mac木有，linux折腾不起，还是win吧。windows用户有福了，安装特别简单。</p>
<p><strong>下载并安装<a href="http://railsinstaller.org/" target="_blank" rel="external">Rails Installer</a>。</strong></p>
<p>这一步会安装好以下组件：<br>Ruby<br>Rails<br>Bundler<br>Git<br>Sqlite<br>TinyTDS<br>SQLServerSupport<br>DevKit</p>
<p>安装好之后，进入终端，使用<code>ruby -v</code>和<code>rails -v</code>查看版本号。</p>
<p>值得一提的是，对于中国用户，最好修改gem源，该用淘宝提供的镜像，速度刷刷的。</p>
<p>在终端依次输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem sources -l</span><br><span class="line">gem sources --remove https://rubygems.org/ </span><br><span class="line">gem sources -a http://ruby.taobao.org/</span><br></pre></td></tr></table></figure></p>
<p>最后再<code>gem sources -l</code>，确保目前的镜像是淘宝的。</p>
<p>###开发项目</p>
<p>从头开发一个项目，大概有这么几个流程：</p>
<ol>
<li><p><code>rails new demo</code> 新建一个项目，会在当前目录下生成项目的文件夹。然后就可以<code>rails s</code>运行服务器，打开终端提示的地址查看web。<em>后面的几个命令都需要切换到demo目录下执行</em></p>
</li>
<li><p><code>rails generate scaffold Product title:string description:text</code> 这个命令非常强大。我们知道，rails是MVC架构。这个命令会生成Product这个controller、相应的view、model，以及product数据表，并自动将这些组件进行关联。也就是说，生成这个数据表，以及跟数据表相关的各种操作功能。</p>
</li>
<li><p><code>rake db:migrate</code> rake命令有点像linux中的make，它会自动跟踪并查找没有执行过的迁移脚本，并执行迁移工作。对于我们这个例子，它的工作就是具体生成数据库及product表。</p>
</li>
<li><p><code>rake test</code> 自动执行测试工作，并报告测试结果。</p>
</li>
<li><p><code>rails s</code> 开启服务器，打开<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a>。你看到的绝对比你预想的多，这就是rails的强大。</p>
</li>
</ol>
<p>以上列举了rails最常用的命令和整体的流程。具体开发过程中的技巧细节，需要跟着教程一点点的学习和练习。我在学习过程中也会及时分享，请关注这个catagory。</p>
<p>顺便多说一句：Sublime Text真是太太太好用了！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ruby走起！]]></title>
      <url>http://codeinterviews.com/ruby-on/</url>
      <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e82h1gxsy6j20jf0e8js2.jpg" alt=""></p>
<p>为了在他们NB闪闪地聊Ruby时我能不跟个傻子似的呆若木鸡，为了回报那条「一月30K」的招聘启事对我的激励，为了不糟蹋收藏夹里面好些个Ruby相关的文章，也为了见识一下ROR（Ruby on Rails）的伟大，我决定以身犯难，拨开迷雾，学习ROR。</p>
<p>BTW，虽然Ruby的伟大之处十分得益于ROR，但Ruby毕竟是基础，ROR毕竟是框架，所以新开的这个分类叫做Ruby，向<strong>松本行弘</strong>致敬。同时遵循Ruby的命名规范，首字母大写。</p>
<p>Ruby中文社区的很多前辈在指导我们这些后生学习ROR时都说，没有Ruby基础的也可以直接上手Rails，不过最好稍微了解一点，不必太多，然后在rails中慢慢学习和体会ruby的闪光点。我很听话，照办。</p>
<p>关于Ruby和Rails的教程，数不胜数，文字和视频都有。我已经在为知笔记造过一次轮子了，不想在这里重复，而且我造出的轮子自用可以，拿出来就略献丑了。因此本文不再写Ruby教程之类的东西（也许以后把轮子打磨的漂亮之后会分享），而是列举一下目前发现的不错的文章、视频资料。</p>
<a id="more"></a>
<p>###站点</p>
<ul>
<li><p><a href="http://ruby-china.org/" target="_blank" rel="external">Ruby China</a>Ruby中文社区，注册一个账号，去里面发现好东西，必看</p>
</li>
<li><p><a href="http://railscasts-china.com/" target="_blank" rel="external">Railscasts China</a>Ruby视频教程，五花八门，琳琅满目，必看</p>
</li>
<li><p><a href="http://tryruby.org/levels/1/challenges/0" target="_blank" rel="external">Code School - TryRuby</a> 可以在线书写和执行Ruby代码</p>
</li>
</ul>
<p>###方法论、路线图</p>
<ul>
<li><p><a href="http://ruby-china.org/wiki" target="_blank" rel="external">Ruby China | Wiki</a>这里面的每篇文章都要看。入门的话，只要看<a href="http://ruby-china.org/wiki/start_leaning_rails" target="_blank" rel="external">Ruby China | 如何从零开始学会 Rails - Wiki</a></p>
</li>
<li><p><a href="http://yedingding.com/2013/04/22/rails-for-beginners.html" target="_blank" rel="external">Rails 初学者指南 | The Voice of Dingding Ye</a></p>
</li>
</ul>
<p>###教程</p>
<ul>
<li><p><a href="https://www.ruby-lang.org/zh_cn/documentation/quickstart/" target="_blank" rel="external">20分钟体验 Ruby</a>强烈推荐，快速对Ruby有个认识</p>
</li>
<li><p><a href="http://221.173.127.35:82/1Q2W3E4R5T6Y7U8I9O0P1Z2X3C4V5B/read.pudn.com/downloads74/ebook/268092/Ruby%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8Bv1.0.pdf" target="_blank" rel="external">Ruby语言入门教程v1.0.pdf</a>虽然有点久远，但是整理的很好，我从这里面收获很多</p>
</li>
<li><p><a href="http://saito.im/slide/ruby-new.html" target="_blank" rel="external">Ruby.new</a>一个Slide，简洁、漂亮、实用，收获很多</p>
</li>
<li><p><a href="http://railstutorial-china.org/" target="_blank" rel="external">Ruby on Rails 教程</a>中文版可以在线阅读，多人推荐</p>
</li>
<li><p><a href="http://guides.ruby-china.org/" target="_blank" rel="external">Ruby on Rails Guides 中文</a>中文版，版本是3.2.8，英文好的直接读官方的版本4<a href="http://guides.rubyonrails.org/" target="_blank" rel="external">Ruby on Rails Guides</a></p>
</li>
<li><p><a href="http://edu.51cto.com/course/course_id-418.html" target="_blank" rel="external">诱人的Ruby-入门篇（共18个课时）_51CTO视频课程</a></p>
</li>
<li><p><a href="http://www.codeschool.com/paths/ruby" target="_blank" rel="external">Ruby - Code School</a></p>
</li>
</ul>
<p>###其他</p>
<ul>
<li><p><a href="http://railsapps.github.io/" target="_blank" rel="external">Rails Examples and Tutorials · RailsApps</a> </p>
</li>
<li><p><a href="http://www.diguage.com/archives/tag/ruby" target="_blank" rel="external">Ruby | “地瓜哥”博客网</a></p>
</li>
<li><p>wiki里面说的所有参考书目，都可以在<a href="http://so.baiduyun.me/" target="_blank" rel="external">这里</a>搜索下载</p>
</li>
</ul>
<p>具体某个技术细节相关的文章就不列举了。这些是从我的为知笔记转移过来的，虽然五花八门，但我自己的话还是会跟着wiki里面的路线图走，这些权当参考吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓4.3，我来啦！]]></title>
      <url>http://codeinterviews.com/gai-shi-san-shua-ji-shou-ji/</url>
      <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e812xd4ow7j214u104q8i.jpg" alt=""></p>
<p>这两天折腾手机，把盖世三刷成了CM，随后各种设置各种恢复各种鼓捣。记录一下，以求对得起耽误的这些时间。</p>
<a id="more"></a>
<p>###备份数据</p>
<ol>
<li>用豌豆荚或百度云备份<em>通讯录和短信</em></li>
<li>用钛备份或豌豆荚（推荐）备份手机应用</li>
</ol>
<p>###刷机</p>
<ol>
<li><p>下载CM的<a href="http://wiki.cyanogenmod.org/w/I9300_Info" target="_blank" rel="external">ROM</a>。我用的是Nightly，最新的安卓4.3。另外，尽管我手机是联通版，但用的ROM是国际版。这里贴出CM和安卓的版本对应：</p>
<p><em>CM4（Android 1.6）、CM5（Android 2.1）、CM6（Android 2.2）、CM7（Android 2.3）、CM9（Android 4.0）、CM10（Android 4.1）、CM10.1（Android 4.2）、CM10.2（Android 4.3）。</em></p>
</li>
<li><p>下载谷歌服务框架。由于版权问题，CM默认不支持谷歌服务，需要自行刷入。<a href="http://goo.im/gapps" target="_blank" rel="external">这里</a>有所有的版本。</p>
</li>
<li><p>刷ROM。把ROM和谷歌服务框架放到手机内存卡中，关机，按住音量加+Home键+电源键,一秒后放开电源键，进入recovery。<br>选择wipe date/factory reset并yes。<br>选择wipe cache partition并yes。<br>选择并安装ROM。<br>选择并安装谷歌服务套件。<br>搞定，重启，刷机完毕。</p>
</li>
</ol>
<p>###恢复数据</p>
<ol>
<li>通过豌豆荚恢复通讯录、短信和应用。</li>
<li>通过钛备份恢复应用。<br>我在使用钛备份恢复时出现问题，所有应用无法恢复，怎么尝试都不行，最终放弃，一百多款应用就这么没了。只有把主要用的应用一一安装。幸亏有云，很多数据可以从云端拉下来。</li>
</ol>
<p>###CM设置</p>
<ol>
<li><p><code>设置-安全-未知来源</code>打上对勾，这样才能通过豌豆荚或Google Play安装应用。</p>
</li>
<li><p><code>设置-关于手机-版本号</code>点五次，打开手机的「开发者选项」，进入勾选「USB调试」。这样才能用USB连接PC上的豌豆荚。</p>
</li>
<li><p><strong>截图</strong>快捷键：电源键+音量减同时按下并松开。<code>设置-Buttons-电源菜单选项</code>勾选「屏幕截图」，这样就可以长按电源键进行截图了。</p>
</li>
</ol>
<p>###vpn</p>
<p> 尽管有fqrouter2这样的神器，我却还是不想浪费了vpn账号。</p>
<p> 安卓4.0以上的系统，vpn要使用必须设置密码锁，很不人道。有网友提出了一个解决方案，我试了试，果然简单好用。</p>
<ol>
<li>按照正常程序，设置密码锁，进入设置vpn。</li>
<li>按电源键关闭屏幕，再按一下，看到锁屏界面。故意输错5次，出现对话框，输入谷歌的账号密码解锁。看到几个密码锁的选项，直接无视，按返回键，搞定。手机重启后再使用vpn可能还会提示设置密码锁，直接返回键就可以进去了。</li>
</ol>
<p>###来自三星Galaxy S3</p>
<p> 新浪微博如果不是从「三星应用市场」下载安装，发微博时就无法显示「来自三星Galaxy S3」的微博尾巴，而是「来自Android客户端」，这样不够个性，不好。有办法！</p>
<p> 首先确保手机里没有微博客户端，有就卸载掉。</p>
<p> 到<a href="http://pan.baidu.com/share/link?shareid=685377599&amp;uk=1661888259" target="_blank" rel="external">这里</a>下载新浪微博为盖世三定制的微博客户端。安装好之后会看到版本很低，用豌豆尖或Google Play升级到最新版本。发个微博试试吧，尾巴回来了:)</p>
<p>###用钛备份恢复数据失败，导致这个应用无法安装</p>
<p> 如题，比如我用钛备份恢复扇贝单词失败了。通过豌豆荚下载安装时，提示我安装失败。我以为这辈子不能用扇贝了。但我想，既然不能安装，多半是因为手机里残留了跟扇贝有关的文件的缘故。于是我就找啊找，找啊找，找啊找…终于，在<code>/data/data</code>看到了他们的身影，果断删除，再安装就没问题了。</p>
<p>###相机功能缺失</p>
<p> 4.3原生的相机有很多改进，也有很多值得称道的地方，但我用惯了三星的相机，对这个不大喜欢。我从三星的ROM中提取出了三星的相机并安装。另外从老罗的锤子手机里提取出了非常好用的三个应用：计算器、便签、时钟，看官可以去<a href="http://pan.baidu.com/share/link?uk=1661888259&amp;shareid=1390201726" target="_blank" rel="external">这里</a>下载。</p>
<p> 安装方法：拷贝到<code>/system-app</code>，把权限设置的跟其他应用一样，再重启就好了。</p>
<hr>
<p>爱打卡-100days-第91天-0111</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识Sublime Text]]></title>
      <url>http://codeinterviews.com/go-to-sublime-text/</url>
      <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e7z6jqyv1hj211y0kqwi1.jpg" alt=""></p>
<p>看到很多人推荐神器<strong>Sublime Text</strong>，我今天也来玩玩。</p>
<p>官网的一句话广告：</p>
<blockquote>
<p>Sublime Text is a sophisticated text editor for code, markup and prose.</p>
</blockquote>
<p>维基百科的一句话简介：</p>
<blockquote>
<p>Sublime Text 是一套基于 Python 的跨平台文字编辑器。最初设计为 Vim 编辑器的多功能扩充软件。</p>
</blockquote>
<p>注意Sublime Text和<strong>python、vim</strong>的渊源，后面我们就会看到了。</p>
<p><em>声明：以下均为windows下操作，其他系统未测试。</em></p>
<a id="more"></a>
<p>###安装</p>
<p>去<a href="http://www.sublimetext.com/" target="_blank" rel="external">官网</a>下载和安装相应的版本。对于windows用户，有<em>安装版</em>和<em>绿色版</em>可选。推荐使用<strong>安装版</strong>。</p>
<p><em>注意：最新版本为3测试版，推荐下载2！</em></p>
<p>软件安装好了之后不需要任何配置就可以使用了。最常用的设置Sublime Text已经帮我们做好了，打开直接享用！</p>
<p>###插件管理</p>
<p>一个NB的编辑器之所以NB，插件支持是一个重要的元素。Sublime Text有一个插件管理器是必装的。</p>
<p><code>ctrl+</code>打开<strong>Console</strong>，把下面的代码复制进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib2,os; pf=&apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &apos;wb&apos; ).write( urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; +pf.replace( &apos; &apos;,&apos;%20&apos; )).read()); print( &apos;Please restart Sublime Text to finish installation&apos;)</span><br></pre></td></tr></table></figure>
<p>回车键。</p>
<p>重启，如果看到<code>Preferences &gt; Package Control</code>就说明成功了。</p>
<p>如果上面的方法安装失败，使用下面这个办法：</p>
<ol>
<li>Click <code>the Preferences &gt; Browse Packages…</code>menu</li>
<li>Browse up a folder and then into the <code>Installed Packages/</code> folder</li>
<li>Download <a href="https://sublime.wbond.net/Package%20Control.sublime-package" target="_blank" rel="external">Package Control.sublime-package</a> and copy it into the <code>Installed Packages/</code> directory</li>
<li>Restart Sublime Text</li>
</ol>
<p>插件管理器搞定之后，就可以随意安装插件了。方法很简单：</p>
<p><code>ctrl+shift+p</code>，输入<code>ip</code>，看到「Install Package」，回车键。然后出现插件列表，在里面输入要找的插件，比如<strong>tag</strong>，选中并回车即可自动安装好。</p>
<p>###常用插件</p>
<p>我今天才开始用，安装的插件很少。下面是网友推荐的几个，我只安装了一部分。</p>
<ul>
<li><p>tag：Html格式化，右键Auto-Format Tags on Ducument。</p>
</li>
<li><p>ZenCoding：不得不用的一款前端开发方面的插件，Write less , show more.安装后可直接使用，Tab键触发，Alt+Shift+W是个代码机器。</p>
</li>
<li><p>SideBarEnhancements：侧栏右键功能增强，非常实用。</p>
</li>
<li><p>Theme–Soda：完美的编码主题，用过的都说好，Setting user里面添加”theme”: “Soda Dark.sublime-theme”。</p>
</li>
<li><p>SublimeLinter：这是用来在写代码时做代码检查的。可以在包管理器中安装。写Python程序的话，它还会帮你查代码是否符合PEP8的要求。有问题有代码会出现白框，点击时底下的状态栏会提示出什么问题。</p>
</li>
<li><p>Python PEP8 Autoformat：这是用来按PEP8自动格式化代码的。可以在包管理器中安装。如果以前写程序不留意的话，用SublimeLinter一查，满屏都是白框框，只要装上这个包，按ctrl+shift+r，代码就会按PEP8要求自动格式化了，一屏的白框几乎都消失了。</p>
</li>
<li><p>Alignment：代码对齐，如写几个变量，选中这几行，Ctrl+Alt+A，哇，齐了。</p>
</li>
</ul>
<p>###快捷键</p>
<p>前面说过，Sublime Text跟Vim渊源极深，软件安装好之后也是默认支持Vim模式的。所以很多vimer熟悉的快捷键和操作方式在这里同样使用，甚至也分为普通模式和插入模式，但命令模式有很多不同。</p>
<p>这里只列举最有用且不同于vim的一些快捷键，以后发现更多好用的后会再行补充。</p>
<ul>
<li><code>ctrl+shift+p</code> 打开命令提示窗口，你所要的，这里都有:)</li>
<li><code>ctrl+` </code> 打开console</li>
<li><code>ctrl+r</code> 查找函数和块，非常有用</li>
<li><code>ctrl+/</code> 注释和解注释</li>
<li><code>ctrl+p</code> 切换打开的文件</li>
<li><code>ctrl+w</code> 关闭当前标签页</li>
<li><code>ctrl+shift+w</code> 关闭所有打开的标签页</li>
<li><code>ctrl+m</code> 跳转到该位置前后的括号</li>
<li><code>ctrl+k+b</code> 开关侧边栏</li>
<li><code>alt+n</code> 快速切换到第n个打开的标签页</li>
<li><code>F11</code> 全屏模式</li>
<li><code>shift+F11</code> 防打扰模式</li>
</ul>
<p>###赞许</p>
<p>好看。</p>
<p>方便好用。</p>
<p>###抱怨</p>
<p>markdown的高亮支持惨不忍睹，也没有好用的插件可以替代。</p>
<hr>
<p>爱打卡-100days-第89天-0111</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vim使用中的几个问题]]></title>
      <url>http://codeinterviews.com/vim-tips/</url>
      <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e7y2y7xlk0j20it0ectbi.jpg" alt=""></p>
<p>使用VIM做主编辑器有一段时间了，快捷键和命令用的越来越熟练。本文将使用过程中遇到的问题、解决方案和一些好用的技巧汇总如下，并不定时更新。</p>
<p>###查找之后高亮显示的词怎么取消高亮？</p>
<p>说明：通常我们会用<code>:/bla[Enter]</code>查询文中出现的<em>bla</em>，并以高亮显示。可以通过<code>n</code>和<code>N</code>查找下一个和上一个。查找完之后，高亮显示并不会消失，这样会影响阅读其他的代码或文字。</p>
<p>解决：使用<code>:noh</code>命令。</p>
<a id="more"></a>
<p>###插入模式下怎么进行光标移动？</p>
<p>说明：当然，可以使用方向键进行移动。但Vimer通常不会这么干。难道每次都要<code>Esc</code>回到<em>普通模式</em>再移动吗？</p>
<p>解决：根据前辈们的说法，Vimer要有一个意识，就是默认保持普通模式。除此之外，一切都是命令。比如插入文字的命令为<code>iblabla</code>，执行「命令」的命令为<code>:bla</code>。所以，要想移动光标，乖乖回到普通模式吧。</p>
<p>但是我们都知道<code>Esc</code>的键程太远，老这么按很费劲。于是大家就进行快捷键的映射。我找到的最好的解决方案是用<code>jj</code>替代<code>Esc</code>。</p>
<p>在<code>.vimrc</code>中加入这一样：</p>
<p><code>imap jj &lt;Esc&gt;</code></p>
<p>有人会说，那我要输入「jj」肿么办呢？这种情况是很少的，编程的实践证明几乎不会用到这个组合词。如果万一用到，那么输入一个j，稍等一秒再输入另外一个即可。</p>
<p>当然，你也可以映射到<code>Caps Lock</code>，悉听尊便。</p>
<p>###怎样在Windows右键菜单中加入「用Vim编辑」？</p>
<p>Windows下安装gvim会默认在右键菜单中添加这一项。我前两天清理无用的注册表，这一项不幸被360吃掉了。乖乖修改注册表吧~</p>
<ol>
<li><p>按下<code>Win + r</code>，输入<code>regedit</code>打开注册表。</p>
</li>
<li><p>找到<code>HKEY_CLASSES_ROOT\*\Shell</code>。</p>
</li>
<li><p>用鼠标右键添加项，名字叫「用Vim编辑」，再在这个文件夹上点击右键添加项，起名叫做「command」。</p>
</li>
<li><p>编辑项的值为<code>&quot;E:\\Program Files\\Vim\\vim74\\gvim.exe&quot; -p &quot;%1&quot;</code>，具体路径根据自己电脑情况而定。</p>
</li>
</ol>
<p>用类似的方式，还可以添加「用vim新标签编辑」。只需要修改相应的名字，并将项目的值写为<code>&quot;E:\\Program Files\\Vim\\vim74\\gvim.exe&quot; -p --remote-tab-silent &quot;%1&quot;</code>即可。</p>
<p>###tips</p>
<ol>
<li><p>反向的操作常常用<code>Shift</code>。比如删除前一个字符用<code>x</code>，那么删除后一个字符用<code>Shift + x</code>，也就是<code>X</code>。</p>
</li>
<li><p>数字的运用。数字是规定操作重复次数的，有时候非常有用。比如<code>10dd</code>是删除10行。</p>
</li>
<li><p><code>.</code>重复上一个操作。</p>
</li>
<li><p>block级别的光标移动。比如移动到函数的开头用<code>[[</code>，结尾用<code>]]</code>。</p>
</li>
<li><p>批量缩进。普通模式下<code>v</code>进入选择模式，通过移动光标选择几行，然后<code>&lt;</code>和<code>&gt;</code>可以分别对这几行进行向左缩进和向右缩进。<code>=</code>可以自动缩进。非常好用。</p>
</li>
<li><p>自动补全。<code>Ctrl + n</code>。</p>
</li>
<li><p>buffer常用操作。</p>
<p><code>:ls</code>列出buffer里面的所有文件。</p>
<p><code>:bn</code>打开buffer里面编号为n的文件。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[elementary os]]></title>
      <url>http://codeinterviews.com/elementary-os/</url>
      <content type="html"><![CDATA[<p>把Ubuntu系统删除之后，在win7上装了虚拟机运行elementary os，一个设计出色的类ubuntu的linux发行版。简要记录一下过程，<strong>并分享几张截图</strong>。</p>
<p>###安装Vmvare</p>
<p>首先安装虚拟机。我的笔记本是win7 32位系统。</p>
<ol>
<li><p>下载<a href="http://pan.baidu.com/share/link?shareid=2928125003&amp;uk=1661888259" target="_blank" rel="external">VMware9-workstation_官方原版+完美稳定的汉化补丁+VMware9注册机.rar</a>，并解压。</p>
</li>
<li><p>根据文件夹里的说明进行安装。</p>
</li>
</ol>
<p>安装过程可能遇到一个图示的问题：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e7vn5a0rgxj209w05cjrj.jpg" alt=""></p>
<p>解决办法是：</p>
<ol>
<li>在运行中键入 “regedit” 获取注册表</li>
<li>删除 HKEY_LOCAL_MACHINE\SOFTWARE\VMware, Inc.</li>
<li>重新安装VMware即可。</li>
</ol>
<a id="more"></a>
<p>###安装elementary os</p>
<ol>
<li><p>下载<a href="http://pan.baidu.com/share/link?shareid=2964731970&amp;uk=1661888259" target="_blank" rel="external">elementaryos-stable-i386.20130810.iso</a>。</p>
</li>
<li><p>运行vmware，进行安装。<a href="http://www.cnblogs.com/achillesyang/archive/2012/06/21/2557152.html" target="_blank" rel="external">这里</a>有详细的图文说明，虽然是ubuntu，但区别不大。</p>
</li>
</ol>
<p>需要说明的是：</p>
<ul>
<li>在<strong>网络配置</strong>那一步，选择NAT就可以了，安装好之后不用设置即可上网。</li>
<li>内存大小选择1G，硬盘大小8G，CPU选择双核。</li>
</ul>
<p>###晒图</p>
<p>好了，安装过程很简单，这里把elementary os系统截图分享给大家。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e7vmppa7u8j20vo0f40sy.jpg" alt="启动画面"></p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e7vmr7lie1j211s0lcgt4.jpg" alt="漂亮的桌面和终端"></p>
<p><img src="http://ww3.sinaimg.cn/large/5e8cb366jw1e7vmrq1scgj211s0lcacy.jpg" alt="自带浏览器"></p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e7vmshrv63j211s0lctdh.jpg" alt="文件浏览器"></p>
<hr>
<p>###PS</p>
<ol>
<li><p>今天百度1元1T永久网盘空间。360随后推出免费1T永久网盘空间。网民乐开花。</p>
</li>
<li><p>济南中院对薄熙来案子公开审理，中院官方微博进行图文直播，「庭审现场」详细叙说庭审的过程，我从早上跟到了傍晚，很有意思。</p>
</li>
</ol>
<hr>
<p>爱打卡-100days-第86天-0111</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[批量下载mlook电子书]]></title>
      <url>http://codeinterviews.com/downloading-mlook/</url>
      <content type="html"><![CDATA[<p><img src="http://webbies.dk/assets/templates/SudoSlider/images/download_box.png" alt=""></p>
<p>这几天断断续续完成了这个爬虫程序，功能是批量下载<a href="http://mlook.mobi/" target="_blank" rel="external">http://mlook.mobi/</a>中mobi和epub格式的电子书。</p>
<p>中间遇到了几个困难，个个耗费了我不少心神。目前这个程序已经可以正常使用，但还有许多值得改进的地方。我把脚本放在gist，日后更新版本后会直接在本篇博客中显示。</p>
<a id="more"></a>
<p>先贴代码：</p>
<script src="https://gist.github.com/zippera/6260748.js"></script>

<p>几点说明：</p>
<ol>
<li><p>使用时在该脚本目录下运行<code>python mlook_ebooks.py</code>并输入要下载页数即可自动下载。</p>
</li>
<li><p>该程序依赖第三方包：requests和BeautifulSoup4。</p>
</li>
<li><p>只下载mobi和epub格式，其他格式没意思。</p>
</li>
<li><p>改程序改到比较满意后会详细介绍其中用到的技术。</p>
</li>
</ol>
<hr>
<p>####推荐</p>
<p>Youtube视频下载插件：<a href="http://pan.baidu.com/share/link?shareid=488296723&amp;uk=1661888259" target="_blank" rel="external">点此获得</a></p>
<p>使用方法：下载之后，拖到chrome的「扩展程序」页面即可自动安装。再打开youtube的视频页面就可以在下边看到下载按钮了，可以选择各种画质进行下载。</p>
<hr>
<p>爱打卡-100days-第82天-0111</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS学习笔记]]></title>
      <url>http://codeinterviews.com/css-notes/</url>
      <content type="html"><![CDATA[<p><img src="http://images.51cto.com/files/uploadimg/20120913/0953270.png" alt=""></p>
<p>之前做网站自己搞前端，在<strong>w3cschool</strong>杂乱地把html，css，jquery，ajax的教程学习了一遍，然后用刚刚诞生不久的Bootstrap作为前端框架，算来我属于BS最早的一批用户了:)</p>
<p> 最近学python之外，很想把CSS、jquery学的更好一点。把原来做过的笔记复习了一下，然后打开Bootstrap的<strong>Bootstrap.css</strong>，一行一行地看，不会的一一Google，在旁边做注释。不过这个工程量太大了，其实很多是重复的，不必要全部都看。</p>
<p> 看过一些后我就去改博客的样式。Hexo用的是stylus，而不是直接用CSS，所以先简单学了下stylus的语法，很简单，只是把CSS语法简化了，<a href="http://learnboost.github.io/stylus/" target="_blank" rel="external">官网首页</a>写的很明白。在学习Bootstrap的CSS文件时，主要用到了w3cschool的<a href="http://www.w3school.com.cn/css/css_reference.asp" target="_blank" rel="external">CSS参考手册</a>，「Ctrl + F」找到后点进去会有详实的解释和生动的例子，很好用。</p>
<p>废话少说，这篇博客主要是把目前的笔记贴上来。</p>
<a id="more"></a>
<p>###简介</p>
<p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。</p>
<p>选择器通常是您需要改变样式的 HTML 元素。每条声明由一个属性和一个值组成。属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。</p>
<p>###引用CSS</p>
<ol>
<li><p><strong>外部样式表</strong> <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot; /&gt;</code></p>
</li>
<li><p><strong>内部样式表</strong> <code>&lt;style type=&quot;text/css&quot;&gt;css代码&lt;/style&gt;</code></p>
</li>
<li><p><strong>内联样式表</strong> 写在html标签内。</p>
</li>
</ol>
<p>这里需要注意的是，如果一个样式在三个里面都有，那么优先级依次提高，也就是说最终会使用3里面的这个。</p>
<p>###常用规则</p>
<ul>
<li>子元素继承后，可override。</li>
<li>上下文选择器（所有后代） (contextual selectors) <code>li strong {...}</code></li>
<li>子元素选择器（直接后代）<code>h1 &gt; strong</code></li>
<li>相邻兄弟选择器 <code>h1 + p</code></li>
<li>id派生 <code>#sidebar p</code></li>
<li>类选择器 <code>.center</code>  也可派生</li>
<li>属性选择器 <code>[title]{...}</code></li>
<li>属性和值选择器 <code>[title=W3School]</code> 另外，<code>[title~=hello]</code>值里面包含hello的<code>[lang|=en]</code>值中有连字符</li>
</ul>
<p>###浏览器私有属性</p>
<p>不同浏览器对CSS的支持不尽相同，有些属性只有特定的浏览器才支持。</p>
<p>-moz、-ms、-webkit 、-o</p>
<p>分别为firefox、IE、chrome及safari、opera。</p>
<p>###注意事项</p>
<ol>
<li><p><strong>一切皆为框</strong>（可通过display改变）。div、h1 或 p元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。</p>
</li>
<li><p><strong>定位机制</strong>。有三种基本的定位机制：普通流、浮动和绝对定位。除非专门指定，否则所有框都在普通流中定位。（按照标签出现的位置）<br>相对定位：相对于原位置进行移动。原来的位置仍然占据。<br>绝对定位：是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p>
</li>
<li><p><strong>颜色</strong>。当使用RGB百分比时，即使当值为0时也要写百分比符号。</p>
</li>
<li><p><strong>注释</strong>。用<code>/*...*/</code></p>
</li>
<li><p><strong>通配符</strong>。可以使用星号作为通配符。</p>
</li>
</ol>
<p>###几个高级应用举例</p>
<ol>
<li><p><code>text-shadow: 0 1px 0 rgba(255,255,255,.1);</code></p>
<p>这个可以用来设置字体的阴影效果。各值的含义分别为：横向偏移、纵向偏移、阴影宽度、阴影颜色。</p>
</li>
<li><p><code>transition:width 2s;</code></p>
<p>样式过渡效果，第一个值是需要过渡的css selector，第二个是过渡的速度（时间）。比如鼠标放在一个元素上，该元素便开始过渡到另一种样式。</p>
</li>
<li><p><code>background-image: -webkit-linear-gradient(left, rgba(0,0,0,0), rgba(0,0,0,.1));</code></p>
<p>颜色过渡效果。这里用webkit指明是chrome或safari浏览器才有的私有属性。并且通过linear指明是线性过渡。各值的意义分别为：过渡方向（从左到右）、开始颜色、停止颜色。</p>
</li>
</ol>
<p>CSS的规则很简单，但小知识点很多，企图一下学完并记住是不现实的。最好记住上面这些基本的规则，用好上述的手册，遇到好看的样式时就分析学习一下，写个例子应用试试，日积月累才能学好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Python模拟浏览器登录]]></title>
      <url>http://codeinterviews.com/python-login/</url>
      <content type="html"><![CDATA[<p><img src="http://www.adafruit.com/adablog/wp-content/uploads/2012/03/index-18.jpg" alt=""></p>
<p>我的博客中曾经贴过几个爬虫程序的<a href="http://zipperary.com/categories/python/" target="_blank" rel="external">代码</a>，用来批量下载图片非常方便。这样的爬虫实现起来比较简单。而有些网站需要用户登录之后才可以下载文件，之前的方法就办不到了。今天就说说用Python模拟浏览器的登录过程，为之后的登录下载做好准备。</p>
<p>登录的情况，需要额外用到的一个模块是<strong>cookielib</strong>，用来记住登录成功之后保存到本地的cookie，方便在网站的各个页面之间穿越。</p>
<a id="more"></a>
<p>先上代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf8</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> cookielib</span><br><span class="line"></span><br><span class="line"><span class="comment">###登录页的url</span></span><br><span class="line">lgurl = <span class="string">'http://mlook.mobi/member/login'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###用cookielib模块创建一个对象，再用urlllib2模块创建一个cookie的handler</span></span><br><span class="line">cookie = cookielib.CookieJar()</span><br><span class="line">cookie_handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment">###有些网站反爬虫，这里用headers把程序伪装成浏览器</span></span><br><span class="line">hds = &#123; <span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.72 Safari/537.36'</span> &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">###登录需要提交的表单</span></span><br><span class="line">pstdata = &#123;<span class="string">'formhash'</span>:<span class="string">''</span>, <span class="comment">#填入formhash</span></span><br><span class="line">	<span class="string">'person[login]'</span>:<span class="string">''</span>, <span class="comment">#填入网站的用户名</span></span><br><span class="line">	<span class="string">'person[password]'</span>:<span class="string">''</span>, <span class="comment">#填入网站密码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">dt = urllib.urlencode(pstdata) <span class="comment">#表单数据编码成url识别的格式</span></span><br><span class="line">req = urllib2.Request(url = lgurl,data = dt,headers = hds) <span class="comment">#伪装成浏览器，访问该页面，并POST表单数据，这里并没有实际访问，只是创建了一个有该功能的对象</span></span><br><span class="line">opener = urllib2.build_opener(cookie_handler) <span class="comment">#绑定handler，创建一个自定义的opener</span></span><br><span class="line">response = opener.open(req)<span class="comment">#请求网页，返回句柄</span></span><br><span class="line">page = response.read()<span class="comment">#读取并返回网页内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> page <span class="comment">#打印到终端显示</span></span><br></pre></td></tr></table></figure>
<p>说明一下：</p>
<ol>
<li><p>我这里就不提供用户名密码了。关于需要提交的表单数据，chrome用户可以<code>F12 -&gt; Network -&gt; 填好账号密码并登录 -&gt; 在Network找到POST...</code>，请看截图。</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e7oseux1hbj20n306xq40.jpg" alt=""></p>
<p>点击「login」进入下图界面。</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e7osfs2qz2j20hm06x0tz.jpg" alt=""><br>「From Data」里面数据比较多，通常需要用户名、密码，其余的数据是否必要，需要测试一下。对于这个网站，还需要「formhash」。</p>
</li>
<li><p>Linux下无编码问题，win下如果出现编码问题应该是终端对编码的支持不到位。</p>
</li>
<li><p>登录成功之后，我们创建的cookie_handler会自动管理cookie，程序的后面如果需要访问其他页面，用opener打开其url即可。</p>
</li>
<li><p>「User-Agent」同样可以通过F12查看到。</p>
</li>
<li><p>更详细更nice的说明请参考<a href="http://blog.csdn.net/wxg694175346/article/category/1418998" target="_blank" rel="external">这里</a></p>
</li>
<li><p>这篇博客重点不在介绍原理，重点是记录下这个简单的代码块，其他需要登录的爬虫仿写就可以了。</p>
</li>
</ol>
<p>这个程序的目的是批量下载mlook的电子书。现在遇到一个问题：</p>
<p>下载时网站会验证cookie，不通过就没法下载。但是，我们用python下载文件一般是通过<code>urllib.urlretrieve()</code>。问题来了，这种方式没办法跟opener绑定到一起。</p>
<p>一种可能的解决办法是用opener打开下载链接，用open和write方式保存。但这个方法消耗比较大。</p>
<p>程序完成后会共享到这里。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python安装、升级和包管理]]></title>
      <url>http://codeinterviews.com/python-upgrade/</url>
      <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e7m0eyh2i1j20m80go0tk.jpg" alt=""></p>
<a id="more"></a>
<p>昨天之前，我win下的python版本一直是2.6.x。最近安装各种第三方包的时候频频出现兼容或依赖方面的错误，版本比较旧，的确改升级了。python的版本分为2系和3系，且各版本之间可以同时存在。由于我前几天看过《Dive into python3》，正好想练习一下，又由于第三方库对python2的支持是最好的，所以我选择同时安装2.7.5和3.3。下面说一下升级的过程（以win7下2.7.5为例）：</p>
<ol>
<li><p>安装<strong>python</strong>：到python<a href="http://www.python.org/getit/" target="_blank" rel="external">官网</a>下载2.7.5win版的二进制文件，双击安装，设置默认。</p>
</li>
<li><p>修改或添加环境变量：<code>C:\Python27;C:\Python27\Scripts;</code>。现在就可以在cmd里面运行<code>python</code>了，如果失败，重启cmd再运行。</p>
</li>
<li><p>安装<strong>setuptools</strong>（有了这个才能安装第三方的包）：到<a href="https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py" target="_blank" rel="external">这里</a>下载<strong>ez_setup.py</strong>，在其所在的目录下运行<code>python es_setup.py</code>即可安装。</p>
</li>
<li><p>安装<strong>pip</strong>（包管理器，可以方便的安装各种第三方包）：到<a href="https://github.com/pypa/pip/releases" target="_blank" rel="external">这里</a>下载最新版本的源代码包ø，解压之后进入目录，运行<code>python setup.py install</code>即可安装。</p>
</li>
<li><p>安装需要的<strong>第三方包</strong>，以shadowsocks为例，运行<code>pip install shadowsocks</code>。如果提示成功，那恭喜你哦了。如果提示<code>could not fetch url https...</code>，说明你的ssl和pip不兼容。最好的解决办法是，回到第4步，下载1.2版本并安装。这个版本会默认通过http方式获得包，而不是https。</p>
</li>
</ol>
<p>好人做到底，再列举一下pip最常用的几个命令：</p>
<ul>
<li><p><code>pip install foo</code>       安装包foo</p>
</li>
<li><p><code>pip uninstall foo</code>   卸载包foo</p>
</li>
<li><p><code>pip install -upgrade foo</code>    升级包foo</p>
</li>
<li><p><code>pip show --files foo</code>    显示包foo所在目录</p>
</li>
<li><p><code>pip list --outdated</code>    列出需要升级的包</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[恼人的Linux]]></title>
      <url>http://codeinterviews.com/annoying-linux/</url>
      <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e7lacvg6zcj21hc0xcqc6.jpg" alt=""></p>
<a id="more"></a>
<p>看到v2上大家在讨论刚刚发布的elementaryos稳定版，贴图看起来特美，我把系统从百度网盘下载下来，烧录到U盘，修改BIOS的启动项，插入U盘，关机重启（好多天没关过机了），双手合十眼睛汪汪地期待奇迹。然后，尼玛，真奇迹，卡在读取的阶段不动了！懒得折腾了。好容易重启一次，进Ubuntu练习一下这几天学的命令吧。</p>
<p>Ubuntu还是那么惊艳，那么耀眼（显卡驱动坏了无法调低亮度）。开始练习。敲到<code>cd</code>命令的时候，心想目录名那么长还有好多特殊字符，真麻烦。然后google，挂了。翻墙吧，Goagent配置失效了。用vpn吧，一会好一会坏的，还不能全局翻（apt-get安装软件的时候慢啊）。用shadowsocks吧，没有二进制的。用nodejs版吧，先装nodejs，各种error：又是缺少依赖包又是文件权限不足，装好依赖包后make吧，这个慢啊，到最后阶段又error了，吐血。算了，python版吧，先装pip，又是缺少依赖包，折腾了一下装好了。装shadowsocks，又是缺少依赖包，折腾一下好了。配置好config之后执行<code>python proxy.py</code>，又TM错误，缺少M2crypto包，安装吧，缺少openssl和swig，狂吐。NND，不弄了，继续VPN吧。</p>
<p>软件安装的时候，如果apt-get可以安装那最好，否则，呵呵，config,make,make install…</p>
<p>要在某个目录使用shell，基本上必须用cd从头切换进去，不能直接在目录里调出shell（这点不确定）。</p>
<p>人家说，当初Linus这伙人做Linux的时候就没想着用桌面，这群高人喜欢用命令做一切。不过，话说回来，各种命令配合通配符真的很强大。只能说学习曲线陡峭，投资回报巨大。</p>
<p>早些时候看过《鸟哥的linux私房菜》，内容太多了，怪吓人的，虽然忍着痛苦学习并做了笔记，但之后没怎么用。这次从别的地方学习了一些用的最多的命令，win下用cygwin练习，不会的搜索，一点点积累，再看鸟哥私房菜时感觉就很不同了。</p>
<p>好吧现在又回到了win，不知道下次和ubuntu见面将是何年何月。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python中文件遍历的几种方法]]></title>
      <url>http://codeinterviews.com/traverse-in-python/</url>
      <content type="html"><![CDATA[<p>今天写一个在windows下批量修改文件名的python脚本，用到文件的遍历。用python进行文件遍历有多种方法，这里列举并说明一下。</p>
<p>###os.path.walk()</p>
<p>这是一个传统的用法。</p>
<p>walk(root,callable,args)方法有三个参数：要遍历的目录，回调函数，回调函数的参数（元组形式）。</p>
<p>调用的过程是遍历目录下的文件或目录，每遍历一个目录，调用回调函数，并把args作为参数传递给回调函数。</p>
<p>回调函数定义时也有三个参数，比如示例中的func中的三个参数，分别为walk传来的参数、目录的路径、目录下的文件列表（只有文件名，不是完整路径）。请看示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">s = os.sep	<span class="comment">#根据unix或win，s为\或/</span></span><br><span class="line">root = <span class="string">"d:"</span> + s + <span class="string">"ll"</span> + s	<span class="comment">#要遍历的目录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(args,dire,fis)</span>:</span>	<span class="comment">#回调函数的定义</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> fis:</span><br><span class="line">        fname = os.path.splitext(f)		<span class="comment">#分割文件名为名字和扩展名的二元组</span></span><br><span class="line">        new = fname[<span class="number">0</span>] + <span class="string">'b'</span> + fname[<span class="number">1</span>]		<span class="comment">#改名字</span></span><br><span class="line">        os.rename(os.path.join(dire,f),os.path.join(dire,new))	<span class="comment">#重命名</span></span><br><span class="line"></span><br><span class="line">os.path.walk(root,func,())	<span class="comment">#遍历</span></span><br></pre></td></tr></table></figure>
<p>这种方法在使用时有个问题，不能递归遍历下一层（这点我还不确定，欢迎指正）。</p>
<p>python的高级版本中加入了os.walk()，比这个好用。</p>
<a id="more"></a>
<p>###os.walk()</p>
<p>原型为：os.walk(top, topdown=True, onerror=None, followlinks=False)</p>
<p>我们一般只使用第一个参数。（topdown指明遍历的顺序）</p>
<p>该方法对于每个目录返回一个三元组，(dirpath, dirnames, filenames)。第一个是路径，第二个是路径下面的目录，第三个是路径下面的非目录（对于windows来说也就是文件）。请看示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">s = os.sep</span><br><span class="line">root = <span class="string">"d:"</span> + s + <span class="string">"ll"</span> + s	</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rt, dirs, files <span class="keyword">in</span> os.walk(root):</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">        fname = os.path.splitext(f)</span><br><span class="line">        new = fname[<span class="number">0</span>] + <span class="string">'b'</span> + fname[<span class="number">1</span>]</span><br><span class="line">        os.rename(os.path.join(rt,f),os.path.join(rt,new))</span><br></pre></td></tr></table></figure>
<p>这种方式可以递归遍历所有的文件。</p>
<p>###listdir</p>
<p>可以使用os模块下的几个方法组合起来进行遍历。请看示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">s = os.sep</span><br><span class="line">root = <span class="string">"d:"</span> + s + <span class="string">"ll"</span> + s</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(root):</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(os.path.join(root,i)):</span><br><span class="line">        <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，其中的i是目录或文件名，不是完整的路径，在使用时要结合os.path.join()方法还原完整路径。</p>
<p>遍历搞定之后，文件名的修改可以使用正则表达式做一些高级的处理。</p>
<p>另外，还可以使用os.system(cmd)来调用shell里面的相关命令对文件进行处理，很好很强大。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python中的异常处理]]></title>
      <url>http://codeinterviews.com/python-error/</url>
      <content type="html"><![CDATA[<p>从几年前开始学习编程直到现在，一直对程序中的异常处理怀有恐惧和排斥心理。之所以这样，是因为不了解。这次攻python，首先把自己最畏惧和最不熟悉的几块内容列出来，里面就有「异常处理」这一项。</p>
<p>《Dive into Python》并没有专门介绍异常处理，只是例子中用到的时候略微说明了一下。今天下载《Learn Python》，直接进异常处理这块。这一部分有四章，第一章讲解异常处理的一般使用方法，后面的章节深入地讨论其机制。我目前只看了第一章，先学会用，以后有必要的时候再扩展阅读。</p>
<p>python主要支持五种异常机制，一一列举。</p>
<a id="more"></a>
<p>###默认的异常处理器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello girl!'</span></span><br><span class="line"><span class="keyword">print</span> s[<span class="number">100</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'continue'</span></span><br></pre></td></tr></table></figure>
<p>如果我们没有对异常进行任何预防，那么在程序执行的过程中发生异常，就会中断程序，调用python默认的异常处理器，并在终端输出异常信息。这种情况下，第3行代码不会执行。</p>
<p>###try…except</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello girl!'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">print</span> s[<span class="number">100</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'error...'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'continue'</span></span><br></pre></td></tr></table></figure>
<p>程序执行到第2句时发现try语句，进入try语句块执行，发生异常，回到try语句层，寻找后面是否有except语句。找到except语句后，会调用这个自定义的异常处理器。except将异常处理完毕后，程序继续往下执行。这种情况下，最后两个print语句都会执行。</p>
<p>except后面也可以为空，表示捕获任何类型的异常。</p>
<p>###try…finally</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello girl!'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">print</span> s[<span class="number">100</span>]</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'error...'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'continue'</span></span><br></pre></td></tr></table></figure>
<p>finally语句表示，无论异常发生与否，finally中的语句都要执行。但是，由于没有except处理器，finally执行完毕后程序便中断。这种情况下，倒第2个print会执行，到第1个不会执行。如果try语句中没有异常，三个print都会执行。</p>
<p>###assert</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="keyword">False</span>,<span class="string">'error...'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'continue'</span></span><br></pre></td></tr></table></figure>
<p>这个语句，先判断assert后面紧跟的语句是True还是False，如果是True则继续执行print，如果是False则中断程序，调用默认的异常处理器，同时输出assert语句逗号后面的提示信息。本例情况下，程序中断，提示error，后面的print不执行。</p>
<p>###with…as</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'nothing.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.read()</span><br><span class="line">	<span class="keyword">print</span> <span class="number">2</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'continue'</span></span><br></pre></td></tr></table></figure>
<p>我们平时在使用类似文件的流对象时，使用完毕后要调用close方法关闭，很麻烦。这里with…as语句提供了一个非常方便的替代方法：open打开文件后将返回的文件流对象赋值给f，然后在with语句块中使用。with语句块完毕之后，会隐藏地自动关闭文件。</p>
<p>如果with语句或语句块中发生异常，会调用默认的异常处理器处理，但文件还是会正常关闭。</p>
<p>这种情况下，会抛出异常，最后的print不执行。</p>
<p>书中介绍的很详细，除了上面我提到的之外，还有很多有用的附加信息，比如<code>try..except..finally..else</code>可以连用，比如自定义异常类。这里不再列出，详情可以参考这本书中的介绍。</p>
<p>PS：这本书的翻译真不咋地，跟《Dive into Python》比差很多。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开启vim模式]]></title>
      <url>http://codeinterviews.com/vim-start/</url>
      <content type="html"><![CDATA[<p>Notepad++用了两年了，作为一般的使用非常轻便，而且支持丰富的插件，但想要在编写速度上再提升就很难了。这几天SN上总有人推荐vim的介绍和设置文章，池建强也开始写vim系列文章，在需求和刺激的双重驱动下，我重新燃起了对vim的热情。于是下载安装了Gvim。win版的vim是最丑的，跟mac和linux下的没法比，但是我一没mac，二不爱来回重启切换系统，所以只能凑合用这个了。把工具栏隐藏掉，把配色方案改一下，发现还有美容的希望。</p>
<p>装好gvim后，第一步就是找几个成熟的配置文件写进.vimrc，这样便能直接上手使用好用的vim了。</p>
<p>然后设置文件关联。这个我还没找到像NPP那样的一键关联设定，只能见招拆招，看到一种类型的文件后把vim设置为默认的打开程序。</p>
<p>vim命令学过一些，但长时间不用基本忘光了。昨天用vim写博客，配合鼠标，跟普通编辑器的使用没有什么区别。</p>
<a id="more"></a>
<p>今天特意看了一下原来的vim笔记，把最常用的命令复习了一番，并在文件中反复练习了几次。今后要拔掉鼠标，逼自己用vim上的各种快捷键和命令。</p>
<p>目前发现vim的几个亮点：</p>
<ol>
<li>特别轻便，打开文件秒开。</li>
<li>虽然对初学者不太友好，但定制功能强大，各种功能只要能想到便有办法定制。</li>
<li>默认对语法高亮的支持非常perfect。</li>
<li>使用快捷键多加练习的话会有飞一般的感觉。</li>
<li>插件、主题什么的有丰富的支持。</li>
</ol>
<p>也发现几个不好的地方：</p>
<ol>
<li>大多数好玩的快捷键都是在一般模式下使用。插入模式中想要移动光标神马的只能用箭头或者用Esc跳到一般模式（Esc好远啊）。</li>
<li>缓冲区是什么东东，有待了解。</li>
<li>没有方便的文件关联设置。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[科学上网之goagent gui]]></title>
      <url>http://codeinterviews.com/goagent-gui/</url>
      <content type="html"><![CDATA[<p>作为IT从业者，经常需要去国外的一些网站看技术文档，需要去<em>youtube、udacity</em>等网站看一些技术相关的视频，但由于国内政策限制，很多类似的网站被GFW墙掉。正所谓魔高一尺，道高一丈，在伟大的程序员手里，一件件的fq软件诞生。本人有点小工具收藏癖，到现在为止已经收藏了不少的科学上网方法，有时间汇总一下。今天又发现一个好东西，特拿来分享。</p>
<p>软件名：Goagent GUI</p>
<p>操作系统：Win8，Win7，xp</p>
<p>主页：<a href="https://goagent.codeplex.com/" target="_blank" rel="external">https://goagent.codeplex.com/</a>（无需fq）</p>
<p>简介：基于Goagent，在此基础上制作了图形化的软件界面，配置和使用更加方便。</p>
<a id="more"></a>
<p>优点：</p>
<ol>
<li>图形化界面，相对于原始的Goagent更加友好、简便。</li>
<li>默认是全局代理，浏览器不经过任何设置即可自由上网。</li>
<li>常用的便捷功能都集中在上面，轻松设置。</li>
<li>chrome可以配合<a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm" target="_blank" rel="external">Proxy Switchy Sharp</a>插件实现「国内网站不走代理，国外被屏蔽网站走代理」，提高访问速度。</li>
<li>google appid可以免费申请十个，每个每天1G的流量，所以总共每天可以用10G流量，干什么都绰绰有余了。</li>
<li>速度很不错，我的2M铁通看youtube、vimeo都无需缓冲、流畅播放。</li>
</ol>
<p>缺点：需要申请gae账号，其实也并不麻烦，<a href="http://blog.4a8a.com/post-133.html" target="_blank" rel="external">这个博客</a>的介绍可以参考参考。</p>
<p>使用方法：</p>
<ol>
<li>点击<a href="https://goagent.codeplex.com/releases/view/110172" target="_blank" rel="external">下载</a>绿色免安装版。</li>
<li>解压后运行<code>GoAgent_GUI.exe</code>。</li>
<li>点击进入「快速部署」，删除默认的两个「服务器端」，填入自己的google appid，并填写google的账号密码，点击「开始部署」。</li>
<li>「命令行」停止之后，关闭部署窗口，回到主窗口，点击进入「高级设定」，三个选项全选。搞定！</li>
</ol>
<p>现在就可以自由上网了！</p>
<p>补充：</p>
<ol>
<li>截图不上传了，项目主页有。</li>
<li>Proxy Switchy Sharp的使用方法参考<a href="http://blog.4a8a.com/post-133.html" target="_blank" rel="external">这个博客</a>里的「二、3」。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery之$.post()]]></title>
      <url>http://codeinterviews.com/jquery-post/</url>
      <content type="html"><![CDATA[<p>在提交表单时我们可以使用.submit()方法自定义提交表单的动作。提交的方式可以选择get、post、getJSON、getJSONP等等。这里说一下post方式。</p>
<p><code>jQuery.post( url [, data ] [, success(data, textStatus, jqXHR) ] [, dataType ] )</code></p>
<p>url：要提交的地址，相当于html中的action值。</p>
<p>data：要发送给服务器的数据。</p>
<p>success：这是一个回调函数，如果post成功，会执行该函数。</p>
<p>dataType：这个参数可以设置从服务器返回的数据的格式，可以为xml, json, script, text, html。</p>
<a id="more"></a>
<p>使用示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery.post demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-1.9.1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">id</span>=<span class="string">"searchForm"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"s"</span> <span class="attr">placeholder</span>=<span class="string">"Search..."</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Search"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- the result of the search will be rendered inside this div --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span><br><span class="line">/* 使用submit()自定义提交动作 */</span><br><span class="line">$("#searchForm").submit(function(event) &#123;</span><br><span class="line"> </span><br><span class="line">  /* 阻止form正常的提交，使用自定义方式 */</span><br><span class="line">  event.preventDefault();</span><br><span class="line"> </span><br><span class="line">  /* 提取html中的某些元素，这里是要post的数据和地址 */</span><br><span class="line">  var $form = $( this ),</span><br><span class="line">      term = $form.find( 'input[name="s"]' ).val(),</span><br><span class="line">      url = $form.attr( 'action' );</span><br><span class="line"> </span><br><span class="line">  /* 发送数据，使用了url和data这两个参数，后者用字典形式 */</span><br><span class="line">  var posting = $.post( url, &#123; s: term &#125; );</span><br><span class="line"> </span><br><span class="line">  /* 提交成功后的操作，将返回的数据显示在一个div中 */</span><br><span class="line">  posting.done(function( data ) &#123;</span><br><span class="line">    var content = $( data ).find( '#content' );</span><br><span class="line">    $( "#result" ).empty().append( content );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在使用chrome浏览器进行调试时发现一个问题，如果url为http或https，而本文件是在本地打开，post就会失败。这是因为chrome出于安全考虑不支持跨域（file和http）访问。解决的办法，一是用<code>python -m SimpleHTTPServer 8000</code>开一个临时的http服务器，一是使用get而非post。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python学习之yield]]></title>
      <url>http://codeinterviews.com/python-yield/</url>
      <content type="html"><![CDATA[<p>python中有一个略微奇怪的表达式叫yield expression，本文就来探究一下这是个什么东西。一步一步来。</p>
<p>####iterable</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="keyword">print</span> str(item)</span><br></pre></td></tr></table></figure>
<p>mylist是一个列表（list），我们可以逐条取出每一个item，这个过程叫做iteration。像list这样可以用”for…in…”依次遍历的对象被称为iterable，其他的iterable还有string、tuple、dict等。iterable的一个特点是所有的item会存储到内存中，这样会产生一些不便和不利的地方，于是催生了generator（后面讲到）。</p>
<a id="more"></a>
<p>####list comprehension(列表推导式)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>表达式右边是一个for循环的简写形式，用<code>[]</code>包裹起来（称为list comprehension），表达式的值是一个list，我们可以像普通list那样使用”for…in…”遍历其元素，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="keyword">print</span> str(item)</span><br></pre></td></tr></table></figure>
<p>####generator</p>
<p>对上面的list comprehension稍作修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> mygenerator:</span><br><span class="line">    <span class="keyword">print</span> item</span><br></pre></td></tr></table></figure>
<p>可以看到只是把<code>[]</code>换成了<code>()</code>，这时表达式的值不再是list，而是一个generator。</p>
<p>generator也属于iterable，但是其调用方式非常特别。</p>
<p>####yield</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creatGenerator</span><span class="params">()</span>:</span></span><br><span class="line">    mylist = range(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> mylist:</span><br><span class="line">        <span class="keyword">yield</span> x*x</span><br><span class="line">        </span><br><span class="line">mygenerator = creatGenerator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> mygenerator:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>yield的使用方法和return是一样的。但是（重点来了）：</p>
<ul>
<li>第6行中调用函数的时候，函数体并不执行，只是简单返回一个generator对象。</li>
<li>第8行的for循环，每次遍历mygenerator的一个item：creatGenerator()函数体开始执行，直到函数体执行到<code>yield x*x</code>便中断运行，返回一个迭代值。下一次循环，函数体从上一次<code>yield x*x</code>的下一条语句开始执行…直到不再执行yield expression为止（generator 自动抛出 StopIteration 异常，表示迭代完成。在 for 循环里，无需处理 StopIteration 异常，循环会正常结束。）</li>
</ul>
<p>####什么时候用yield？</p>
<ul>
<li>mylist只使用一次，或者mylist特别长，由于不用全部保存到memory，所以执行起来又快又省空间。</li>
<li>函数体需要返回多值的时候。和yield不用，return语句第一次出现函数便结束，如<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  第一个函数会返回一个generator对象，使用这个对象可以依次获得全部三个输出。第二个函数只有一个输出1，后面的return语句不会执行。</p>
<p>  当然，稍作修改的话，也可以使用return返回多值：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc3</span><span class="params">()</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        result.append(x)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">print</span> myfunc3()</span><br></pre></td></tr></table></figure>
<p>参考资料：<a href="http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained" target="_blank" rel="external">http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained</a>  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python学习之re模块]]></title>
      <url>http://codeinterviews.com/python-re/</url>
      <content type="html"><![CDATA[<p>这几天玩爬虫已经使用了很多次的re模块，算是比较熟悉了，这里梳理一下。</p>
<p>首先，关于正则表达式的概念，<a href="http://blog.csdn.net/wxg694175346/article/details/8929576" target="_blank" rel="external">这里</a>有最好的教程。</p>
<p>对于正则表达式，我们可以先用compile方法编译为pattern对象，再调用相关的方法进行模式匹配，也可以直接进行匹配。</p>
<a id="more"></a>
<p>对于第一种，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pat = re.compile(<span class="string">r'e(.*?)o'</span>) <span class="comment">#编译为pattern对象</span></span><br><span class="line">text = <span class="string">'Hello world'</span> <span class="comment">#要匹配的文本</span></span><br><span class="line">mat = pat.match(text) <span class="comment">#从text开头进行匹配，开头不符合就over，返回一个match对象，通过group（）方法获取对应元组</span></span><br><span class="line">src = pat.search(text) <span class="comment">#在整个text中搜索，第一次找到就返回，通过group（）方法获取对应元组</span></span><br><span class="line">spl = pat.split(text) <span class="comment">#用pat进行匹配，并以匹配的文本为界分割text，返回列表</span></span><br><span class="line">fdl = pat.findall(text) <span class="comment">#在text中搜索所有匹配的内容，返回列表</span></span><br><span class="line">sub = pat.sub(s,text) <span class="comment">#用pat进行匹配，然后把匹配内容替换为s，返回替换之后的字符串</span></span><br><span class="line">sbn = pat.subn(s,text) <span class="comment">#同上，但返回字符串和替换次数构成的元组</span></span><br><span class="line">fdi = pat.finditer(text) <span class="comment">#返回迭代器</span></span><br></pre></td></tr></table></figure>
<p>对于第二种，相应代码为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">'Hello world'</span></span><br><span class="line">mat = re.match(<span class="string">r'e(.*?)o'</span>,text)</span><br><span class="line">src = re.search(<span class="string">r'e(.*?)o'</span>,text)</span><br><span class="line">spl = re.split(<span class="string">r'e(.*?)o'</span>,text) </span><br><span class="line">fdl = re.findall(<span class="string">r'e(.*?)o'</span>,text)</span><br><span class="line">sub = re.sub(<span class="string">r'e(.*?)o'</span>,s,text)</span><br><span class="line">sbn = re.subn(<span class="string">r'e(.*?)o'</span>,s,text)</span><br><span class="line">fdi = re.finditer(<span class="string">r'e(.*?)o'</span>,text)</span><br></pre></td></tr></table></figure>
<p>返回结果和第一种一样，使用方法也有明显的规律，就是把正则表达式放在第一个参数位置。</p>
<p>值得注意的是，在第一种的re.compile()和第二种的方法中，都可以附加一个额外的参数用来标明匹配模式，放在最后面。</p>
<p>可选值有：</p>
<p> re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）<br> re.M(全拼：MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）<br> re.S(全拼：DOTALL): 点任意匹配模式，改变’.’的行为<br> re.L(全拼：LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定<br> re.U(全拼：UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性<br> re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。  </p>
<p>可以使用类似<code>re.I | re.M</code>形式，使这两种模式同时生效。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python学习之hashlib和base64模块]]></title>
      <url>http://codeinterviews.com/python-hashlib-base64/</url>
      <content type="html"><![CDATA[<p>看到好几位博主通过对模块的各个击破学习python，我也效法一下，本篇说一下python中加密涉及到的模块。</p>
<p>###hashlib</p>
<p>hashlib模块支持的加密算法有md5 sha1 sha224 sha256 sha384 sha512(加密原理请参考<a href="http://msdn.microsoft.com/zh-cn/library/92f9ye3s.aspx" target="_blank" rel="external">此处</a>)，使用起来也很简单。</p>
<a id="more"></a>
<p>以md5加密为例，有两种方法：</p>
<p>一、 追加模式</p>
<p> 代码示例：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib <span class="comment">#引入hashlib模块</span></span><br><span class="line"></span><br><span class="line">mm = hashlib.md5() <span class="comment">#创建一个md5对象</span></span><br><span class="line">mm.update(<span class="string">"Hello"</span>) <span class="comment">#通过update方法加密文本</span></span><br><span class="line">mm.update(<span class="string">" world!"</span>) <span class="comment">#追加，这两句相当于 mm.update("Hello world!")</span></span><br><span class="line"><span class="keyword">print</span> mm.digest() <span class="comment">#输出加密后的二进制数据</span></span><br><span class="line"><span class="keyword">print</span> mm.hexdigest() <span class="comment">#输出加密后的十六进制数据</span></span><br></pre></td></tr></table></figure>
<p>二、 一句话</p>
<p> 如果不需要追加，只用加密一段文本，可用这种形式，代码示例：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">hashlib.new(<span class="string">"md5"</span>,<span class="string">"Hello world!"</span>).digest()</span><br></pre></td></tr></table></figure>
<p>此外，md5等算法对象还提供了<code>digest_size</code>和<code>block_size</code>等属性，指示加密后文本的大小。</p>
<p>对于其他的加密算法，只要在代码中替换「md5」即可，不再举例。</p>
<p>###base64</p>
<p>这个模块提供的加密算法并不安全，但十分简单，有时候会用到。</p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">a = <span class="string">"Hello world!"</span></span><br><span class="line">b = base64.encodestring(a) <span class="comment">#加密</span></span><br><span class="line">c = base64.decodestring(b) <span class="comment">#解密</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a==c</span><br></pre></td></tr></table></figure>
<p>python还有诸多的第三方模块提供更多的加密方式，以后学到的时候再说。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python多线程编程中join函数的使用]]></title>
      <url>http://codeinterviews.com/python-thread-join/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p>测试用的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试多线程中join的功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading, time  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doWaiting</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'start waiting1: '</span> + time.strftime(<span class="string">'%H:%M:%S'</span>) + <span class="string">"\n"</span>  </span><br><span class="line">    time.sleep(<span class="number">3</span>)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'stop waiting1: '</span> + time.strftime(<span class="string">'%H:%M:%S'</span>) + <span class="string">"\n"</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doWaiting1</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'start waiting2: '</span> + time.strftime(<span class="string">'%H:%M:%S'</span>) + <span class="string">"\n"</span>   </span><br><span class="line">    time.sleep(<span class="number">8</span>)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'stop waiting2: '</span>, time.strftime(<span class="string">'%H:%M:%S'</span>) + <span class="string">"\n"</span>  </span><br><span class="line">tsk = []    </span><br><span class="line">thread1 = threading.Thread(target = doWaiting)  </span><br><span class="line">thread1.start()  </span><br><span class="line">tsk.append(thread1)</span><br><span class="line">thread2 = threading.Thread(target = doWaiting1)  </span><br><span class="line">thread2.start()  </span><br><span class="line">tsk.append(thread2)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'start join: '</span> + time.strftime(<span class="string">'%H:%M:%S'</span>) + <span class="string">"\n"</span>   </span><br><span class="line"><span class="keyword">for</span> tt <span class="keyword">in</span> tsk:</span><br><span class="line">    tt.join()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'end join: '</span> + time.strftime(<span class="string">'%H:%M:%S'</span>) + <span class="string">"\n"</span></span><br></pre></td></tr></table></figure>
<p>这个小程序使用了两个线程thread1和thread2，线程执行的动作分别是doWaiting()和doWaiting1()，函数体就是打印「开始」+休眠3秒+打印「结束」，分别附加上时间用来查看程序执行的过程。后面用start()方法同步开始执行两个线程。然后开始循环调用两个线程的join()方法，在此之前和之后都会用print函数做好开始结束的标记。我们主要观察<code>for tt in tsk: tt.join()</code>。</p>
<p>join()不带参数的情况下，执行如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/5e8cb366jw1e72rsxgr8gj20it06i74w.jpg" alt=""></p>
<p>可以看到，两个线程并行执行，进程1在3s后结束，进程2在8s后结束，然后回到主进程，执行打印「end join」。</p>
<p>下面把参数设置成超时2s，即<code>tt.join(2)</code>，执行如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/5e8cb366jw1e72rtihfr6j20it06iwf3.jpg" alt=""></p>
<p>两个线程开始并发执行，然后执行线程1的<code>join(2)</code>，等线程1执行2s后就不管它了，执行线程2的<code>join(2)</code>，等线程2执行2s后也不管它了（在此过程中线程1执行结束，打印线程1的结束信息），开始执行主进程，打印「end join」。4s之后线程2执行结束。</p>
<p>总结一下：</p>
<ol>
<li>join方法的作用是阻塞主进程（挡住，无法执行join以后的语句），专注执行多线程。</li>
<li>多线程多join的情况下，依次执行各线程的join方法，前头一个结束了才能执行后面一个。</li>
<li>无参数，则等待到该线程结束，才开始执行下一个线程的join。</li>
<li>设置参数后，则等待该线程这么长时间就不管它了（而该线程并没有结束）。不管的意思就是可以执行后面的主进程了。</li>
</ol>
<p>最后附上参数为2时的程序执行流程表，自己画的orz，这样看起来更好理解。</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e72rwxky2oj21kw16owza.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python爬虫：点点美女图片]]></title>
      <url>http://codeinterviews.com/python-pachong-dian-dian-tu-pian/</url>
      <content type="html"><![CDATA[<p>继续鼓捣爬虫，今天贴出一个代码，爬取点点网「美女」标签下的图片，原图。</p>
<a id="more"></a>
<script src="https://gist.github.com/zippera/6086025.js"></script>

<p>使用方法：新建一个文件夹，把代码保存为name.py文件，运行<code>python name.py</code>就可以把图片下载到文件夹。 </p>
<hr>
<p>顺带贴上校友<a href="https://plus.google.com/117459153115593347327" target="_blank" rel="external">崔桐</a>的一个爬虫程序，你懂得。</p>
<script src="https://gist.github.com/zippera/6094689.js"></script>

<p>使用方法同上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python爬虫：糗百图片]]></title>
      <url>http://codeinterviews.com/python-pachong-qiu-bai/</url>
      <content type="html"><![CDATA[<p>学习python少不了写爬虫，不仅能以点带面地学习、练习使用python，爬虫本身也是有用且有趣的，大量重复性的下载、统计工作完全可以写一个爬虫程序完成。</p>
<p>用python写爬虫需要python的基础知识、涉及网络的几个模块、正则表达式、文件操作等知识。昨天在网上学习了一下，写了一个爬虫自动下载「糗事百科」里面的图片。源代码如下：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="comment"># 上面那句让代码里支持中文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------  </span></span><br><span class="line"><span class="comment">#   程序：糗百图片爬虫  </span></span><br><span class="line"><span class="comment">#   版本：0.1  </span></span><br><span class="line"><span class="comment">#   语言：Python 2.7  </span></span><br><span class="line"><span class="comment">#   说明：能设置下载的页数。没有做更多抽象和交互方面的优化。  </span></span><br><span class="line"><span class="comment">#--------------------------------------- </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment">#正则表达式，用来抓取图片的地址</span></span><br><span class="line">pat = re.compile(<span class="string">'&lt;div class="thumb"&gt;\\n&lt;img src=\"(ht.*?)\".*?&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用来合成网页的URL</span></span><br><span class="line">nexturl1 = <span class="string">"http://m.qiushibaike.com/imgrank/page/"</span></span><br><span class="line">nexturl2 = <span class="string">"?s=4582487&amp;slow"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#页数计数</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置抓取的页数</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Page "</span> + str(count) + <span class="string">"\n"</span></span><br><span class="line">    myurl = nexturl1 + str(count) + nexturl2</span><br><span class="line">    myres = urllib2.urlopen(myurl)<span class="comment">#抓取网页</span></span><br><span class="line">    mypage = myres.read()<span class="comment">#读取网页内容</span></span><br><span class="line">    ucpage = mypage.decode(<span class="string">"utf-8"</span>) <span class="comment">#转码</span></span><br><span class="line"></span><br><span class="line">    mat = pat.findall(ucpage)<span class="comment">#用正则表达式抓取图片地址</span></span><br><span class="line">        </span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> len(mat):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> mat:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"url: "</span> + item + <span class="string">"\n"</span></span><br><span class="line">            fnp = re.compile(<span class="string">'/(\w+\.\w+)$'</span>)<span class="comment">#下面三行分离出图片文件的名称</span></span><br><span class="line">            fnr = fnp.findall(item)</span><br><span class="line">            fname = fnr[<span class="number">0</span>]</span><br><span class="line">            urllib.urlretrieve(item, fname)<span class="comment">#下载图片</span></span><br><span class="line">	    	</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"no data"</span></span><br></pre></td></tr></table></figure>
<p>使用方法：新建一个practice文件夹，将源代码保存为<code>qb.py</code>文件，并放在practice文件夹中，在命令行里执行<code>python qb.py</code>，即开始下载图片。可以修改源代码里面的while语句设置下载的页数。</p>
<p><em>资料推荐：<a href="http://blog.csdn.net/wxg694175346/article/category/1418998" target="_blank" rel="external">http://blog.csdn.net/wxg694175346/article/category/1418998</a></em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[推荐一些资源]]></title>
      <url>http://codeinterviews.com/recommendations/</url>
      <content type="html"><![CDATA[<p><img src="/img/tuijian.jpg" alt=""></p>
<p>今天给大家推荐一些不错的资源，藏着掖着怕臭掉，全民共享才超值。</p>
<a id="more"></a>
<ol>
<li><p>『ikindle』全站电子书</p>
<p>众所周知，ikindle一直是中国mobi电子书最大最全质量最好的下载站，不过几个月前网站关闭了，后来重新上线已经面目全非，原来丰富的电子书已经不再提供下载。好在有牛人用爬虫抓取保存了全站的资源，裨益全民。</p>
<p>下载地址在<a href="http://pan.baidu.com/share/link?shareid=650121&amp;uk=4043738632" target="_blank" rel="external">这里</a>，提取密码是lhzc</p>
<p>如果有一天资源被删下载失败，请联系我，还有备份。</p>
</li>
<li><p>『子午书简』全站电子书</p>
<p>这也是我常去下载mobi电子书的网站，今天访问时服务器已经宕机。但站长真好人，提供了全站资源的压缩包供我们下载。这里转述一下站长大人的嘱托：</p>
<p>如果想看所有的书，你可以来<a href="http://pan.baidu.com/share/link?shareid=2626260278&amp;uk=3641007573" target="_blank" rel="external">baidu云盘</a>下载三个压缩包或来<a href="http://kuai.xunlei.com/d/.8UlAwIDwADHtOBR5bc" target="_blank" rel="external">迅雷快传</a>下载一个完整包，解压后是calibre的目录，你可以把你的calibre library切换到这个目录来。 </p>
</li>
<li><p>豆瓣读书Top250</p>
<p>这里是豆瓣读书评分最高的250本电子书的，全部为epub格式，建议使用『多看』进行阅读。</p>
<p>下载地址在<a href="http://pan.baidu.com/share/link?shareid=542885889&amp;uk=1661888259" target="_blank" rel="external">这里</a>。另外，<a href="http://pan.baidu.com/share/link?shareid=948636175&amp;uk=2970291509&amp;from=name" target="_blank" rel="external">这里</a>还有一个相关资源可供下载。</p>
<p>另外，找优质电子书还可以去mlook、epub、coay、古腾堡，自行搜索吧，不提供链接了。</p>
</li>
<li><p>豆瓣电影口碑榜</p>
<p><a href="http://movie.douban.com/doulist/13921/" target="_blank" rel="external">这里</a>有最新的实时的电影口碑排行榜，喜欢看电影的朋友可以参考一下。</p>
</li>
<li><p>影视下载</p>
<p>推荐快播专用搜索引擎『100soo』，<a href="http://www.100soo.cn/index.html" target="_blank" rel="external">地址</a>，资源非常全，质量也高，用快播缓冲即可完成下载。</p>
</li>
<li><p>各种资源下载</p>
<p>我们都知道VeryCD资源多质量好，但限于版权问题已停止提供下载服务。推荐<a href="http://simplecd.me/" target="_blank" rel="external">http://simplecd.me/</a>这个网站，对verycd的全站镜像，下载杠杠的！</p>
<p>另外推荐几个：<a href="http://ishare.iask.sina.com.cn/" target="_blank" rel="external">新浪资料</a>（很全，真的很全）、<a href="http://thepiratebay.sx/" target="_blank" rel="external">海盗湾</a>（全球性的，需要梯子）、<a href="http://torrentproject.com/" target="_blank" rel="external">torrentproject</a>（很全）。</p>
</li>
<li><p>公开课</p>
<p>对网络公开课感兴趣的朋友，不可错过以下网站：</p>
<ul>
<li><a href="http://coursegraph.com/navigation/" target="_blank" rel="external">课程图谱</a></li>
<li><a href="http://www.guokr.com/group/184/" target="_blank" rel="external">果壳MOOC自习教室小组</a></li>
<li>网易公开课和网易云课堂。</li>
</ul>
</li>
<li><p>其他</p>
<p><a href="http://gate.guokr.com/" target="_blank" rel="external">果壳任意门</a>，点进去看看吧，会有你喜欢的！</p>
</li>
</ol>
<p>今天就列这些吧，好资源好站点太多太多了，做个有心人，发现更多精彩。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Google表单]]></title>
      <url>http://codeinterviews.com/google-form/</url>
      <content type="html"><![CDATA[<p><img src="/img/biaodan1.png" alt="Google表单示例"></p>
<p>介绍一个小工具：Google表单。这是google drive下面的一个实用小工具，用户可以用此创建留言表单或者问卷调查表单，提交的数据会保存到表单制作者的google drive，格式为Excel，可以轻松导出，还会有趋势图直观显示用户提交的频度。<a href="https://docs.google.com/forms/d/10V0l91dCDnyfpeicX4RclsHQ_xOihI61tvGuVCzB80g/viewform" target="_blank" rel="external">点此</a>查看效果（留言表单）。</p>
<a id="more"></a>
<p>表单的制作也非常简单。</p>
<p>进入这个<a href="https://docs.google.com/forms/d/1Y8eyaYTl150evVQPwQGzv3u5FD4UbQKCV3eh0E7N5os/edit" target="_blank" rel="external">页面</a>，选择「标题和主题背景」，然后编辑表单，有诸多种类的项目可以添加。完成之后，点击「发送表单」就可以生成这个表单的链接了。</p>
<p><img src="/img/biaodan2.png" alt="标题和主题背景"></p>
<p><img src="/img/biaodan3.png" alt="编辑表单"></p>
<p>另外，我们可以把表单嵌入自己的网页，如<a href="http://zipperary.com/photos/" target="_blank" rel="external">这里</a>。方法是，点击「文件」-「嵌入」，弹出对话框，设置iframe的大小。然后将代码嵌入网页中即可。</p>
<p><img src="/img/biaodan4.png" alt="将表单嵌入网页"></p>
<hr>
<p>今日推荐Android App: fqrouter</p>
<p>推荐理由：一键安装，无需设置，科学上网。已经试用，速度和稳定性都没的说，界面不美观但瑕不掩瑜。还可以作为热点支持其他设备科学上网，贴心而强悍。感谢作者！</p>
<p>下载地址：<a href="https://play.google.com/store/apps/details?id=fq.router2" target="_blank" rel="external">https://play.google.com/store/apps/details?id=fq.router2</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[把flickr相册嵌入网页]]></title>
      <url>http://codeinterviews.com/flickr-on-page/</url>
      <content type="html"><![CDATA[<p><img src="/img/flickr.png" alt=""></p>
<p>flickr是雅虎旗下的图片存储与分享服务，注册即赠送1T的免费存储空间，足够这辈子用了。flickr会无损保存我们的照片，提供各种滤镜渲染效果。同时，flickr的图片展示方式也非常的方便和舒适，幻灯片效果尤为漂亮。本文介绍一种方法，把自己的图集在博客页面上进行展示。效果如上图所示。</p>
<a id="more"></a>
<p>方法很简单，代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"500"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">src</span>=<span class="string">"http://www.flickr.com/slideShow/index.gne?set_id=#####"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>frameborder</code>是边框；<code>width</code>和<code>height</code>分别设置宽度和高度，可以是绝对尺寸，也可以是百分比；<code>scrolling</code>是滚动与否；最后的<code>src</code>是相册集的链接，必须使用这种格式，set_id是相册集的id，可以在自己相册集的URL中看到。</p>
<p>我们可以单独建立一个页面用来展示自己的图册，方法可参考<a href="http://zipperary.com/2013/05/30/hexo-guide-4/" target="_blank" rel="external">《hexo系列教程：（四）hexo博客的优化技巧》</a>中的「导航栏添加”关于”」。只要将上述代码填入正文即可。</p>
<hr>
<p>####今日推荐：为知笔记</p>
<p>可以完美导入Evernote中的笔记、分类和标签。相较于Evernote，为知笔记速度更加流畅、使用体验更加人性化，有各种各样的插件方便拓展功能，尤其是支持markdown。已经用了一周了，很好用，谁用谁知道！</p>
<p>传送门：<a href="http://www.wiz.cn/" target="_blank" rel="external">http://www.wiz.cn/</a></p>
<hr>
<p>爱打卡-100days-第42天-0111</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[科学上网新招]]></title>
      <url>http://codeinterviews.com/ke-xue-shang-wang/</url>
      <content type="html"><![CDATA[<p><img src="/img/breakwall2.png" alt=""></p>
<p>用了一年多的Goagent，除了首次安装配置的时候有些麻烦，后续使用还是挺方便的，速度和稳定性都可以，尽管偶尔会撒个娇。</p>
<p>近日混V2EX，多次不经意间看到shadowsocks这个词，还有ss-server之类的词语，不甚了了。昨天终于点进去瞧了瞧，哦，原来是一个用来科学上网的东东。</p>
<p>shadowsocks是由<a href="http://www.v2ex.com/member/clowwindy" target="_blank" rel="external">@clowwindy</a>发明的轻量级服务器中转包传输工具。有<a href="https://github.com/clowwindy/shadowsocks/wiki/Ports-and-Clients" target="_blank" rel="external">各平台的各种客户端</a>，五花八门，总有一款适合你。</p>
<a id="more"></a>
<p>原理略去不讲，因为我也不懂。下面介绍使用方法（这里只针对windows用户）。</p>
<ol>
<li><p>下载<a href="https://breakwall.net/soft/yingwa.zip" target="_blank" rel="external">Yingwa</a>。</p>
</li>
<li><p>解压之后，点击<strong>yingwa.exe</strong>，打开对话框。</p>
</li>
<li><p>如图进行配置，连接服务器。</p>
<p><img src="/img/breakwall1.png" alt=""></p>
<p>至于服务器端的access，如有需要可电邮我索取。</p>
<p>点击「Save」保存，然后「Connect」连接。打开任意浏览器，web世界已无阻隔。</p>
</li>
</ol>
<p>如果有安卓手机，可以安装安卓版的Shadowsocks，亲测好用！<a href="https://play.google.com/store/apps/details?id=com.github.shadowsocks" target="_blank" rel="external">点此</a>进入Google Play下载。</p>
<p>想折腾GoAgent的，传送门：<a href="https://code.google.com/p/goagent/" target="_blank" rel="external">https://code.google.com/p/goagent/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[将hexo博客部署到bae]]></title>
      <url>http://codeinterviews.com/hexo-on-bae/</url>
      <content type="html"><![CDATA[<p>我相信很多博主选择使用hexo做为博客程序，一个很重要的原因是可以使用免费、易用的github做为代码托管中心。用过一段时间后我发现，github在国内的速度也不是很理想。于是想到能不能把博客放在百度云BAE上呢，如果成功的话速度应该会有很大的提升。</p>
<p>和新浪的SAE类似，BAE提供web应用的服务器环境，现在支持Python、Java、PHP。不过，这个我们不用关心，因为我们代码是纯静态的，选择哪个环境都是可以的。SAE目前收费了。而BAE，不仅提供无限量的免费存储空间和1G的免费数据库空间，而且速度好像比SAE要快些，操作也十分方便。</p>
<p>就像github，我们可以使用git、svn这样的版本控制工具提交代码。hexo目前默认支持的部署环境为github、heroku，并通过github.js和heroku.js脚本把git命令简化为几个简单的hexo命令，使用起来更加方便高效。按理说我应该类似做一个bae.js，实际上我也尝试了，可惜未果，对其中原理不甚明了。现阶段还是使用原始的git方式提交代码，等以后bae.js成功了会在此更新分享。</p>
<p>下面说一下在bae部署hexo博客的步骤。</p>
<a id="more"></a>
<ol>
<li><p><a href="http://developer.baidu.com/bae" target="_blank" rel="external">注册bae账号</a>。</p>
<p>注册账号很简单，点击链接，进入bae主页，按照提示进行操作即可。如果之前没有百度账号，可能需要先行注册。</p>
</li>
<li><p>填写开发者资料。</p>
<p>第一步完成后，在页面右上角可以看到「创建应用」的链接，点击进入后按照提示填写即可。</p>
</li>
<li><p>创建应用。</p>
<p>开发者资料填写好后，右上角的「快速创建应用」就可以用了。按照如下方式填写好，点击「确定」。</p>
<p><img src="/img/bae1.png" alt=""></p>
</li>
<li><p>托管设置。</p>
<p>点击左侧面板中的「云环境」，进行设置。设置好后点击「确定」，进入「版本管理」。</p>
<p><img src="/img/bae2.png" alt=""></p>
</li>
<li><p>提交代码。</p>
<p>将hexo目录下的public文件夹打包为public.zip。按照下图方式将代码包上传到bae。完成之后，点击「预览」就可以看到博客了。</p>
<p><img src="/img/bae3.png" alt=""></p>
</li>
<li><p>同步。</p>
<p>添加文章后怎样提交到bae呢？<a href="http://developer.baidu.com/wiki/index.php?title=docs/cplat/rt/manage/git" target="_blank" rel="external">这里</a>有百度给出的详细图文教程。按照教程安装好tortoisegit软件。</p>
<p>以后提交代码时，先使用<code>hexo generate</code>命令生成public文件夹，再把public下的文件拷贝到教程中新建的文件夹中去，然后提交该文件夹，这样就能同步到bae了。（提交时，直接commit、push即可，不必先add或delete）</p>
</li>
</ol>
<p>这个方法很笨，操作熟练后倒是也很快，不失为一个备选方法。</p>
<p>本博客<a href="http://zipperary.com" target="_blank" rel="external">http://zipperary.com</a>依然托管在github，这个<a href="http://me.zipperary.com" target="_blank" rel="external">http://me.zipperary.com</a>在bae上，大家可以感受一下速度是否不同。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[怎样在博文中嵌入图片、音乐、视频？]]></title>
      <url>http://codeinterviews.com/media-on-hexo/</url>
      <content type="html"><![CDATA[<p>到目前为止，我的博客中几乎清一色的文本，偶尔夹杂图片。今天在<a href="http://sinchang.github.io/2013/06/26/music/" target="_blank" rel="external">SinChang的博客</a>中看到博客中嵌入了音乐，于是想了解一下怎样在博文中嵌入音乐、视频、flash等多媒体文件。</p>
<p>实际上，在hexo中，markdown支持html标签，md文件解析为html时原有的html部分会保留。有基于此，我们只要在文中插入符合html规范的代码即可。下面举例说明。</p>
<p>###图片</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](http://ww2.sinaimg.cn/large/5e8cb366jw1e62o63tkv3j20dh078q5a.jpg)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e62o63tkv3j20dh078q5a.jpg" alt=""></p>
<a id="more"></a>
<p>###音乐</p>
<p>以『虾米音乐』为例，歌曲页面有个『转帖』选项，将html代码或javascript代码复制到文中即可。</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">"http://www.xiami.com/widget/0_3515679/singlePlayer.swf"</span> <span class="attr">type</span>=<span class="string">"application/x-shockwave-flash"</span> <span class="attr">width</span>=<span class="string">"257"</span> <span class="attr">height</span>=<span class="string">"33"</span> <span class="attr">wmode</span>=<span class="string">"transparent"</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<embed src="http://www.xiami.com/widget/0_3515679/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent">

<p>###视频</p>
<p>嵌入视频的方法和音乐类似，视频网站每个视频页面都会有一个『分享』或『转帖』按钮，点击可以查看代码。</p>
<p>代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">498</span> <span class="attr">width</span>=<span class="string">510</span> <span class="attr">src</span>=<span class="string">"http://player.youku.com/embed/XMjI2MjU3MDMy"</span> <span class="attr">frameborder</span>=<span class="string">0</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XMjI2MjU3MDMy" frameborder="0" allowfullscreen></iframe>

<p>###万能</p>
<p>对于有些音乐、视频找不到『转帖』按钮的，可以查看源代码，找到相应的代码块贴在文中。若找不到，说明该文件的确不能放在自己文中了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo 主题优化]]></title>
      <url>http://codeinterviews.com/hexo-theme-alteration/</url>
      <content type="html"><![CDATA[<p>下载了几个博主修改过的hexo主题源代码，对照自带默认主题light，尝试进行修改。</p>
<p><img src="/img/themegai.png" alt=""></p>
<a id="more"></a>
<p>修改主题主要涉及的文件是<code>hexo\themes\light\source\css</code>和<code>hexo\themes\light\layout</code>文件夹下的文件。后者是布局和标签，前者是css定义。对应标签进行修改即可。</p>
<p>我本次修改的部分有这几个：</p>
<ol>
<li><p>网页背景、文字颜色等。</p>
<p>这个很简单，找到<code>hexo\themes\light\source\css\_base\layout.styl</code>，在body下面增加一条<code>background-image url(&#39;/imgs/noise.png&#39;)</code>，至于背景图片，用自己喜欢的即可。然后在<code>hexo\themes\light\source\css\_base\variable.styl</code>中修改color区块中的属性，就可以改变网站不同元素的颜色了。</p>
</li>
<li><p>添加drop-shadow效果。</p>
<p>这种效果在前文<a href="http://zipperary.com/2013/06/23/box-and-shadow-effect/" target="_blank" rel="external">《前端之drop-shadow效果》</a>中做过详细介绍，这里只是移植过来。需要修改的文件是<code>hexo\themes\light\source\css\_partial\article.styl</code>，在<code>.post-content</code>下面的平行层级添加一下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> .post-content:before</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  z-index: -1;</span><br><span class="line">  bottom: 15px;</span><br><span class="line">  left: 10px;</span><br><span class="line">  width: 50%;</span><br><span class="line">  height: 20%;</span><br><span class="line">  -webkit-box-shadow: 0 15px 10px rgba(0, 0, 0, 0.7);</span><br><span class="line">  -moz-box-shadow: 0 15px 10px rgba(0, 0, 0, 0.7);</span><br><span class="line">  box-shadow: 0 15px 15px rgba(0, 0, 0, 0.7);</span><br><span class="line">  -webkit-transform: rotate(-2deg);</span><br><span class="line">  -moz-transform: rotate(-2deg);</span><br><span class="line">  -o-transform: rotate(-2deg);</span><br><span class="line">  transform: rotate(-2deg);</span><br><span class="line">	</span><br><span class="line">.post-content:after</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  z-index: -1;</span><br><span class="line">  bottom: 15px;</span><br><span class="line">  left: 10px;</span><br><span class="line">  width: 50%;</span><br><span class="line">  height: 20%;</span><br><span class="line">  -webkit-box-shadow: 0 15px 10px rgba(0, 0, 0, 0.7);</span><br><span class="line">  -moz-box-shadow: 0 15px 10px rgba(0, 0, 0, 0.7);</span><br><span class="line">  box-shadow: 0 15px 15px rgba(0, 0, 0, 0.7);</span><br><span class="line">  -webkit-transform: rotate(-2deg);</span><br><span class="line">  -moz-transform: rotate(-2deg);</span><br><span class="line">  -o-transform: rotate(-2deg);</span><br><span class="line">  transform: rotate(-2deg);</span><br><span class="line">  right: 10px;</span><br><span class="line">  left: auto;</span><br><span class="line">  -webkit-transform: rotate(2deg);</span><br><span class="line">  -moz-transform: rotate(2deg);</span><br><span class="line">  -o-transform: rotate(2deg);</span><br><span class="line">  transform: rotate(2deg);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>只做了这点修改，以后看到喜欢的样式再对照修改吧。</p>
<p>另外，已经成功把hexo博客复制一份到wordpress。方法是在wordpress安装这个插件<strong>FeedWordPress</strong>，然后把网站的atom.xml地址填上就可以导入了。还发现一些问题，是wordpress和bae冲突的问题，比如不能在线安装主题和插件，评论异常。问题解决之后会写博客分享。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端之『折角』效果]]></title>
      <url>http://codeinterviews.com/qian-duan-zhi-zhe-jiao-xiao-guo/</url>
      <content type="html"><![CDATA[<p>昨天访问一位Q友的网站，看到一个很nice的效果。如图，上下两个区域交界线的中央处，有一个白色的倒三角，看起来很像上方区域到下放区域的延伸，视觉效果非常不错。我不知道这个效果的学名叫什么，姑且叫做『折角』吧。<br><img src="/img/zhejiaodemo.png" alt=""></p>
<a id="more"></a>
<p>发扬『钻头』精神，使用chrome的『审查元素』和『查看源代码』，我把该效果使用的css定义挖掘出来，制作了一个小demo，效果图是这样的：</p>
<p><img src="/img/zhejiao.png" alt=""></p>
<p>首先新建一个style.css文件，用文本编辑器打开，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.footer_bottom &#123;</span><br><span class="line"> background:#2c2e2e; </span><br><span class="line"> min-height:80px;</span><br><span class="line"> &#125; </span><br><span class="line">.footer_bottom &#123;</span><br><span class="line"> background:url(bg.png);</span><br><span class="line"> &#125;</span><br><span class="line">.footer_bottom h3 &#123;</span><br><span class="line"> color:#FFFFFF;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.frow &#123;</span><br><span class="line"> background:url(row_w.png) 50% 0% no-repeat; </span><br><span class="line"> padding-top:10px;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><p><code>footer_bottom</code>的作用是渲染demo中的黑色区域，设定高度、背景图片、区域内文字字体颜色等。</p>
</li>
<li><p><code>frow</code>的作用就是把我们那个白色的倒三角图片放到合适的位置，<code>50% 0%</code>用来控制其位置的横纵坐标。</p>
</li>
<li><p><a href="https://linost.com/img/row.png" target="_blank" rel="external">白色三角</a>和<a href="https://linost.com/img/bg.png" target="_blank" rel="external">黑色背景</a>，都是图片，点击链接查看。文末会给出这个demo的源文件供大家参考。</p>
</li>
</ul>
<p>接下来新建一个<code>demo.html</code>文件用来测试效果，内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer_bottom"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"frow"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is a demo!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>好了，这个效果的制作介绍完了，动手试试吧！</p>
<p>PS: demo源文件<a href="http://pan.baidu.com/share/link?shareid=116398762&amp;uk=1661888259" target="_blank" rel="external">在此</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端之drop-shadow效果]]></title>
      <url>http://codeinterviews.com/box-and-shadow-effect/</url>
      <content type="html"><![CDATA[<p>今天从<a href="https://news.ycombinator.com/" target="_blank" rel="external">hackernews</a>跳入<a href="https://commando.io/" target="_blank" rel="external">COMMANDO</a>来看它的『 flatten bootstrap』效果，却被网页简洁、漂亮的UI吸引住了。我对bootstrap已经比较了解，一眼就能看出来这个网站的主页是根据bootstrap主页经过简单修改得到的。一直下拉到网页底部，看到了这个效果：</p>
<p><img src="/img/ui1.png" alt=""></p>
<p>这种有点立体感的小框，曾在不少网站见到过，一直很喜欢。这次决定认真研究一下效果是什么做出来的。</p>
<a id="more"></a>
<p>比较懒，先在<a href="http://www.v2ex.com/t/73328#;" target="_blank" rel="external">V2EX</a>提问，没有得到详细的回答。于是狠心用chrome工具『审查元素』来分析。找到相应模块的标签，找到css文件并根据标签进行查找。将有关的css定义提取出来，做了一个简单的例子进行尝试。终于弄明白这个效果是怎么产生的。</p>
<p>这里先展示一下成品：</p>
<p><img src="/img/uidemo.png" alt=""></p>
<p>首先新建一个<code>style.css</code>文件，用文本编辑器打开，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*下面的css定义已经是最精简形式，每一项的更改或删除都会影响最终效果。作为学习，不妨尝试修改小项查看效果，以增加了解。*/</span><br><span class="line">.box &#123;</span><br><span class="line">    background:#fff;</span><br><span class="line">    box-shadow:none;</span><br><span class="line">    border:1px solid #ddd;</span><br><span class="line">    -webkit-border-radius:3px;</span><br><span class="line">    border-radius:3px;</span><br><span class="line">    padding:60px 0;</span><br><span class="line">    margin-top:15px;</span><br><span class="line">    margin-bottom:60px;</span><br><span class="line">&#125;</span><br><span class="line">.drop-shadow &#123;</span><br><span class="line">   position:relative;</span><br><span class="line">&#125;</span><br><span class="line">.drop-shadow:before,</span><br><span class="line">.drop-shadow:after &#123;</span><br><span class="line">   content:&quot;&quot;;</span><br><span class="line">   position:absolute;</span><br><span class="line">   z-index:-1;</span><br><span class="line">    bottom:15px;</span><br><span class="line">   left:10px;</span><br><span class="line">   width:50%;</span><br><span class="line">   height:20%;</span><br><span class="line">   -webkit-box-shadow:0 15px 10px rgba(0, 0, 0, 0.7);</span><br><span class="line">   -moz-box-shadow:0 15px 10px rgba(0, 0, 0, 0.7);</span><br><span class="line">   box-shadow:0 15px 15px rgba(0, 0, 0, 0.7);</span><br><span class="line">   -webkit-transform:rotate(-2deg);</span><br><span class="line">   -moz-transform:rotate(-2deg);</span><br><span class="line">   -o-transform:rotate(-2deg);</span><br><span class="line">   transform:rotate(-2deg);</span><br><span class="line">&#125;</span><br><span class="line">.drop-shadow:after&#123;</span><br><span class="line">   right:10px;</span><br><span class="line">   left:auto;</span><br><span class="line">   -webkit-transform:rotate(2deg);</span><br><span class="line">   -moz-transform:rotate(2deg);</span><br><span class="line">   -o-transform:rotate(2deg);</span><br><span class="line">   transform:rotate(2deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>css文件做好之后，新建一个html文件做测验。文件名不妨叫<code>demo.html</code>，内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"span12 box drop-shadow"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is a demo!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：此html文件和css文件在同一文件夹下。</p>
<p>保存并打开html文件，就能看到预期效果了。</p>
<p>其中，box的作用是撑起这个『框架』，drop-shadow中的before和after产生框架左右两侧的阴影效果。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何绑定二级域名]]></title>
      <url>http://codeinterviews.com/secondary-dns/</url>
      <content type="html"><![CDATA[<p>我曾在<a href="http://zipperary.com/2013/05/27/domain-name-and-dns/" target="_blank" rel="external">购买域名、设置DNS</a>一文中介绍过『如何在Goddady购买域名，在DNSPod设置域名映射』。本文在此基础上介绍一下怎样绑定二级域名（a.aa.com形式）。</p>
<p>我在『百度开放平台』新建了一个web应用，百度提供了<code>duapp.com</code>下的二级域名，如<a href="http://1.yiqiansw.duapp.com/" target="_blank" rel="external">http://1.yiqiansw.duapp.com/</a>。也可以自由绑定其他域名。这里以此为例进行介绍。</p>
<ol>
<li><p>在百度开发者中心，查看CNAME记录。</p>
<p><img src="/img/sdns1.png" alt=""><br>按照上图打开『域名绑定』窗口。我们看到，第一步是『将您的自有域名的CNAME记录指向：yiqiansw.duapp.com』，这里<code>yiqiansw.duapp.com</code>是百度默认提供的域名。（该窗口不要关闭，稍后会回来）</p>
<a id="more"></a> </li>
<li><p>在<a href="https://www.dnspod.cn" target="_blank" rel="external">DNSPOD</a>设置二级域名映射。</p>
<p>在主域名下面，添加一条CNAME记录。如图：</p>
<p><img src="/img/sdns2.png" alt=""></p>
</li>
<li><p>回到第一步中打开的窗口，在『自由域名』栏填写<code>yiqiansw.zipperary.com</code>。勾选『我承诺自有域名已备案，并同意百度域名绑定法务协议』。点击『确认绑定』。</p>
</li>
</ol>
<p>好了，到这里我们已经成功绑定二级域名，查看<a href="http://yiqiansw.zipperary.com" target="_blank" rel="external">http://yiqiansw.zipperary.com</a>。</p>
<p>吐槽两句：新浪SAE是收费的，『云豆』用完后直接把我的APP全停了。百度的BAE是后起之秀，趁着未收费之际先寄居于此吧，反正不比SAE差！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大规模机器学习]]></title>
      <url>http://codeinterviews.com/large-scale-ml/</url>
      <content type="html"><![CDATA[<p>机器学习在这几年得到快速发展，一个很重要的原因是 Large Dataset（大规模数据），这节课就来介绍用机器学习算法处理大规模数据的问题。</p>
<p>关于数据的重要性，有一句话是这么说的：</p>
<blockquote>
<p>It’s not who has the best <strong>algorithm</strong> that wins.<br>It’s who has the most <strong>data</strong>.</p>
</blockquote>
<p>然而，当数据量过大时，计算的复杂度会增加，计算成本也会提高。假如数据量是一百万，使用梯度下降算法来训练参数，每走一步，需要对百万数据进行求和计算，这样的计算量是极大的。但现实问题总是有大量数据，比如全国的车辆、网民等等。那么，我们就有必要研究一下如何更好地处理大规模数据。</p>
<a id="more"></a>
<p>###方案一：Stochastic Gradient Descent </p>
<p>以 linear regression 为例，先开看看我们原来的梯度下降算法：</p>
<p><img src="/img/lsml1.png" alt=""></p>
<p>图中给出了要求的model h(x)、目标函数J、以及梯度下降算法（循环部分）。迭代的过程：每一步使用所有数据计算θ，并重新赋值，然后下一步再使用所有数据和上一步求得的θ更新θ。图中右侧，中心点是最优点，θ从起始点，每迭代一步就像中心点移动一步，最终走到中心点求出θ最优值。这里的问题是，每迭代一步，就需要计算所有数据（如百万数据）。</p>
<p>上述梯度下降算法也叫 batch gradient descent 。下面我们做些改进，以适应大数据的情况。</p>
<p><img src="/img/lsml2.png" alt=""></p>
<p>上图右侧，我们改变了迭代形式。对于训练集中每个数据，fit θ，使得模型符合这个数据，然后用第二个数据走同样步骤，以此类推。也就是说，每个数据都能获得目前为止最优的θ。这样的迭代，我们称为 stochastic gradient descent 。</p>
<p>需要注意：迭代之前，需要 randomly shuffle training example. 因为数据的不同使用次序，得到的结果不尽相同。</p>
<p>下面给出该算法的步骤和演示图：</p>
<p><img src="/img/lsml3.png" alt=""></p>
<p>从演示图可以看出，θ最后可能围绕最优点左右摇摆而达不到最优点。θ甚至可能不会converge。那么，<strong>怎么检查θ能否converge呢？</strong></p>
<p>每迭代n个数据（eg.1000），使用目前得到的θ，计算这n个数据的cost，并绘制在横坐标为迭代次数、纵坐标为cost的坐标系中。随着迭代次数增加，坐标系中的曲线越来越长。观察曲线形状，如果一直呈下降趋势，那么说明可以converge，如果一直上下摇摆或者上升趋势，就说明无法converge。对于后者，可以随着迭代次数的增加逐渐减小α（学习速度），就可以保证θ可以converge。</p>
<p><strong>一个应用：Online learning</strong></p>
<p>Online learning 是根据不断涌入的新数据更新θ从而改进我们的model。例如一个货运订单系统，用户输入出发地、目的地，网站会给出价格，用户会选择下单或取消。这里的model就是，给出用户特征和出发地、目的地，通过model得出适当价格。这是一个 logistic regress 问题。每当有一个用户进行上述行为，我们的训练集就动态增加了一个数据，这样就可以使用 stochastic gradient descent 动态优化model。</p>
<p>###方案二： Mini-Batch Gradient Descent </p>
<p>在 batch gradient descent 中，我们每次迭代使用全部m个数据。</p>
<p>在 stochastic gradient descent 中，每次迭代使用1个数据。</p>
<p>在 Mini-Batch Gradient Descent  中，每次迭代用b（2-m）个数据，算作一种折中方案。b即为 mini-batch 。</p>
<p>结合上面两个算法，第三个算法很容易理解，如下：</p>
<p><img src="/img/lsml4.png" alt=""></p>
<p>###方案三：Map Reduce and Data Parallelism</p>
<p>当数据量很大，我们又希望使用 batch gradient descent 时，可以将数据分割并分布到不同 的机器上进行局部运算，然后汇总。</p>
<p><img src="/img/lsml5.png" alt=""></p>
<p>图中，把迭代式加和的部分分割开，400个数据分布到4台机器上，每台机器同步处理100个数据，<br>最后将四个结果再相加，得到迭代式中加和项的结果。</p>
<p>总的来说，对于大数据，或者分布到不同机器上同步处理，或者使用单数据迭代的算法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Recommender System(推荐系统)]]></title>
      <url>http://codeinterviews.com/recommender-system/</url>
      <content type="html"><![CDATA[<p><strong> Recommender System </strong> （推荐系统）是机器学习中一个极为常见且重要的应用，本节就来做一下介绍。</p>
<p>###为什么要介绍「推荐系统」</p>
<p>有两个原因：</p>
<ol>
<li><p>「推荐系统」在很多公司中被作为一项战略级别的应用，是盈利的重要来源，例如亚马逊、Netflix。这些网站根据用户的使用历史，推荐用户可能喜欢、感兴趣的产品。</p>
</li>
<li><p>机器学习中有一个很重要的理念，就是“自动选择特征”，而「推荐系统」就是一个很好的应用实例。</p>
</li>
</ol>
<p>例子：电影推荐系统。新上一部电影或尚未评分的电影，如何自动评分，推荐给用户。需要用到的数据，网站上不同用户对不同电影的评分情况（1-5）。</p>
<a id="more"></a>
<p>###第一种解决方案：基于内容的推荐系统</p>
<p><img src="/img/rec1.png" alt=""></p>
<p>左栏是五部电影，电影数用nm表示。上横栏是五个用户，用户数用nu表示。右栏是电影的特征向量，有两个特征。中间是不同用户对电影的评分，问号表示未看过。</p>
<p><strong>预测电影评分的原理</strong>就是：每个用户有一个偏好参数，每部电影有个类型特征值（例如浪漫指数、动作指数），我们需要找到一个函数，将用户偏好和电影类型结合起来，生成评分。</p>
<p>上图的底部以Alice对第三部电影的评价为例：x代表电影的类型特征值，θ代表用户对不同类型电影的偏好程度，两个特征值进行点乘，得到评分。</p>
<p>注意，这里用到了有监督学习中的「线性回归算法」。</p>
<p><strong>问题来了，用户偏好θ是怎么求得的呢？</strong></p>
<p>这里就回到了线性回归算法。假设每个用户评价过m部电影，我们的cost function应该是下面的形式(下式为所有用户偏好)：</p>
<p><img src="/img/rec3.png" alt=""></p>
<p>与之前的线性回归算法类似，我们使用「梯度下降算法」学习参数θ，这里不再赘述。</p>
<p>###第二种解决方案：Collaborative Filtering</p>
<p>在第一种方案中，需要事先知道每部电影的类型特征向量，有时候不是很现实。第二方案中，我们会用到的算法可以进行feature learning，自动学习要使用哪些特征。</p>
<p>这里，每部电影的类型特征x未知，但每个用户的偏好特征θ会给出。接下来的cost function和梯度下降算法求x，跟第一种方案几乎一样。</p>
<p>我们的routine是：随机给出θ，估计x，优化θ，优化x…… 也可以换种思路，同时将x和θ最小化：</p>
<p><img src="/img/rec4.png" alt=""></p>
<p>这里正式给出「Collaborative Filtering Algorithm」</p>
<p><img src="/img/rec5.png" alt=""></p>
<p>初始化θ、x，求出θ、x，预测。</p>
<p>###「相关」推荐</p>
<p>有时候网站需要根据用户看过的某部电影推荐另外一部类似的影片，原理很简单。每部电影都有一个特征向量，如果两部电影的特征向量之间的距离很近，那么这两部电影就是相关的，或者说类似。</p>
<p>距离也有很多计算方式：有欧氏距离、绝对值距离、切比雪夫距离、马氏距离、兰氏距离、相似系数、定性指标的距离等，最常用的是欧氏距离。</p>
<p>###其他</p>
<p>如果某个用户尚未对任何电影评分，那么怎样推荐电影给他呢？</p>
<p>方法是：将每个用户对该电影的评分计算平均值，作为上述用户对此电影的默认评分，根据评分的高低决定是否要推荐给该用户。</p>
<p>总结：本节推荐系统，实质上是线性回归算法的一个应用实例，用到的算法都是前面的课程讲到的，这里只是结合「推荐系统」这个例子形象地讲解一下。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Anomaly Detection]]></title>
      <url>http://codeinterviews.com/anomaly-detection/</url>
      <content type="html"><![CDATA[<p>『异常检测』是无监督学习中的又一类算法，其目的是根据训练集中一堆无标记的数据，判断出要测试的数据是否异常。Andrew Ng给出的三个应用例子是plane engine、fraud detection和monitoring computers in a data center.结合下图说明一下什么是『异常检测』。</p>
<p><img src="/img/add1.png" alt=""></p>
<p>图中红色标记的是训练集中的飞机引擎，横纵坐标是飞机引擎的两个特征（feature）。对于一个新的飞机引擎（绿色标志），观测其特征，若落在上面那个位置，我们很容易判断这个引擎是正常的，若落在下面的位置，则有足够的理由将其标记为异常。</p>
<p><strong>『异常检测』的原理</strong>：这一类的数据一般呈正态分布（又叫高斯分布），根据数据的特征向量，容易得出其概率大小，然后跟某个事前约定好的数值进行比较，如果概率比这个值还小，我们就判断这个数据检测出了异常。</p>
<a id="more"></a>
<p>###高斯分布</p>
<p>通过下图回顾一下高斯分布的概念。</p>
<p><img src="/img/add2.png" alt=""></p>
<p>从上图可以看出，根据红色标记的数据的分布情况，我们可以大致画出其分布曲线，形态类似正态分布，那么我们不妨就假设数据是服从正态分布的。现在的任务是，根据训练集中的数据，估计参数 μ、σ2。上图底部给出了参数估计的两个公式。</p>
<p>参数 μ、σ2估计出来之后，根据正态分布的公式，便得到了数据分布式。对于新给的测试数据，输入其特征向量，便得到概率的大小了。</p>
<p>###算法</p>
<p>训练集中有m个数据，特征向量为n维。假设每个特征Xi都服从正态分布。那么该特征向量出现的概率为<code>P(x)=P(x1;μ1,σ21)*P(x2;μ2,σ22)...P(xi;μi,σ2i)...P(xm;μm,σ2m)</code>。 在这里，我们假设“各特征之间是相互独立的”。</p>
<p>总结一下，「anomaly detection」的算法大概三个步骤：</p>
<ol>
<li>选择进行『异常检测』要使用的特征，下面会介绍。</li>
<li>计算每个特征的μ、σ2。</li>
<li>对于新的数据，求出P(x)，与约定好的数据进行比较，若是大于，则OK，否则异常。</li>
</ol>
<p>###选择特征</p>
<p>不是所有的特征都能够用来进行异常检测，我们要使用的特征应该明显服从正态分布的特征，异常数据的数量要远低于正常数据。有时需要create new features，例如，x1可能不服从正态分布，但log(x)服从正态分布，那么我们使用log(x)作为要使用的特征。</p>
<p>###异常检测和有监督学习的区别</p>
<p>异常检测，实际上也是一种有标记的学习，标记就是数据是否异常。那么是否可以直接使用有监督学习中的算法呢？不能！两者有些区别：</p>
<ol>
<li>异常检测中，（y=1）的数据远少于（y=0）的数据。而有监督学习中，两者数量都很大。</li>
<li>异常检测中，异常的种类很多，而数量很少，无法通过学习获得model。而有监督学习中，异常的种类少数量多，足够用来学得一个有效的model。</li>
</ol>
<p>###多元正态分布</p>
<p>在上面的异常检测算法中，我们假设各特征值相互独立，并拆开来分别计算μ和σ。在大多数情况下这么做是完全可以的，也有少数情况会出现问题，如下图。</p>
<p><img src="/img/add5.png" alt=""></p>
<p>图中绿色标记的数据，单独按照特征x1和x2来计算，都是正常数据。但事实上，这是一个异常的数据。这种情况下，我们需要使用多元正态分布来做异常检测。</p>
<p><img src="/img/add7.png" alt=""></p>
<p>多元正态分布的公式上图已给出，图中底部时是参数估计的公式。使用多元正态分布进行异常检测，方法和使用正态分布时（original model）类似，不做介绍了。</p>
<p>需要指出的是，original model是多元正态分布的一个特例。此时，Σ是一个对角阵，对角线上的数据是σ1…σn的平方。</p>
<p>###when to use which</p>
<ol>
<li>original model 有时需要 manually create features，而多元正态分布中直接使用全部特征。</li>
<li>前者 computationally cheaper。</li>
<li>前者 m 可以很小，而后者中，m&gt;n，否则Σ有可能不存在逆矩阵。</li>
<li>前者更常用一些。</li>
</ol>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Principal Componential Algorithm (PCA)]]></title>
      <url>http://codeinterviews.com/pca/</url>
      <content type="html"><![CDATA[<p>今天学习的是<strong>无监督学习</strong>中的第二类算法：<strong>Dimentionality Reduction</strong>，即维度降低。我们所研究的数据集合，每个数据通常都有一个<strong>特征向量</strong>，在真实的问题中，维度往往很高，数量级可以达到上万或者更高。有时候就需要进行降维，<strong>好处</strong>有这几点：</p>
<ul>
<li>Data Compression。数据压缩，大量的数据，每个数据都有很高的特征维度，存储所需要的空间就会很大，对硬件的配置要求也会很高。</li>
<li>Speed up learning。加速学习、提高训练的速度。</li>
<li>Visualization。视觉化是处理问题一个很好的手段，形成图形后可以直观地观察、更好地理解我们的问题。当特征向量超过三维后，就无法用图形表示了，所以这类降维往往需要降到三维以下。</li>
</ul>
<p><strong>数据降维的原理：</strong> 特征向量不同分量之间，往往有一定**的相关性。<br>最简单的例子，我们要表示一根指挥棒，纵坐标为用inch表示其长度，横坐标用cm表示其长度，这样可以形成用二维特征向量表示的特征值。所有的数据都落在一条直线上，事实上也就是一维图形了。<br>假如相关度不如上个例子那么高，我们还是可以找出一条直线进行拟合，然后将所有数据投射到这条直线上，用这些投射点作为降维之后的数据。同理，对于维度为3的特征向量，可以投射到一个平面（plane）上，降为二维。</p>
<a id="more"></a>
<p><strong>PCA：</strong> 全称是Principal Componential Algorithm，是目前使用最广泛、最常用的数据降维算法。我们来通过下图说明一下PCA要做什么：</p>
<p><img src="/img/pca1.jpg" alt=""></p>
<p>上图中，x1和x2为特征向量的两个分量，坐标系中分布着我们的数据。我们的目的就是寻找这样一条直线（一个一维的向量），使得每个数据点到直线的平均距离最小。同样的，要把n为特征向量降为k维，需要找到k个向量，每个向量用u(i)表示。</p>
<p>###PCA与linear regression（线性回归）的关系</p>
<p>二者都是在坐标系中寻找一个拟合surface，但有以下区别：</p>
<ol>
<li>linear regression的坐标系中有y，pca中没有。</li>
<li>linear regression中的距离，所有x点对应的真实值y=g(x)与估计值f(x)之间的vertical distance距离。</li>
</ol>
<p>###PCA流程</p>
<p>首先要对数据进行预处理，以使得后面的计算更方便。预处理方法有两个：</p>
<ol>
<li>mean normalization。 计算各特征的平均值，记为μj ，（Xj(i)表示第i个样本的第j维特征的value） <code>μj = Σm Xj(i)/m</code>，然后令<code>Xj(i)= (Xj(i)-μj)</code>。使得各特征的平均值为0.</li>
<li>feature scaling。不同的特征分量，其取值范围不同，比如0-1000、0-1000000，feature scaling的目的就是要使所有特征分量的取值范围相同。方法是：令<code>Xj(i)= (Xj(i)-μj)/sj</code>。</li>
</ol>
<p>下面进入PCA核心部分。</p>
<ol>
<li><p>计算n*n的协方差矩阵Σ。</p>
<p><img src="/img/pca2.jpg" alt=""></p>
</li>
<li><p>计算Σ的<strong>eigenvectors</strong>。<code>[U,S,V]=SVD（Σ）</code>。这是octave中的计算式。SVD为奇异值分解（singular value decomposition），) 。 其中U为n*n的矩阵，取前k列，就得到我们需要的k个向量，这k个向量构成的矩阵我们记为Ureduce。</p>
</li>
<li><p>计算每个数据降维后的特征向量表示。</p>
<p><img src="/img/pca3.png" alt=""></p>
</li>
</ol>
<p>现在讨论几个相关的问题。</p>
<p>###K值大小的确定</p>
<p>首先给出下式：</p>
<p><img src="/img/pca4.png" alt=""></p>
<p>分子叫做：average squared projection error.</p>
<p>分母叫做：total variance.</p>
<p>分式叫做：error ratio. 由于降维后肯定会有信息量的损失，error ratio就是衡量损失的大小。我们需要确定一个threshold，使得当我们使用这k个主成分时，error ratio &lt; threshold，否则信息量损失太大。例如，error ratio&lt;0.01，我们也说，99% of variance is retained。</p>
<p>从上面<code>[U,S,V] = SVD（Σ）</code>返回值中有一个S。S是一个对角阵。可以证明：</p>
<p><img src="/img/pca5.png" alt=""></p>
<p>这样，只要返回一个S，我们就可以按照上式进行计算，将k从1逐渐增大，直到符合要求。</p>
<p>###Reconstruction from compressed representation</p>
<p>特征向量从n维降到k维后，我们需要再恢复到n维怎么办？</p>
<p><code>xapprox = (U&#39;)-1×z = (U-1)-1×z = Uz</code></p>
<p>这里的xapprox是x的近似值。</p>
<p>###PCA的错误使用</p>
<p>既然PCA可以降维，可不可以用来prevent overfitting呢？不能！因为降维时没有考虑到y。应该首选regularization来解决overfitting。</p>
<p>不要盲目用PCA。能用原始数据的尽量用原始数据，当存储量不够、学习缓慢时，可以考虑使用PCA。</p>
<p>###遗留问题</p>
<p>这个课程里并没有详细讲解PCA算法细节，只是给了octave中用到的公式。算法细节需要另外找资料学习。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[k-means algorithm]]></title>
      <url>http://codeinterviews.com/k-means-algorithm/</url>
      <content type="html"><![CDATA[<p>最近在学习『机器学习』这门课，使用的斯坦福大学Andrew Ng在<strong>Coursera</strong>的在线课程。机器学习主要包括<strong>有监督学习</strong>和<strong>无监督学习</strong>。我的学习进度到了后者。今天学习的是无监督学习中最常见、最普遍、最基础的一类问题——<strong>clustering</strong>。</p>
<p><strong>首先说说什么是有监督学习和无监督学习。</strong>  </p>
<p>给出一个数据集合，如果对于集合中的每个数据，不仅有该数据的特征值向量，而且每个数据都进行了类型标记，我们把这个集合叫做训练集（training set）。然后我们通过一些算法进行学习。学习的目的是，找到一个判别函数，给定一个新的数据，这个判别函数能输出这个数据的所属分类。找到这样的判别函数的过程，就叫做有监督学习。这里的监督，指的是训练集中的每个数据都进行了类别标记。  </p>
<p>与此相反，对于无监督学习，每个数据并没有进行类别标记，我们只知道它的特征向量，并不知道所属类别。</p>
<p>所谓<strong>clustering（聚类）</strong>，就是给定一个数据集合，集合大小为m，每个数据都有特征向量x，我们通过某种算法，将这批数据瓜分成k组，每个数据分别属于某一组。</p>
<p>下面直观地说明一下什么是聚类问题，以及聚类的流程。</p>
<p><img src="/img/kmeans.png" alt=""></p>
<p>左上角的图中，绿点表示我们的数据集合，横、纵坐标分别是数据的特征值向量分量。例如，数据表示衬衫的尺寸（L/M/S），横、纵坐标分别表示height和weight。我们的目的是将这批数据分为k组（比如3组，L/M/S）。</p>
<p><strong>聚类的过程</strong>如下：</p>
<ol>
<li>随机选择两个location，作为<strong>class centroid</strong>(种子)。如左上图中蓝色和红色x。</li>
<li>对于数据集合中的每个数据点，分别计算到两个种子的距离，并互相比较，如果距离蓝色种子近则标记为蓝色，否则标记为红色。如右上图。这个过程叫class assignment。</li>
<li>计算每一临时组的中心点（average），并作为这一组新的种子。如左下图，种子移动到了中心点。</li>
<li>重复2、3，直到种子不再变动。</li>
</ol>
<p>在<strong>有监督学习</strong>中，有个<strong>cost function</strong>，用J表示。学习的过程，就是不断调整参数，使得J最小。在<strong>无监督学习</strong>中，也有类似的cost function，在k-means中，我们把它叫做<strong>distortion cost function</strong>。如图：</p>
<p><img src="/img/opob.png" alt=""></p>
<p>式子右边，表示的是每个点到它所属分组的种子的距离平均值，也就是要最小化这个距离。这里的参数，就是种子的位置和每个数据所属分组。</p>
<p><strong>k-means算法的几个问题</strong></p>
<ol>
<li><p>如何选择k的大小？</p>
<p>Andrew Ng说并没有最好的办法。但有以下3个方法可以考虑：</p>
<ul>
<li>观察数据分布大致情况，manually set the number k.</li>
<li><p>Elbow method。如图：<br><img src="/img/elbow.png" alt=""><br>我们对k取不用的值，分别计算相应的J（cost function），绘制图像，转弯最急的那点就是elbow（类似人的胳膊肘）。缺点是，有些根本找不到明确的elbow点，如第二个图。</p>
</li>
<li><p>purpose。我们进行聚类，一般都是要服务于某个目的或用途。因此，可以根据具体的用途确定k的大小。比如对于衬衫，是分为3类好还是分为5类好，要看哪一个能更好地服务于我们的应用。</p>
</li>
</ul>
</li>
<li><p>如何确定k个种子的初始位置？</p>
<p>Ng教授给出以下建议：</p>
<ol>
<li>K &lt; m，组数要比数据集合的大小小。</li>
<li>从数据集合中，随机选取k个。</li>
<li>这k个数据就是初始的k个种子。</li>
</ol>
<p>由于种子的初始位置对于聚类结果影响很大，不同的初试位置聚类的效果好坏也不同。我们可以进行多次聚类，每次选择不同的初始种子，然后选择J最小的那次聚类。</p>
</li>
</ol>
<p>k-means算法的演示地址：<a href="http://home.deib.polimi.it/matteucc/Clustering/tutorial_html/AppletKM.html" target="_blank" rel="external">K-means - Interactive demo</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown 番外篇]]></title>
      <url>http://codeinterviews.com/markdown-extras/</url>
      <content type="html"><![CDATA[<p>开博后写过一篇<a href="http://zipperary.com/2013/05/22/introduction-to-markdown/" target="_blank" rel="external">Introduction to markdown</a>，给出了几个介绍markdown的教程。这几个教程或是简明易懂，或是全面规范，可以作为很好的入门教材或查阅手册。</p>
<p>在实际的使用当中，我发现有些用法不是这些教程里能够找到的，或者教程里没有进行应有的强调导致使用时容易出错。本文就对这样的问题进行汇总，并会不定期更新。</p>
<ol>
<li><p>删除线。</p>
<p>方法：在要划删除线的文本前后添加<code>~~</code></p>
<p>示例：<code>~~看《冰与火之歌》~~</code></p>
<p>解析为： <del>看冰与火之歌</del></p>
</li>
<li><p>代码块中html代码显示不正常，<code>&lt;、&gt;</code>被解析为<code>&amp;gt; &amp;lt;</code></p>
<p>原因：markdown是一个语法规范，具体的解析可以使用不同的程序，而不同程序对规范的完成度也未必相同。hexo 所用的 marked 解析程序，无法对代码块中<code>&lt;、&gt;</code>做正确解析，需要人工矫正。</p>
<p>方法：标明语言类型html</p>
<p>示例： </p>
<p><img src="/img/kk.png" alt=""></p>
<p>解析为：</p>
<p><img src="/img/kkk.png" alt=""></p>
</li>
<li><p>有序列表。</p>
<p>问题：有序列表每项中包含若干段落时，这几个列表项得不到正确解析。</p>
<p>方法：在每个列表项中各段落之前加一个空格。</p>
<p>示例：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. foo</span><br><span class="line"></span><br><span class="line"> foo</span><br><span class="line"> </span><br><span class="line">2. bar</span><br><span class="line"></span><br><span class="line"> bar</span><br></pre></td></tr></table></figure>
<p> 解析为：</p>
<ol>
<li><p>foo</p>
<p>foo</p>
</li>
<li><p>bar</p>
<p>bar</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识node.js]]></title>
      <url>http://codeinterviews.com/learn-nodejs/</url>
      <content type="html"><![CDATA[<p>这几天在V2EX看到很多<em>node.js</em>相关的招聘贴，有招后端的，有招前端的，多是初创公司，可以看出<em>node.js</em>的火热程度。正好我所用的博客框架<em>hexo</em>是基于<em>node.js</em>的，本就想了解下<em>hexo</em>的工作原理，再加上众多招聘贴金光闪闪的刺激，学习<em>node.js</em>的兴致就上来了。</p>
<p>原来跟过<a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="external">《Node入门》</a>这个教程，学习时也做了些笔记。这次找到另外一个教程<a href="http://www.infoq.com/cn/master-nodejs" target="_blank" rel="external">《深入浅出Node.js》</a>，更加侧重背景技术的介绍。现在根据我的学习，对<em>node.js</em>做个简单介绍。</p>
<p><em>node.js</em>这个词，后缀是<em>.js</em>，是不是一种javascript程序呢？非也。javascript是使用最多的前端技术，由浏览器解析后呈现在用户面前。而<em>node.js</em>是一项后端技术，准确的说，它既提供了后端的运行时环境，又是一个库。</p>
<p>那与javascript有关系没有？有。首先，<em>node.js</em>的语法同javascript。其次，<em>node.js</em>用的引擎是Chrome浏览器用于解析javascript的V8引擎。正因为与javascript关系紧密，很多前端可以更为轻松地转为<em>node.js</em>后端开发。</p>
<p><em>node.js</em>于2009年诞生，创始人是 Ryan Dahl。它采用C++语言编写而成，是一个Javascript的运行环境。<em>node.js</em>采用了Google Chrome浏览器的V8引擎，性能很好，同时还提供了很多系统级的API，如文件操作、网络编程等。</p>
<p><em>node.js</em>的特点是：事件驱动、异步编程，为网络服务而设计。回调函数注册后，等待事件的触发，而无需阻塞等待，这样充分利用了服务器的资源。</p>
<p><em>node.js</em>的安装很简单，在 Windows 环境下安装 Node.js，仅须<a href="http://nodejs.org/" target="_blank" rel="external">下载</a>安装文件并执行即可完成安装。</p>
<p>安装完成后，通过<code>node -v</code>命令可以查看是否安装成功，成功则显示<em>node.js</em>的版本。</p>
<p>使用：创建一个example.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;); </span><br><span class="line">http.createServer(function (req, res) &#123; </span><br><span class="line">    res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); </span><br><span class="line">    res.end(&apos;Hello World\n&apos;); </span><br><span class="line">&#125;).listen(1337, &quot;127.0.0.1&quot;); </span><br><span class="line">console.log(&apos;Server running at http://127.0.0.1:1337/&apos;);</span><br></pre></td></tr></table></figure></p>
<p>运行<code>node example.js</code> 执行文件，然后打开浏览器，访问<code>http://127.0.0.1:1337/</code>，<em>node.js</em>服务器和example.js就运行起来了。</p>
<p>上述安装好<em>node.js</em>后，会把一些核心包安装到本地。我们需要使用别人的模块怎么办？神器：NPM。</p>
<p>NPM的全称是Node Package Manager，如果你熟悉ruby的gem，Python的PyPL、setuptools，PHP的pear，那么你就知道NPM的作用是什么了。没错，它就是Nodejs的包管理器。我们使用上述方法安装<em>node.js</em>时，默认附带安装好了NPM，不需要另行安装。</p>
<p>使用NPM安装扩展包的方法很简单，<code>npm install -g 包名</code>。<br>其中的<code>-g</code>参数指明我们使用全局路径。这个命令会把模块安装在 <code>$PREFIX/lib/node_modules</code> 下，可通过命令 <code>npm root -g</code> 查看全局模块的安装目录。<br>例如，我想使用hexo搭建博客，需要安装hexo包，应该使用命令<code>npm install -g hexo</code>进行安装，安装目录在<code>C:\Users\zippera\AppData\Roaming\npm\node_modules</code>，hexo使用的所有包都可以在该目录下找到。</p>
<p>如何创建自己的模块，并在适当的地方使用呢？通过下面的例子就能看出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var PI = Math.PI;</span><br><span class="line">exports.area = function (r) &#123;</span><br><span class="line">    return PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line">exports.circumference = function (r) &#123;</span><br><span class="line">    return 2 * PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将这个文件存为circle.js，并新建一个app.js文件，并写入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var circle = require(&apos;./circle.js&apos;);</span><br><span class="line">console.log( &apos;The area of a circle of radius 4 is &apos; + circle.area(4));</span><br></pre></td></tr></table></figure></p>
<p>在require了这个文件之后，定义在exports对象上的方法便可以随意调用。</p>
<p>好了，既然是初识，就讲到这里、点到为止吧。</p>
<p>现在比较知名的<em>node.js</em>用户有LinkedIn、淘宝，<em>node.js</em>的优势正在得到越来越多的认可，以后有必要的话会做深入学习。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo系列教程：（五）hexo博客的优化技巧续]]></title>
      <url>http://codeinterviews.com/hexo-guide-5/</url>
      <content type="html"><![CDATA[<p>继续介绍hexo博客的优化和使用。</p>
<p>###添加RSS</p>
<p>hexo提供了RSS的生成插件，需要手动安装和设置。步骤如下：</p>
<ol>
<li>安装RSS插件到本地：<code>npm install hexo-generator-feed</code></li>
<li><p>开启RSS功能：编辑<code>hexo/_config.yml</code>，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">- hexo-generator-feed</span><br></pre></td></tr></table></figure>
</li>
<li><p>在站点添加链接：<br>在<code>themes/light/_config.yml</code>中，编辑 <code>rss: /atom.xml</code><br>在<code>themes/light/layout/_partial/header.ejs</code>中，<code>&lt;ul&gt;&lt;/ul&gt;</code>之间，添加一样代码<code>&lt;li&gt; &lt;a href=&quot;/atom.xml&quot;&gt;RSS&lt;/a&gt; &lt;/li&gt;</code></p>
</li>
</ol>
<p>###添加sitemap</p>
<p>同样的，我们使用hexo提供的插件，方法与添加RSS类似。</p>
<ol>
<li>安装sitemap到本地：<code>npm install hexo-generator-sitemap</code></li>
<li><p>开启sitemap功能：编辑<code>hexo/_config.yml</code>，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">- hexo-generator-sitemap</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<code>zipperary/sitemap.xml</code>即可看到站点地图。不过，sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。</p>
</li>
</ol>
<p>###设置百度统计、Google Analytics<br><a id="more"></a><br>到<a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="external">百度统计</a>和<a href="http://www.google.com/analytics/" target="_blank" rel="external">Google Analytics</a>（可能需要穿墙）注册账号、添加网站地址即可，很简单，不详述了。需要注意的是，设置好之后数据要过几个小时才能出现，不用着急。</p>
<p>###购买域名、设置DNS</p>
<p>参考之前的这篇博客<a href="http://zipperary.com/2013/05/27/domain-name-and-dns/" target="_blank" rel="external">购买域名、设置DNS</a></p>
<p>###文章中插入图片</p>
<p>使用markdown写文章，插入图片的格式为<code>![图片名称](链接地址)</code>，这里要说的是链接地址怎么写。对于hexo，有两种方式：</p>
<ol>
<li>使用本地路径：在<code>hexo/source</code>目录下新建一个<code>img</code>文件夹，将图片放入该文件夹下，插入图片时链接即为<code>/img/图片名称</code>。</li>
<li>使用<em>微博图床</em>，地址<a href="http://weibotuchuang.sinaapp.com/" target="_blank" rel="external">http://weibotuchuang.sinaapp.com/</a>，将图片拖入区域中，会生成图片的URL，这就是链接地址。</li>
</ol>
<p>###加入「fork me on github」</p>
<p><a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="external">这里</a>有 github 给出的教程，把代码插入到任意一个全局的模板文件中就行，比如<code>layout.ejs</code>的末尾。</p>
<p>###bug:「warning: LF will be replaced by CRLF」</p>
<p>在<code>hexo deploy</code>时，有时会出现这个提示信息<code>warning: LF will be replaced by CRLF</code>，虽然看起来挺乱糟糟的，但不影响使用，可以忽略不计。若想不提示，可以使用如下方法：</p>
<ol>
<li>切换到博客的根目录，执行如下命令：<code>git config --global core.autocrlf  false</code></li>
<li>删除掉该目录下的<code>.git</code>文件夹（可能是隐藏的），命令：<code>rm -rf .git</code></li>
<li>重新<code>git init</code>。</li>
</ol>
<p>再deploy试试吧，清新脱俗了。</p>
<p>###bug:<code>hexo deploy</code>没反应</p>
<p>好多网友遇到过这个问题，目前来看，主要问题出在config.yml的deploy配置上。注意缩进，同时注意冒号后面要有一个空格。</p>
<p>###bug:<code>hexo update -g</code>升级错误，hexo命令失效</p>
<p>我升级时遇到了这个问题，原因不详。这种情况下，可执行<code>npm install -g hexo</code>重新安装一遍hexo，效果跟升级一样。各版本所做更新修正，请参考<a href="https://github.com/tommy351/hexo/releases" target="_blank" rel="external">这里</a>。</p>
<p>###bug:搜索框进行搜索：没有结果</p>
<p>点击搜索后进入的google页面，搜索框里面是不是显示「site:yoursite.com」，这说明有个地方没有设置，请随我来：</p>
<p>打开根目录下的config文件，第15行，<code>url:</code>，自觉填上吧。</p>
<p>###bug:代码块中不显示行号</p>
<p>hexo 的作者已经提示过了，使用四个空格的方式标志代码块的确没行号，需要行号的要使用反引号的方式。</p>
<p>###文件结构</p>
<p>最后，贴上文件结构的截图，供大家参考。</p>
<p><img src="/img/zipperary.png" alt="hexo根目录"></p>
<p><img src="/img/source.png" alt="source目录"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo系列教程：（四）hexo博客的优化技巧]]></title>
      <url>http://codeinterviews.com/hexo-guide-4/</url>
      <content type="html"><![CDATA[<p><a href="http://zipperary.com/2013/05/28/hexo-guide-3/" target="_blank" rel="external">上一节</a>中我们已经学会了用hexo发布博客，这里再介绍一些小技巧对博客站点进行优化，实现更加丰富的功能。</p>
<p>###添加“多说”评论</p>
<p>hexo默认使用国外比较流行的disqus，不过，按照“因地制宜”的原则，我们修改为国内用的多又好用的“多说”评论系统。步骤非常简单：</p>
<ol>
<li>在<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>进行注册，获得通用代码。</li>
<li>将通用代码粘贴到<code>themes\light\layout\_partial\comment.ejs</code>里面，如下：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> ( <span class="attr">page.comments</span>)&#123; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"comment"</span>&gt;</span></span><br><span class="line">通用代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>很多网友反映自己使用的非 light 主题中找不到相应的文件。我的这些修改都是在 light主题中，其他主题没有了解过，各位只好自己探索了。</em></p>
<p>###添加『页面导航』</p>
<p>在刚才添加「多说」评论的文件中，加入一段代码，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> ( <span class="attr">page.comments</span>)&#123; %&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"pagination"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">page.prev</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- config.root %&gt;&lt;%- page.prev.path %&gt;"</span> <span class="attr">class</span>=<span class="string">"alignleft prev"</span> &gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">prev</span>') %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">page.next</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- config.root %&gt;&lt;%- page.next.path %&gt;"</span> <span class="attr">class</span>=<span class="string">"alignright next"</span> &gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">__</span>('<span class="attr">next</span>') %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"comment"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>###添加“百度分享”</p>
<p>到<a href="http://share.baidu.com/code" target="_blank" rel="external">百度分享</a>获得代码，在<code>themes/light/layout/_partial/article.ejs</code>中，将<code>&lt;%-partial(&#39;post/share&#39;)%&gt;</code>删掉，替换为百度分享的代码。<br><a id="more"></a></p>
<p>###添加小图标</p>
<p>在<code>themes/light/layout/_partial/head.ejs</code>里将<code>&lt;link href=&quot;&lt;%- config.root %&gt;favicon.png&quot; rel=&quot;icon&quot;&gt;</code>替换为<code>&lt;link href=&quot;&lt;%- config.root %&gt;favicon.ico&quot; rel=&quot;icon&quot; type=&quot;image/x-ico&quot;&gt;</code>。将favicon.ico图标文件放在source目录下。制作图标的网站，<a href="http://www.faviconer.com" target="_blank" rel="external">http://www.faviconer.com</a>。</p>
<p>###添加分类、标签云widget</p>
<p>很简单，在<code>themes/light/_config.yml</code>中，添加如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">- category</span><br><span class="line">- tagcloud</span><br></pre></td></tr></table></figure></p>
<p>###添加友情链接widget</p>
<ol>
<li><p>在<code>themes/light/layout/_widget</code>中新建名为<code>blogroll.ejs</code>的文件，编辑内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget tag"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>友情链接<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"entry"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://zipperary.com/"</span> <span class="attr">title</span>=<span class="string">"Zippera's Blog"</span>&gt;</span>Zippera<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>themes/light/_config.yml</code>中，添加如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">- blogroll</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>###生成post时默认生成categories配置项</p>
<p>在<code>scaffolds/post.md</code>中，添加一行<code>categories:</code>。同理可应用在<code>page.md</code>和<code>photo.md</code>。</p>
<p>###添加新浪微博widget(微博秀)</p>
<ol>
<li>去<a href="http://open.weibo.com/widget/weibotopic.php" target="_blank" rel="external">新浪微博开放平台</a>设置和生成微博秀代码。</li>
<li>在<code>themes/light/layout/_widget</code>中新建名为<code>weibo.ejs</code>的文件，将刚才的代码直接保存到这里。</li>
<li>在<code>themes/light/_config.yml</code>中，添加如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">widgets:</span><br><span class="line">- weibo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>###导航栏添加”关于”</p>
<ol>
<li><code>hexo new page &quot;about&quot;</code></li>
<li>到<code>source/about/index.md</code>编辑内容。</li>
<li>在<code>themes/light/_config.yml</code>中，添加如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  关于: /about</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>###主页文章显示摘要</p>
<p>编辑md文件的时候，在要作为摘要的文字后面添加<code>&lt;!--more--&gt;</code>即可。</p>
<p>优化是无止境的，今天先写这些。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo系列教程：（三）hexo博客的配置、使用]]></title>
      <url>http://codeinterviews.com/hexo-guide-3/</url>
      <content type="html"><![CDATA[<p>在<a href="http://zipperary.com/2013/05/28/hexo-guide-2/" target="_blank" rel="external">上一节</a>中，我们在本地和github搭建起了自己的hexo博客站点，但是还未发表过文章，站点的配置还是原来的默认值。在本节，我们来进行个性化的设置，将站点打造成自己的，同时介绍下怎么撰文和发表。</p>
<p>站点配置用到两个文件，一个是对整站的配置<code>H:\hexo\_config.yml</code>，另一个是对主题的配置<code>H:\hexo\themes\light_config.yml</code>，我们来分别介绍。</p>
<p><em>H:\hexo\ _config.yml</em><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: http://zespia.tw/hexo/docs/configure.html</span><br><span class="line">## Source: https://github.com/tommy351/hexo/</span><br><span class="line"></span><br><span class="line"># Site 这里的配置，哪项配置反映在哪里，可以参考我的博客</span><br><span class="line">title: Zippera&apos;s blog #站点名，站点左上角</span><br><span class="line">subtitle: Walk steps step by step #副标题，站点左上角</span><br><span class="line">description: Walk steps step by step #给搜索引擎看的，对站点的描述，可以自定义</span><br><span class="line">author: zippera #在站点左下角可以看到</span><br><span class="line">email: #你的联系邮箱</span><br><span class="line">language: zh-CN #中国人嘛，用中文</span><br><span class="line"></span><br><span class="line"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://zipperary.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line"></span><br><span class="line"># Writing 文章布局、写作格式的定义，不修改</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">auto_spacing: false # Add spaces between asian characters and western characters</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">max_open_file: 100</span><br><span class="line">filename_case: 0</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  backtick_code_block: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class="line">## 2: Enable pagination</span><br><span class="line">## 1: Disable pagination</span><br><span class="line">## 0: Fully Disable</span><br><span class="line">archive: 1</span><br><span class="line">category: 1</span><br><span class="line">tag: 1</span><br><span class="line"></span><br><span class="line"># Server 不修改</span><br><span class="line">## Hexo uses Connect as a server</span><br><span class="line">## You can customize the logger format as defined in</span><br><span class="line">## http://www.senchalabs.org/connect/logger.html</span><br><span class="line">port: 4000</span><br><span class="line">logger: false</span><br><span class="line">logger_format:</span><br><span class="line"></span><br><span class="line"># Date / Time format 日期格式，不修改</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: MMM D YYYY</span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination 每页显示文章数，可以自定义，我将10改成了5</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 5</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Disqus Disqus插件，我们会替换成“多说”，不修改</span><br><span class="line">disqus_shortname:</span><br><span class="line"></span><br><span class="line"># Extensions 这里配置站点所用主题和插件，暂默认，后面会介绍怎么修改</span><br><span class="line">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</span><br><span class="line">## Themes: https://github.com/tommy351/hexo/wiki/Themes</span><br><span class="line">theme: light</span><br><span class="line">exclude_generator:</span><br><span class="line">plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line"># Deployment 站点部署到github要配置，上一节中已经讲过</span><br><span class="line">## Docs: http://zespia.tw/hexo/docs/deploy.html</span><br><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https://github.com/zippera/zippera.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>现在可以<code>hexo generate</code>，<code>hexo server</code>，打开<code>localhost:4000</code>查看效果了。</p>
<p><em>H:\hexo\themes\light_config.yml</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">menu: #站点右上角导航栏，暂时默认，后面介绍修改</span><br><span class="line">  首页: /</span><br><span class="line">  存档: /archives</span><br><span class="line">  关于: /about</span><br><span class="line">  ToDo: /todolist</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">widgets: #站点右边栏，暂时默认，后面介绍修改和添加</span><br><span class="line">- search</span><br><span class="line">- category</span><br><span class="line">- tagcloud</span><br><span class="line">- weibo</span><br><span class="line">- blogroll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">excerpt_link: 阅读全文 #替换为中文</span><br><span class="line"></span><br><span class="line">plugins: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">twitter: #右边栏要显示twitter展示的话，需要在此设置</span><br><span class="line">  username: moxie198</span><br><span class="line">  show_replies: false</span><br><span class="line">  tweet_count: 5</span><br><span class="line"></span><br><span class="line">addthis: #SNS分享，身在天朝，当然用“百度分享”，暂时默认，后面会介绍</span><br><span class="line">  enable: true</span><br><span class="line">  pubid:</span><br><span class="line">  facebook: true</span><br><span class="line">  twitter: true</span><br><span class="line">  google: true</span><br><span class="line">  pinterest: true</span><br><span class="line"></span><br><span class="line">fancybox: true #图片效果，默认</span><br><span class="line"></span><br><span class="line">google_analytics: #要使用google_analytics进行统计的话，这里需要配置ID，暂时默认，后面介绍</span><br><span class="line">rss:  #生成RSS，需要配置路径，暂时默认，后面介绍</span><br></pre></td></tr></table></figure></p>
<p>上面改动的不多，更多的是介绍了下功能，后面会相继介绍具体的修改方法。</p>
<p>好了，站点配置好了，我想发表一篇文章，怎么做呢？</p>
<ol>
<li><code>hexo new &quot;my new post&quot;</code></li>
<li><p>在<code>H:\hexo\source\_posts</code>中打开这个文件（打开方式用“记事本”即可），配置开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: my new post #可以改成中文的，如“新文章”</span><br><span class="line">date: 2013-05-29 07:56:29 #发表日期，一般不改动</span><br><span class="line">categories: blog #文章文类</span><br><span class="line">tags: [博客，文章] #文章标签，多于一项时用这种格式</span><br><span class="line">---</span><br><span class="line">#这里是正文，用markdown写，使用方法参照我原来的博客[Introduction to markdown](http://zipperary.com/2013/05/22/introduction-to-markdown/)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hexo server</code>，访问<code>localhost:4000</code>预览效果。（退出server用Ctrl+c）</p>
</li>
<li><code>hexo deploy</code>，同步到github。访问网站看看效果。</li>
</ol>
<p>现在为止，我们已经搭建起博客，进行一些基本配置，并学会了怎么发表文章。后面会陆续介绍一些高级点的个性化设置，不过在此之前，你可以正常发表博客了。后面的文章你可以不看，有意者请跟随。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo系列教程：（二）搭建hexo博客]]></title>
      <url>http://codeinterviews.com/hexo-guide-2/</url>
      <content type="html"><![CDATA[<p><a href="http://zipperary.com/2013/05/28/hexo-guide-1/#more" target="_blank" rel="external">上一节</a>对hexo进行了简单介绍，本节来讲讲怎么搭建hexo博客。</p>
<p><strong>注意</strong>：本节教程只针对Windows用户，Linux和Mac用户请移步<a href="http://zespia.tw/hexo/zh-CN/docs/install.html" target="_blank" rel="external">hexo安装</a>。</p>
<p>###安装Git<br>下载 <a href="http://code.google.com/p/msysgit/" target="_blank" rel="external">msysgit</a> 并执行即可完成安装。</p>
<p>###安装Node.js<br>在 Windows 环境下安装 Node.js 非常简单，仅须<a href="http://nodejs.org/" target="_blank" rel="external">下载</a>安装文件并执行即可完成安装。</p>
<p>###安装hexo<br>利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择<em>Git bash</em>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure></p>
<p>###创建hexo文件夹<br>安装完成后，在你喜爱的文件夹下（如<code>H:\hexo</code>），执行以下指令(在<code>H:\hexo</code>内点击鼠标右键，选择<em>Git bash</em>)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p>
<p>###本地查看<br><a id="more"></a><br>现在我们已经搭建起本地的hexo博客了，执行以下命令(在<code>H:\hexo</code>)，然后到浏览器输入<code>localhost:4000</code>看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p>好了，至此，本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。</p>
<p>###注册Github账号<br>已有账号可以跳过，没有的，请<a href="https://github.com/signup/free" target="_blank" rel="external">在此</a>进行注册，很简单，这里就不介绍了。<br><img src="/img/repo.png" alt=""></p>
<p>###创建repository<br>在自己<a href="https://github.com/" target="_blank" rel="external">Github</a>主页右下角，创建一个新的repository。比如我的<a href="https://github.com/" target="_blank" rel="external">Github</a>账号是<a href="https://github.com/zippera" target="_blank" rel="external">zippera</a>，那么我应该创建的repository名字应该是<code>zippera.github.io</code>。</p>
<p><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1ea6opuis78j20au01qq2t.jpg" alt=""></p>
<p>###部署<br>编辑<code>_config.yml</code>(在<code>H:\hexo</code>下)。你在部署时，要把下面的<code>zippera</code>都换成你的账号名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https://github.com/zippera/zippera.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>执行下列指令即可完成部署。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>有些新用户需要设置 ssh，否则上述命令会失败。ssh 的介绍和设置方法请看<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="external">官方教程</a>，不用担心，很简单。</p>
<p><strong>记住：</strong>每次修改本地文件后，需要<code>hexo generate</code>才能保存。每次使用命令时，都要在<code>H:\hexo</code>目录下。</p>
<p>Okay,我们的博客已经完全搭建起来了，在浏览器访问<code>zippera.github.io</code>就能看到你的成就了！</p>
<p>###bugs</p>
<ol>
<li>有网友反应右键菜单中没有<code>git bash</code>选项，可以进入开始菜单找到<code>git bash</code>，然后通过<code>cd</code>进入相应目录执行命令。</li>
<li>在github部署完成之后，马上访问可能出现404错误，这是正常的，（最多）等待十分钟左右就可以访问了。如果还不行，那很可能是 github 发送给你的验证邮件你没有打开看，据多方反映，验证后就没问题了。</li>
<li>如果在<code>hexo d</code>之后出现<code>fatal: &#39;username.github.io&#39; does not appear to be a git repository</code>，一是检查 repo 的名字是否合乎规范、是否含有大写字母、config.yml 中的 deploy 配置是否正确，二是把 git bash 关掉，重新打开再执行命令。</li>
<li>有的同学可能不是 IT 界的，或者对shell 命令不太了解。在要求输入密码时，你输入之后密码是不显示的，这是为了安全，并非是你没输上。</li>
<li>出现乱码的，不要使用 windows 中的「记事本」打开并编辑文件，推荐使用 sublime text，很简单。如果已经在「记事本」中编辑过，需要使用 sublime text 转码为「utf8」。</li>
<li>安装 hexo 时卡在那儿不动，很可能是网络不给力，能全局 break wall 就好了。</li>
<li>遇到什么其他的问题，不妨删除.deploy 和db.json 再重新生成试一试。</li>
</ol>
<p>###tips</p>
<p>hexo现在支持更加简单的命令格式了，比如：</p>
<p><code>hexo g</code> == <code>hexo generate</code></p>
<p><code>hexo d</code> == <code>hexo deploy</code></p>
<p><code>hexo s</code> == <code>hexo server</code></p>
<p><code>hexo n</code> == <code>hexo new</code></p>
<p>在下一节中，我们会介绍如何配置自己的网站，如何撰写和发表文章。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo系列教程：（一）hexo介绍]]></title>
      <url>http://codeinterviews.com/hexo-guide-1/</url>
      <content type="html"><![CDATA[<p><img src="/img/blogshot.png" alt=""></p>
<p>###什么是hexo</p>
<p><a href="http://zespia.tw/hexo/zh-CN/" target="_blank" rel="external">hexo</a>是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在github和Heroku上。作者是来自台湾的<a href="https://github.com/tommy351/hexo" target="_blank" rel="external">@tommy351</a>。引用<a href="https://github.com/tommy351/hexo" target="_blank" rel="external">@tommy351</a>的话，<a href="http://zespia.tw/hexo/zh-CN/" target="_blank" rel="external">hexo</a>：</p>
<blockquote>
<p>快速、简单且功能强大的 Node.js 博客框架。<br>A fast, simple &amp; powerful blog framework, powered by Node.js.</p>
</blockquote>
<p>类似于jekyll、Octopress、Wordpress，我们可以用<a href="http://zespia.tw/hexo/zh-CN/" target="_blank" rel="external">hexo</a>创建自己的博客，托管到github或Heroku上，绑定自己的域名，用markdown写文章。<a href="http://zipperary.com" target="_blank" rel="external">本博客</a>即使用hexo创建并托管在github上。</p>
<p>###为什么要用hexo<br><a id="more"></a><br>还是引用下作者的话：</p>
<blockquote>
<p>不可思议的快速 ─ 只要一眨眼静态文件即生成完成<br>支持 Markdown<br>仅需一道指令即可部署到 GitHub Pages 和 Heroku<br>已移植 Octopress 插件<br>高扩展性、自订性<br>兼容于 Windows, Mac &amp; Linux</p>
</blockquote>
<p>我再加几条：</p>
<ul>
<li>易用。不仅部署简单，平时使用中仅需要<code>hexo new</code> <code>hexo generate</code> <code>hexo server</code> <code>hexo deploy</code>四个命令。不像Jekyll需要很多繁琐的<code>git</code>命令。</li>
<li>轻。文件少、小，易理解，方便自定义。</li>
<li>用户多。虽然赶不上Jekyll和Octopress，但遇到什么问题都能搜索到答案，或者找到同样使用hexo的用户进行参考和咨询。</li>
</ul>
<p>###谁能使用hexo<br>这是一个免费开源的博客程序，任何人都可以使用和修改。但是不同于wordpress，hexo由于需要使用<em>Github,Git,Markdown,Node.js</em>这样的工具，好多插件、widget都需要自己安装、设置。所以适合那些<strong>有一定计算机基础，喜欢折腾</strong>的人。但是，不要恐惧，只要跟着本教程走，就能很方便地让自己的博客”飞起来”。</p>
<p>###怎样搭建hexo博客<br>正题来了，请期待下一节。</p>
<p>###注意<br>本系列相关博客均根据hexo<strong>1.1.3</strong>版本，但更高版本也几乎完全适用。各版本所做更新修正，请参考<a href="https://github.com/tommy351/hexo/releases" target="_blank" rel="external">这里</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git push时重复输入用户名密码的问题]]></title>
      <url>http://codeinterviews.com/ssh-errors-with-github/</url>
      <content type="html"><![CDATA[<p>在windows上使用git来push到github服务器的时候，每次都需要填写用户名/邮箱、密码，很麻烦。最近用hexo写博客，需要频繁地进行博客配置和预览，而每次预览执行<code>hexo deploy</code>都需要输入用户名、密码验证，不胜其烦，今天下决心解决。</p>
<p>尽管github提供了<code>SSH</code>方式进行本地和服务端的链接，可是按照网站说明设置好之后，这个问题仍然得不到解决。尝试了好几次，最终用下面这个方法解决了。<br><a id="more"></a></p>
<ol>
<li>首先添加环境变量。<br><img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e51yjjv0okj20b00b5gmp.jpg" alt=""></li>
<li>在用户文件夹<code>如C:\Users\zhangsan</code>下新建一个名为<code>_netrc</code>的文件。</li>
<li>编辑该文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">machine github.com</span><br><span class="line">login zhangsan</span><br><span class="line">password 123456</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>保存。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在XP上安装WIN7]]></title>
      <url>http://codeinterviews.com/install-win7-on-xp/</url>
      <content type="html"><![CDATA[<p>从购入笔记本到现在已经装机无数了，无论是<em>Linux</em>系还是<em>Windows</em>系。昨天远程指导同学在XP上安装win7的时候还是遇到了一些问题，折腾一番才最终装机成功。在此记录一下装机过程及遇到的问题。</p>
<p>总的步骤如下：  </p>
<ol>
<li>下载win7操作系统（后缀为<code>.iso</code>）。  </li>
<li>做好文件备份，因为装机会改变C盘，有格式化的风险，存在C盘的用户文件需要保存到其他硬盘。重要文件如：<strong>收藏夹（可以用浏览器登陆账号同步到云端），”我的文档”里面的资料，桌面文件，C盘其他用户文件</strong>。  </li>
<li>下载UltraISO.exe文件，使用方法见网络。  </li>
<li>用U盘制作启动文件。  </li>
<li>重启电脑，设置启动顺序，选择<strong>USB</strong>为第一个。  </li>
<li>插入U盘开始全自动无人值守安装。  </li>
<li>装好系统后进行个性化设置，把系统自带软件插件卸载掉，用杀毒软件进行木马、风险插件、病毒的扫描。<a id="more"></a>
昨天在安装过程中，U盘启动制作好之后，重启电脑，总是提示下图错误:<br><img src="http://www.to668.com/uploadfile/2012/1231/20121231100709268.jpg" alt=""><br>问题可能出现在UltraIso这个软件，或者XP操作系统，或者BIOS设置，但是都进行了重试和排查，至今不知道真正原因在哪。</li>
</ol>
<p>后来打算再进原来的XP系统做些设置，发现开机蓝屏，进不去了。如下图：<br><img src="http://a1.att.hudong.com/33/30/19300001200921130525302854975.jpg" alt=""><br>在网上找到了原因，原来是同学不小心重新设置了<code>SATA Mode</code>为<code>AHCI模式</code>，这个模式XP默认是不支持的。方法就是改为其他模式，如<code>IDE</code>。</p>
<p>一番折腾后，原来的XP是进去了，可是我们的目标——装win7——还没实现。U盘安装尝试多次都不行，干脆放弃这种办法，采用硬盘直接安装。方法如下：  </p>
<blockquote>
<p>将下载的<code>.iso</code>系统文件解压到某个文件夹下（要求：非C盘，路径中没有中文字符），然后打开”安装win7.exe”，按照提示进行操作，会重启然后开始自动安装。  </p>
</blockquote>
<p>这是最简单的方法，前面走了些冤枉弯路。</p>
<p>老矣，不爱折腾系统了，自己的Win7变慢了也只是用软件优化优化。未来还想装一次黑苹果，从现在开始积累RP。嗯。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown指南]]></title>
      <url>http://codeinterviews.com/introduction-to-markdown/</url>
      <content type="html"><![CDATA[<p>前几天学习了markdown，然后一直在用，很喜欢这种<code>格式即内容</code>的写作形式。在<a href="http://jianshu.io/" target="_blank" rel="external">简书</a>写了几篇，对固定链接的格式很不满意，于是寻找能够支持markdown、固定链接显格式、支持自定义域名的博客平台。Github是个很好的选择，在折腾完Jekyll和Octopress几近筋疲力尽的时候，一束光芒照过来，我看到了<code>hexo</code>。<br>说远了…这篇文章是想介绍一下markdown这种写作形式。</p>
<p>本质上，类似于html，markdown也是一种标记型语言，ie，用某些字符（不像html用字符串）标示某种格式，只是标记格式不同罢了。<br>比如：<code>###Hello Word</code>，标示出helloword是三级标题，markdown进行渲染后就成了对应大小、加粗的格式。<br>介绍markdown的教程太多了，我不打算做无用的重复，给出我认为必读的几个供大家参考。<br><a id="more"></a></p>
<ol>
<li><a href="http://lutaf.com/markdown-simple-usage.htm" target="_blank" rel="external">鲁塔弗：markdown 简明语法</a></li>
<li><a href="http://www.ituring.com.cn/article/23" target="_blank" rel="external">图灵社区：怎样使用Markdown</a></li>
<li><a href="http://jianshu.io/p/q81RER" target="_blank" rel="external">简书：献给写作者的 Markdown 新手指南</a></li>
<li><a href="http://wowubuntu.com/markdown/#p" target="_blank" rel="external">官方文档(中文版)：Markdown 语法说明</a></li>
<li><a href="http://upwith.me/?p=503" target="_blank" rel="external">用Markdown来书写你的博客</a></li>
</ol>
<p>说明一下，上述1-3是并列关系，不同人总结的教程，建议都看。4比较繁琐，可以暂时不看，以后需要时再查询即可。<br>还有，markdown就这么点东西，学会了就一劳永逸了，性价比很高！</p>
<p>下面给出几个编辑器，大家边学边练。</p>
<ul>
<li><a href="http://jianshu.io/" target="_blank" rel="external">简书</a> 用微博登录，开始记笔记吧！</li>
<li><a href="https://chrome.google.com/webstore/detail/made/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="external">MaDe (Chrome插件)</a></li>
<li><a href="http://dillinger.io/" target="_blank" rel="external">dillinger</a></li>
<li><a href="http://benweet.github.io/stackedit/" target="_blank" rel="external">StackEdit</a> 由<a href="http://www.tangpro.com/" target="_blank" rel="external">TangPro</a>推荐。</li>
<li><a href="http://ghosertblog.github.io/mdeditor/" target="_blank" rel="external">Cmd - 在线 Markdown 编辑阅读器</a></li>
</ul>
<p>好了，开始你的markdown之旅吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开始使用hexo博客]]></title>
      <url>http://codeinterviews.com/hexo-starts/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近一直在选择一个适合自己的博客平台，把旧博文挪过去，新博文也在此开垦。<br>了解和尝试了很多博客，最终看到了hexo，很简单的配置、很漂亮的主题很实用的功能。<br>下面记录一下其他考虑过的博客的缺点（优点不必说了，存在即有合理性）。</p>
</blockquote>
<a id="more"></a>
<ol>
<li><p>点点、lofter   </p>
<ul>
<li>文章链接格式不好。</li>
</ul>
</li>
<li><p>tumblr</p>
<ul>
<li>墙、速度。</li>
</ul>
</li>
<li><p>wordpress</p>
<ul>
<li>需要VPS，不支持markdown。</li>
</ul>
</li>
<li><p>Typecho</p>
<ul>
<li>需要VPS，不够安全靠谱。</li>
</ul>
</li>
<li><p>Github</p>
<ul>
<li>折腾，折腾，折腾。</li>
</ul>
</li>
<li><p>farbox</p>
<ul>
<li>平台安全、稳定性。</li>
</ul>
</li>
<li><p>简书</p>
<ul>
<li>平台安全、稳定性；文章链接格式不好。</li>
</ul>
</li>
<li><p>csdn</p>
<ul>
<li>不支持绑定域名，不支持markdown。</li>
</ul>
</li>
<li><p>新浪博客（and all the like）</p>
<ul>
<li>乌七八糟；不支持绑定域名。</li>
</ul>
</li>
<li><p>blogger</p>
<ul>
<li>墙。</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
